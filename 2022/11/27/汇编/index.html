<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>汇编 | shimmer's blog</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>汇编</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-11-27T11:15:19.000Z" id="date"> 2022-11-27</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-03-04T11:39:05.677Z" id="updated"> 2023-03-04</time></div></span></div></div><hr><div id="post-content"><p>本文参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39654127/article/details/88698911?ops_request_misc=%7B%22request_id%22:%22167791908116800184162519%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167791908116800184162519&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88698911-null-null.142%5Ev73%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80&spm=1018.2226.3001.4187">(40条消息) 王爽《汇编语言》笔记（详细）_汇编语言笔记_洋葱汪的博客-CSDN博客</a></p>
<p>仅作自己学习参考，内容仅记录自己认为比较重要的，对于知识体系来说不全</p>
<h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一.基础知识"></a>一.基础知识</h2><h3 id="1-指令"><a href="#1-指令" class="headerlink" title="1.指令"></a>1.指令</h3><p>机器指令：CPU能直接识别并执行的二进制编码</p>
<p>汇编指令：汇编指令是机器指令的助记符，同机器指令一一对应。</p>
<p>指令：指令通常由操作码和地址码（操作数）两部分组成</p>
<p>指令集：每种CPU都有自己的汇编指令集。</p>
<p>编译器：够将汇编指令转换成机器指令的翻译程序每一种CPU都有自己的汇编指令集。</p>
<h3 id="2-存储器"><a href="#2-存储器" class="headerlink" title="2.存储器"></a>2.存储器</h3><p>随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储</p>
<p>只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失</p>
<h3 id="3-总线"><a href="#3-总线" class="headerlink" title="3.总线"></a>3.总线</h3><p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质。</p>
<p>根据传送信息的不同，系统总线从逻辑上分为3类，地址总线、控制总线和数据总线。</p>
<h2 id="二-寄存器"><a href="#二-寄存器" class="headerlink" title="二.寄存器"></a>二.寄存器</h2><h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h3><p>CPU由运算器、控制器、寄存器等器件构成，这些器件靠片内总线相连。</p>
<p>运算器进行信息处理；控制器控制各种器件进行工作；寄存器进行信息存储；</p>
<p>8086CPU有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW都是16位</p>
<p>8086采用小端模式：高地址存放高位字节，低地址存放低位字节</p>
<h3 id="2-通用寄存器"><a href="#2-通用寄存器" class="headerlink" title="2.通用寄存器"></a>2.通用寄存器</h3><p>通常用来存放一般性的数据，有AX、BX、CX、DX，它们可分为两个可独立使用的8位寄存器</p>
<table>
<thead>
<tr>
<th align="center">16位</th>
<th align="center">高八位</th>
<th align="center">低八位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AX</td>
<td align="center">AH</td>
<td align="center">AL</td>
</tr>
<tr>
<td align="center">BX</td>
<td align="center">BH</td>
<td align="center">BL</td>
</tr>
<tr>
<td align="center">CX</td>
<td align="center">CH</td>
<td align="center">CL</td>
</tr>
<tr>
<td align="center">DX</td>
<td align="center">DH</td>
<td align="center">DL</td>
</tr>
</tbody></table>
<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的</p>
<p>一个8位寄存器所能存储的数据范围是0 ~ 28-1。</p>
<h3 id="3、8086CPU给出物理地址的方法"><a href="#3、8086CPU给出物理地址的方法" class="headerlink" title="3、8086CPU给出物理地址的方法"></a>3、8086CPU给出物理地址的方法</h3><p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p>
<p>当8086CPU要读写内存时：</p>
<p>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；<br>地址加法器将两个16位地址合成为一个20位的物理地址；<br>地址加法器采用物理地址 &#x3D; 段地址×16 + 偏移地址的方法用段地址和偏移地址合成物理地址。</p>
<p>例如，8086CPU要访问地址为123C8H的内存单元，1230H左移一位(空出4位)加上00C8H合成123C8H</p>
<h3 id="4-段寄存器"><a href="#4-段寄存器" class="headerlink" title="4.段寄存器"></a>4.段寄存器</h3><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，可以用分段的方式来管理内存。</p>
<p>用一个段存放数据，将它定义为“数据段”；</p>
<p>用一个段存放代码，将它定义为“代码段”；</p>
<p>用一个段当作栈，将它定义为“栈段”。</p>
<p>注意：</p>
<p>一个段的起始地址一定是16的倍数；<br>偏移地址为16位，变化范围为0-FFFFH，所以一个段的长度最大为64KB。<br>CPU可以用不同的段地址和偏移地址形成同一个物理地址。<br>段寄存器：8086CPU有4个段寄存器：CS、DS、SS、ES，提供内存单元的段地址。</p>
<h4 id="1-CS和IP"><a href="#1-CS和IP" class="headerlink" title="1.CS和IP"></a>1.CS和IP</h4><p>CS为代码段寄存器，IP为指令指针寄存器，</p>
<p>CPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,</p>
<p>CPU将CS:IP指向的内容当作指令执行。(即PC)</p>
<p>8086CPU的工作过程简要描述</p>
<ol>
<li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP&#x3D;IP+所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。转到步骤1，重复这个过程</li>
</ol>
<h4 id="2-DS-和-address"><a href="#2-DS-和-address" class="headerlink" title="2.DS 和 [address]"></a>2.DS 和 [address]</h4><p>DS寄存器：通常用来存放要访问数据的段地址</p>
<p>[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中</p>
<p>通过数据段段地址和偏移地址即可定位内存单元。</p>
<h4 id="3-SS-和-SP"><a href="#3-SS-和-SP" class="headerlink" title="3.SS 和 SP"></a>3.SS 和 SP</h4><p>在基于8086CPU编程的时候，可以将一段内存当作栈来使用。</p>
<p>栈段寄存器SS，存放段地址，SP寄存器存放偏移地址，任意时刻，SS:SP指向栈顶元素</p>
<p>8086CPU中，入栈时，栈顶从高地址向低地址方向增长。</p>
<p>push ax表示将寄存器ax中的数据送入栈中，由两步完成。</p>
<p>SP&#x3D;SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；<br>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。</p>
<p>pop ax表示从栈顶取出数据送入ax，由以下两步完成。</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中；</li>
<li>SP&#x3D;SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ol>
<p>一看到这就想到脱壳了……</p>
<h2 id="三、第一个程序"><a href="#三、第一个程序" class="headerlink" title="三、第一个程序"></a>三、第一个程序</h2><p>汇编程序从写出到执行的过程：</p>
<p><img src="https://img-blog.csdnimg.cn/20190321114839761.png" alt="在这里插入图片描述"></p>
<p>加载后，CPU的CS:IP指向程序的第一条指令（即程序的入口）</p>
<h2 id="四、-bx-和-loop指令"><a href="#四、-bx-和-loop指令" class="headerlink" title="四、[bx] 和 loop指令"></a>四、[bx] 和 loop指令</h2><h3 id="1-bx-和-loop指令"><a href="#1-bx-和-loop指令" class="headerlink" title="1.[bx] 和 loop指令"></a>1.[bx] 和 loop指令</h3><p>[bx] 的含义：[bx]同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中</p>
<p>loop指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作:</p>
<p>(cx) &#x3D; (cx) - 1；</p>
<p>判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。</p>
<p>例如：计算2的12次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code <br><br>code segment <br>	mov ax, 2<br>	<br>	mov cx, 11 ;循环次数<br>s:  add ax, ax ;2+2  4+4  8+8<br>	loop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，<br>               ;这个地址处有一条指令：add ax，ax。<br>               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前<br>               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。<br>	<br>	mov ax,4c00h <br>	int 21h <br>code ends <br>end<br><br></code></pre></td></tr></table></figure>



<p>loop 和 [bx] 的联合应用</p>
<p>计算ffff:0 ~ ffff:b单元中的数据的和，结果存储在dx中</p>
<p>问题分析：</p>
<p>这些内存单元都是字节型数据范围0 ~ 255 ，12个字节数据和不会超过65535，dx可以存下<br>对于8位数据不能直接加到 dx<br>解决方案：</p>
<p>用一个16位寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器a中，再将ax中的数据加到dx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code <br><br>code segment <br>	mov ax, 0ffffh ;在汇编源程序中，数据不能以字母开头，所以要在前面加0。<br>	mov ds, ax    ;段地址默认在ds中<br>	mov bx, 0   ;初始化ds:bx指向ffff:0<br>	mov dx, 0   ;初始化累加寄存器dx，（dx）= 0<br>	<br>	mov cx, 12  ;初始化循环计数寄存器cx，（cx）= 12<br>s:  mov al, [bx]<br>	mov ah, 0<br>	add dx, ax  ;间接向dx中加上（（ds）* 16 +（bx））单元的数值<br>	inc bx      ;ds:bx指向下一个单元<br>	loop s <br>	<br>	mov ax, 4c00h <br>	int 21h <br>code ends <br>end<br><br></code></pre></td></tr></table></figure>



<h3 id="2-段前缀"><a href="#2-段前缀" class="headerlink" title="2.段前缀"></a>2.段前缀</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, ds:[bx]<br>mov ax, cs:[bx]<br>mov ax, ss:[bx]<br>mov ax, es:[bx]<br>mov ax, ss:[0]<br>mov ax, cs:[0]<br></code></pre></td></tr></table></figure>

<p>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址<br>的“ds:”，“cs:”，“ss:”，“es:”，在汇编语言中称为段前缀。</p>
<h3 id="3-段前缀的使用"><a href="#3-段前缀的使用" class="headerlink" title="3.段前缀的使用"></a>3.段前缀的使用</h3><p>将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code <br><br>code segment <br>	mov ax, 0ffffh <br>	mov ds, ax   ;（ds）= 0ffffh <br>	mov ax, 0020h<br>    mov es, ax   ;（es）= 0020h     0:200 等效于 0020:0<br>    mov bx, 0    ;（bx）= 0，此时ds:bx指向ffff:0，es:bx指向0020:0<br>    <br>	mov cx，12   ;（cx）=12，循环12次<br>s:  mov dl，[bx] ;（d1）=（（ds）* 16+（bx）），将ffff:bx中的字节数据送入dl <br>	mov es:[bx]，dl ;（（es）*16+（bx））=（d1），将dl中的数据送入0020:bx <br>	inc bx  ;（bx）=（bx）+1<br>	loop s <br>	<br>	mov ax，4c00h <br>	int 21h <br>code ends <br>end<br><br></code></pre></td></tr></table></figure>

<h2 id="五、包含多个段的程序"><a href="#五、包含多个段的程序" class="headerlink" title="五、包含多个段的程序"></a>五、包含多个段的程序</h2><p>在代码段中使用数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算 8 个数据的和存到 ax 寄存器<br>assume cs:code <br><br>code segment <br><br>	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据<br><br>	start:	mov bx, 0  ;标号start<br>			mov ax, 0  <br>			<br>			mov cx, 8<br>	s:		add ax, cs:[bx]<br>			add bx, 2<br>			loop s <br>			<br>			mov ax, 4c00h <br>			int 21h <br>code ends<br>end start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方<br>	     	 ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。<br><br></code></pre></td></tr></table></figure>

<p>在代码段中使用栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;利用栈，将程序中定义的数据逆序存放。<br>assume cs:codesg <br><br>codesg segment <br>	dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元<br>	dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用<br>			<br>	start:	mov ax, cs <br>			mov ss, ax <br>			mov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d<br>			mov bx, 0<br>			<br>			mov cx, 8<br>	s:		push cs:[bx]<br>			add bx, 2<br>			loop s    ;以上将代码段0~15单元中的8个字型数据依次入栈<br>			<br>			mov bx, 0<br>			<br>			mov cx, 8<br>	s0:		pop cs:[bx]		<br>			add bx，2<br>			loop s0   ;以上依次出栈8个字型数据到代码段0~15单元中<br>			<br>			mov ax，4c00h <br>			int 21h <br>codesg ends <br>end start	;指明程序的入口在start处<br><br></code></pre></td></tr></table></figure>

<h2 id="六、更灵活的定位内存地址的方法"><a href="#六、更灵活的定位内存地址的方法" class="headerlink" title="六、更灵活的定位内存地址的方法"></a>六、更灵活的定位内存地址的方法</h2><h3 id="1、and-和-or"><a href="#1、and-和-or" class="headerlink" title="1、and 和 or"></a>1、and 和 or</h3><p>and指令：逻辑与指令，按位进行与运算。</p>
<p>mov al, 01100011B<br>and al, 00111011B</p>
<p>执行后：al&#x3D;00100011B即都为1才为1</p>
<p>or指令：逻辑或指令，按位进行或运算。</p>
<p>mov al, 01100011B<br>or al, 00111011B<br>执行后：al&#x3D;01111011B 即只要有一个为1就为1</p>
<h3 id="2-bx-idata"><a href="#2-bx-idata" class="headerlink" title="2.[bx+idata]"></a>2.[bx+idata]</h3><p>[bx+idata]表示一个内存单元, 例如：<code>mov ax, [bx+200]</code><br>该指令也可以写成如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, [200+bx]<br><br>mov ax, 200[bx]<br><br>mov ax, [bx].200<br></code></pre></td></tr></table></figure>



<p>用[bx+idata]的方式进行数组的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:datasg <br><br>datasg segment <br>	db &#x27;BaSiC&#x27;;转为大写<br>	db &#x27;MinIx&#x27;;转为小写<br>datasg ends<br><br>codesg segment<br>	start:<br>		mov ax, datasg <br>		mov ds, ax <br>		mov bx, 0  ;初始ds:bx<br>	<br>		mov cx, 5<br>	s:	mov al, 0[bx]  ;注意这种写法，有三种等效写法<br>		and al, 11011111b ;转为大写字母<br>		mov 0[bx], al ;写回<br>		mov al, 5[bx]  ;[5 + bx]<br>		or al, 00100000b ;转为小写字母<br>		mov 5[bx], al <br>		inc bx<br>		loop s<br>		<br>		mov ax, 4c00h <br>		int 21h<br>codesg ends<br>end start<br><br></code></pre></td></tr></table></figure>

<p>用c语言表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;BaSic&quot;</span>;<br>	<span class="hljs-type">char</span> b[] = <span class="hljs-string">&quot;MinIX&quot;</span>;<br>	<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-keyword">do</span><br>	&#123;<br>		a[i] = a[i] &amp; <span class="hljs-number">0xDF</span>;<br>		b[i] = b[i] | <span class="hljs-number">0x20</span>;<br>		i++;<br>	&#125; <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">5</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br><br></code></pre></td></tr></table></figure>

<h3 id="3、SI-、DI-与-寻址方式的灵活应用"><a href="#3、SI-、DI-与-寻址方式的灵活应用" class="headerlink" title="3、SI 、DI 与 寻址方式的灵活应用"></a>3、SI 、DI 与 寻址方式的灵活应用</h3><h4 id="1、si-、di"><a href="#1、si-、di" class="headerlink" title="1、si 、di"></a>1、si 、di</h4><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs: codesg, ds: datasg <br><br>datasg segment <br>	db &#x27;welcome to masm!&#x27;;用si和di实现将字符串‘welcome to masm！&quot;复制到它后面的数据区中。<br>	db &#x27;................&#x27;<br>datasg ends<br><br>codesg segment <br>	start:	mov ax, datasg <br>			mov ds, ax <br>			mov si, 0<br>			<br>			mov cx, 8<br>	s:		mov ax, 0[si] ;[0 + si]<br>			mov 16[si], ax ;[16 + si] 使用[bx +idata]方式代替di，使程序更简洁<br>			add si, 2 <br>			loop s <br>			<br>			mov ax, 4c00h <br>			int 21h <br>codesg ends <br>end start<br><br></code></pre></td></tr></table></figure>

<h4 id="2、-bx-si-和-bx-di"><a href="#2、-bx-si-和-bx-di" class="headerlink" title="2、[bx + si] 和 [bx + di]"></a>2、[bx + si] 和 [bx + di]</h4><p>[bx+si]和[bx+di]的含义相似</p>
<p>[bx+si]表示一个内存单元，它的偏移地址为（bx）+（si）</p>
<p>指令mov ax, [bx + si]的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p>
<p>该指令也可以写成如下格式：mov ax, [bx] [si]</p>
<h4 id="3、-bx-si-idata-和-bx-di-idata"><a href="#3、-bx-si-idata-和-bx-di-idata" class="headerlink" title="3、[bx+si+idata]和[bx+di+idata]"></a>3、[bx+si+idata]和[bx+di+idata]</h4><p>[bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+idata</p>
<p>指令mov ax，[bx+si+idata]的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p>
<h4 id="4、不同的寻址方式的灵活应用"><a href="#4、不同的寻址方式的灵活应用" class="headerlink" title="4、不同的寻址方式的灵活应用"></a>4、不同的寻址方式的灵活应用</h4><ul>
<li>[idata]用一个常量来表示地址，可用于直接定位一个内存单元；</li>
<li>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；</li>
<li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；</li>
<li>[bx+si]用两个变量表示地址；</li>
<li>[bx+si+idata]用两个变量和一个常量表示地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs assembly"><br>;将datasg段中每个单词改为大写字母<br>assume cs:codesg,ds:datasg,ss:stacksg <br><br>datasg segment<br>	db &#x27;ibm            &#x27; ;16<br>	db &#x27;dec            &#x27; <br>	db &#x27;dos            &#x27;<br>	db &#x27;vax            &#x27;  ;看成二维数组<br>datasg ends <br><br>stacksg segment ;定义一个段，用来做栈段，容量为16个字节<br>	dw 0, 0, 0, 0, 0, 0, 0, 0<br>stacksg ends <br><br>codesg segment <br>	start:	mov ax, stacksg <br>			mov ss, ax<br>			mov sp, 16 <br>			mov ax, datasg <br>			mov ds, ax <br>			mov bx, 0 ;初始ds:bx<br>			<br>			;cx为默认循环计数器，二重循环只有一个计数器，所以外层循环先保存cx值，再恢复，我们采用栈保存<br>			mov cx, 4<br>	s0:		push cx	;将外层循环的cx值入栈<br>			mov si, 0<br>			mov cx, 3	;cx设置为内层循环的次数<br>	s:		mov al, [bx+si]<br>			and al, 11011111b ;每个字符转为大写字母<br>			mov [bx+si], al <br>			inc si<br>			loop s <br>			<br>			add bx, 16 ;下一行<br>			pop cx	;恢复cx值<br>			loop s0 ;外层循环的loop指令将cx中的计数值减1<br>			<br>			mov ax，4c00H <br>			int 21H <br>codesg ends<br>end start<br><br></code></pre></td></tr></table></figure>

<h2 id="七、数据处理的两个基本问题"><a href="#七、数据处理的两个基本问题" class="headerlink" title="七、数据处理的两个基本问题"></a>七、数据处理的两个基本问题</h2><h3 id="1、-bx、si、di和bp"><a href="#1、-bx、si、di和bp" class="headerlink" title="1、 bx、si、di和bp"></a>1、 bx、si、di和bp</h3><p>在8086CPU中，只有这4个寄存器可以用在“[…]”中来进行内存单元的寻址。</p>
<p>在[ ]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di。</p>
<p>只要在[……]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中</p>
<h3 id="2、机器指令处理的数据在什么地方"><a href="#2、机器指令处理的数据在什么地方" class="headerlink" title="2、机器指令处理的数据在什么地方"></a>2、机器指令处理的数据在什么地方</h3><p>数据处理大致可分为3类：读取、写入、运算。</p>
<p>在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：<strong>CPU内部、内存、端口</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2019032120283492.png" alt="在这里插入图片描述"></p>
<h3 id="3、汇编语言中数据位置的表达"><a href="#3、汇编语言中数据位置的表达" class="headerlink" title="3、汇编语言中数据位置的表达"></a>3、汇编语言中数据位置的表达</h3><p>汇编语言中用3个概念来表达数据的位置</p>
<ul>
<li>立即数（idata）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, 1                 ;对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）<br>add bx, 2000h             ;在汇编语言中称为：立即数（idata）<br>or bx, 00010000b<br>mov al, &#x27;a&#x27;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, bx     ;指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。<br>mov ds, ax <br>push bx <br>mov ds:[0], bx <br>push ds <br>mov ss, ax<br>mov sp, ax<br></code></pre></td></tr></table></figure>

<ul>
<li>段地址（SA）和偏移地址（EA）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。<br>mov ax, [0]<br>mov ax, [di]<br>mov ax, [bx+8]<br>mov ax, [bx+si]<br>mov ax, [bx+si+8]   ;以上段地址默认在ds中<br><br>mov ax, [bp]<br>mov ax, [bp+8]<br>mov ax, [bp+si]<br>mov ax, [bp+si+8]   ;以上段地址默认在ss中<br><br>mov ax, ds:[bp]<br>mov ax, es:[bx]<br>mov ax, ss:[bx+si]<br>mov ax, cs:[bx+si+8] ;显式给出存放段地址的寄存器<br><br></code></pre></td></tr></table></figure>

<p>寻址方式</p>
<p><img src="https://img-blog.csdnimg.cn/20190321213006102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4、指令要处理的数据有多长"><a href="#4、指令要处理的数据有多长" class="headerlink" title="4、指令要处理的数据有多长"></a>4、指令要处理的数据有多长</h3><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word</p>
<ul>
<li>通过寄存器名指明要处理的数据的尺寸。<br>例如： mov al, ds:[0] 寄存器al指明了数据为1字节</li>
<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。<br>例如：mov byte ptr ds:[0], 1 byte ptr 指明了指令访问的内存单元是一个字节单元</li>
<li>有些指令默认了访问的是字单元还是字节单元<br>例如，push [1000H]，push 指令只进行字操作。</li>
</ul>
<h3 id="5、寻址方式的综合应用"><a href="#5、寻址方式的综合应用" class="headerlink" title="5、寻址方式的综合应用"></a>5、寻址方式的综合应用</h3><p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, seg <br>mov ds, ax <br>mov bx, 60h   ;确定记录地址，ds:bx <br><br>mov word ptr [bx+0ch], 38   ;排名字段改为38  [bx].0ch<br>add word ptr [bx+0eh], 70   ;收入字段增加70  [bx].0eh<br>mov si, 0   ;用si来定位产品字符串中的字符<br>mov byte ptr [bx+10h+si], &#x27;V&#x27;   ;[bx].10h[si]<br>inc si <br>mov byte ptr [bx+10h+si], &#x27;A&#x27;<br>inc si <br>mov byte ptr [bx+10h+si], &#x27;X&#x27;<br><br></code></pre></td></tr></table></figure>

<p>C语言描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*定义一个公司记录的结构体*/<br>struct company<br>&#123;<br>    char cn[3];/*公司名称*/<br>    char hn[9];/*总裁姓名*/<br>    int pm;/*排名*/<br>    int sr;/*收入*/<br>    char cp[3];/*著名产品*/<br>&#125;;<br>//sizeof (struct company) == 24<br><br>int main()<br>&#123;<br>    /*定义一个公司记录的变量，内存中将存有一条公司的记录*/<br>    struct company dec = &#123;&quot;DEC&quot;, &quot;Ken Olsen&quot;, 137, 40, &quot;PDP&quot;&#125;;<br><br>    int i;<br><br>    dec.pm = 38;<br>    dec.sr = dec.sr + 70;<br><br>    i = 0;<br>    dec.cp[i] = &#x27;V&#x27;; //mov byte ptr [bx].10h[si], &#x27;V&#x27;<br>    i++;<br>    dec.cp[i] = &#x27;A&#x27;;<br>    i++;<br>    dec.cp[i] = &#x27;X&#x27;;<br><br>    return 0;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="6、div指令、dd、dup、mul指令"><a href="#6、div指令、dd、dup、mul指令" class="headerlink" title="6、div指令、dd、dup、mul指令"></a>6、div指令、dd、dup、mul指令</h3><p>div是除法指令</p>
<p>除数：有8位和16位两种，在一个<strong>寄存器</strong>或<strong>内存单元</strong>中。</p>
<p>被除数：默认放在<strong>AX</strong>或<strong>DX和AX</strong>中，<br>如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除数为16位，被除数则为32位，在DX和AX中存放，<strong>DX存放高16位，AX存放低16位。</strong></p>
<p>结果：<br>如果除数为8位，则<strong>AL存储除法操作的商，AH存储除法操作的余数；</strong><br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;利用除法指令计算100001/100。<br>;100001D = 186A1H<br>mov dx, 1;高16位<br>mov ax, 86A1H ;(dx)*10000H+(ax)=100001  低16位<br>mov bx, 100;除数<br>div bx   ;div 除数  被除数默认在dx和ax中存放<br><br>;利用除法指令计算1001/100  这个是8位的除法<br>mov ax, 1001<br>mov bl, 100<br>div b1<br><br></code></pre></td></tr></table></figure>

<p><strong>伪指令dd</strong></p>
<p>db和dw定义字节型数据和字型数据。</p>
<p>dd是用来定义dword（double word，双字）型数据的伪指令</p>
<p><strong>操作符dup</strong></p>
<p>dup在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。<br>它和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">db 3 dup (0)       ;定义了3个字节，它们的值都是0，相当于db 0，0，0。<br>db 3 dup (0, 1, 2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0，1，2，0，1，2，0，1，2。<br>db 3 dup (&#x27;abc&#x27;, &#x27;ABC&#x27;) ;定义了18个字节，它们是abcABCabcABCabcABCC，相当于db &#x27;abc&#x27;, &#x27;ABC&#x27; ,&#x27;abc&#x27; , &#x27;ABC, &#x27;abc&#x27;, &#x27;ABC&#x27;。<br><br></code></pre></td></tr></table></figure>

<p><strong>mul 指令</strong></p>
<p>mul是乘法指令，使用 mul 做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。</p>
<p>8 位： AL中和 8位寄存器或内存字节单元中；</p>
<p>16 位： AX中和 16 位寄存器或内存字单元中。</p>
<p>结果</p>
<p>8位：AX中；</p>
<p>16位：DX（高位）和 AX（低位）中。</p>
<p>格式：&#x3D;&#x3D;mul 寄存器&#x3D;&#x3D; 或 &#x3D;&#x3D;mul 内存单元&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算100*10<br>;100和10小于255，可以做8位乘法<br>mov al,100<br>mov bl,10<br>mul bl ;默认其中一个就是在al中（八位）<br><br>;结果： (ax)=1000（03E8H） <br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算100*10000<br>;100小于255，可10000大于255，所以必须做16位乘法，程序如下：<br>mov ax,100<br>mov bx,10000<br>mul bx<br><br>;结果： (ax)=4240H，(dx)=000FH     （F4240H=1000000）<br></code></pre></td></tr></table></figure>

<h2 id="八、转移指令的原理"><a href="#八、转移指令的原理" class="headerlink" title="八、转移指令的原理"></a>八、转移指令的原理</h2><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
<p>8086CPU的转移行为有以下几类。</p>
<p>只修改IP时，称为&#x3D;&#x3D;段内转移&#x3D;&#x3D;，比如：&#x3D;&#x3D;jmp ax&#x3D;&#x3D;。<br>同时修改CS和IP时，称为&#x3D;&#x3D;段间转移&#x3D;&#x3D;，比如：&#x3D;&#x3D;jmp 1000:0&#x3D;&#x3D;。</p>
<p>由于转移指令对IP的修改范围不同，段内转移又分为：&#x3D;&#x3D;短转移和近转移&#x3D;&#x3D;</p>
<p>短转移IP的修改范围为&#x3D;&#x3D;-128 ~ 127&#x3D;&#x3D;。<br>近转移IP的修改范围为&#x3D;&#x3D;-32768 ~ 32767&#x3D;&#x3D;。</p>
<p>8086CPU的转移指令分为以下几类</p>
<ul>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
<h3 id="1、操作符offset"><a href="#1、操作符offset" class="headerlink" title="1、操作符offset"></a>1、操作符offset</h3><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;将s处的一条指令复制到s0处<br>assume cs:codesg<br>codesg segment<br> s:   mov ax, bx           ;（mov ax,bx 的机器码占两个字节）<br>      mov si, offset s     ;获得标号s的偏移地址<br>      mov di, offset s0    ;获得标号s0的偏移地址<br>      <br>      mov ax, cs:[si]<br>      mov cs:[di], ax<br> s0:  nop                     ;（nop的机器码占一个字节）<br>      nop<br> codesg ends<br> ends<br><br></code></pre></td></tr></table></figure>



<h3 id="2、jmp指令"><a href="#2、jmp指令" class="headerlink" title="2、jmp指令"></a>2、jmp指令</h3><p>jmp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；</p>
<p>jmp指令要给出两种信息：</p>
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移，段内近转移）</li>
</ul>
<p> jmp short 标号， jmp near ptr 标号， jcxz 标号， loop 标号   等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p>
<p><strong>依据位移进行转移的jmp指令</strong><br><strong>jmp short 标号&#x3D;&#x3D;（段内短转移）&#x3D;&#x3D;</strong></p>
<p>指令“jmp short 标号”的功能为(IP)&#x3D;(IP)+8位位移，转到标号处执行指令</p>
<p>（1）8位位移 &#x3D; “标号”处的地址 - jmp指令后的第一个字节的地址；</p>
<p>（2）short指明此处的位移为8位位移；</p>
<p>（3）8位位移的范围为-128~127，用补码表示</p>
<p>（4）8位位移由编译程序在编译时算出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br>codesg segment<br>  start:mov ax,0<br>        jmp short s ;s不是被翻译成目的地址<br>        add ax, 1<br>      s:inc ax ;程序执行后， ax中的值为 1 <br>codesg ends<br>end start<br><br></code></pre></td></tr></table></figure>

<p>CPU不需要这个目的地址就可以实现对IP的修改。这里是依据&#x3D;&#x3D;位移进行转移&#x3D;&#x3D;</p>
<p><strong>jmp short s指令的读取和执行过程：</strong></p>
<p>(CS)&#x3D;0BBDH，(IP)&#x3D;0006，上一条指令执行结束后CS:IP指向EB 03（jmp short s的机器码）；<br>读取指令码EB 03进入指令缓冲器；<br>(IP) &#x3D; (IP) + 所读取指令的长度 &#x3D; (IP) + 2 &#x3D; 0008，CS:IP指向add ax,1；<br>CPU指行指令缓冲器中的指令EB 03；<br>指令EB 03执行后，(IP)&#x3D;000BH，CS:IP指向inc ax</p>
<p><strong>jmp near ptr 标号 &#x3D;&#x3D;（段内近转移）&#x3D;&#x3D;</strong></p>
<p>指令“jmp near ptr 标号”的功能为：**(IP) &#x3D; (IP) + 16位位移**。</p>
<p><strong>转移的目的地址在指令中的jmp指令</strong></p>
<p><strong>jmp far ptr 标号&#x3D;&#x3D;（段间转移或远转移）&#x3D;&#x3D;</strong></p>
<p>指令jmp far ptr 标号 功能如下：</p>
<ul>
<li>(CS) &#x3D; 标号所在段的段地址；</li>
<li>(IP) &#x3D; 标号所在段中的偏移地址。</li>
<li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</li>
</ul>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/12/13/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E9%A2%98/">← Next c语言讲座</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/11/27/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/">加解密算法及其特征 Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://raw.githubusercontent.com/shimmer123456/img/main/img/touxiang.png" alt="Logo"></a><h1 id="Dr"><a href="/">shimmer</a></h1><div id="description"><p>一</p><p>些</p><p>小</p><p>笔</p><p>记</p><p>或</p><p>是</p><p>小</p><p>感</p><p>悟</p></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">一.基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">1.指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2.存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BA%BF"><span class="toc-number">1.3.</span> <span class="toc-text">3.总线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二.寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1.寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2.通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%818086CPU%E7%BB%99%E5%87%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">3、8086CPU给出物理地址的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4.段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CS%E5%92%8CIP"><span class="toc-number">2.4.1.</span> <span class="toc-text">1.CS和IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DS-%E5%92%8C-address"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.DS 和 [address]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SS-%E5%92%8C-SP"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.SS 和 SP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">三、第一个程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-bx-%E5%92%8C-loop%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">四、[bx] 和 loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bx-%E5%92%8C-loop%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">1.[bx] 和 loop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AE%B5%E5%89%8D%E7%BC%80"><span class="toc-number">4.2.</span> <span class="toc-text">2.段前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AE%B5%E5%89%8D%E7%BC%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3.段前缀的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">五、包含多个段的程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">六、更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81and-%E5%92%8C-or"><span class="toc-number">6.1.</span> <span class="toc-text">1、and 和 or</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-bx-idata"><span class="toc-number">6.2.</span> <span class="toc-text">2.[bx+idata]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81SI-%E3%80%81DI-%E4%B8%8E-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">3、SI 、DI 与 寻址方式的灵活应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81si-%E3%80%81di"><span class="toc-number">6.3.1.</span> <span class="toc-text">1、si 、di</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81-bx-si-%E5%92%8C-bx-di"><span class="toc-number">6.3.2.</span> <span class="toc-text">2、[bx + si] 和 [bx + di]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81-bx-si-idata-%E5%92%8C-bx-di-idata"><span class="toc-number">6.3.3.</span> <span class="toc-text">3、[bx+si+idata]和[bx+di+idata]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">6.3.4.</span> <span class="toc-text">4、不同的寻址方式的灵活应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">七、数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-bx%E3%80%81si%E3%80%81di%E5%92%8Cbp"><span class="toc-number">7.1.</span> <span class="toc-text">1、 bx、si、di和bp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="toc-number">7.2.</span> <span class="toc-text">2、机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-number">7.3.</span> <span class="toc-text">3、汇编语言中数据位置的表达</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%8C%87%E4%BB%A4%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%89%E5%A4%9A%E9%95%BF"><span class="toc-number">7.4.</span> <span class="toc-text">4、指令要处理的数据有多长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.</span> <span class="toc-text">5、寻址方式的综合应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81div%E6%8C%87%E4%BB%A4%E3%80%81dd%E3%80%81dup%E3%80%81mul%E6%8C%87%E4%BB%A4"><span class="toc-number">7.6.</span> <span class="toc-text">6、div指令、dd、dup、mul指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">八、转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6offset"><span class="toc-number">8.1.</span> <span class="toc-text">1、操作符offset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.</span> <span class="toc-text">2、jmp指令</span></a></li></ol></li></ol></div></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>