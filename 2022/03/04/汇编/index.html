<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>汇编 | shimmer's blog</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>汇编</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-03-04T06:15:19.000Z" id="date"> 2022-03-04</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-03-04T14:03:45.154Z" id="updated"> 2023-03-04</time></div></span></div></div><hr><div id="post-content"><p>本文参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39654127/article/details/88698911?ops_request_misc=%7B%22request_id%22:%22167791908116800184162519%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167791908116800184162519&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88698911-null-null.142%5Ev73%5Epc_new_rank,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80&spm=1018.2226.3001.4187">(40条消息) 王爽《汇编语言》笔记（详细）_汇编语言笔记_洋葱汪的博客-CSDN博客</a></p>
<p>仅作自己学习参考，内容仅记录自己认为比较重要的，对于知识体系来说不全</p>
<p>放在博客这格式就有点不对劲，代码块明明设置的assembly，但是现实的是text，高亮也显示不了，也许是这个主题的问题，但本地显示都没问题，不管了</p>
<h2 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一.基础知识"></a>一.基础知识</h2><h3 id="1-指令"><a href="#1-指令" class="headerlink" title="1.指令"></a>1.指令</h3><p>机器指令：CPU能直接识别并执行的二进制编码</p>
<p>汇编指令：汇编指令是机器指令的助记符，同机器指令一一对应。</p>
<p>指令：指令通常由操作码和地址码（操作数）两部分组成</p>
<p>指令集：每种CPU都有自己的汇编指令集。</p>
<p>编译器：够将汇编指令转换成机器指令的翻译程序每一种CPU都有自己的汇编指令集。</p>
<h3 id="2-存储器"><a href="#2-存储器" class="headerlink" title="2.存储器"></a>2.存储器</h3><p>随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储</p>
<p>只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失</p>
<h3 id="3-总线"><a href="#3-总线" class="headerlink" title="3.总线"></a>3.总线</h3><p>总线是连接各个部件的信息传输线，是各个部件共享的传输介质。</p>
<p>根据传送信息的不同，系统总线从逻辑上分为3类，地址总线、控制总线和数据总线。</p>
<h2 id="二-寄存器"><a href="#二-寄存器" class="headerlink" title="二.寄存器"></a>二.寄存器</h2><h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1.寄存器"></a>1.寄存器</h3><p>CPU由运算器、控制器、寄存器等器件构成，这些器件靠片内总线相连。</p>
<p>运算器进行信息处理；控制器控制各种器件进行工作；寄存器进行信息存储；</p>
<p>8086CPU有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW都是16位</p>
<p>8086采用小端模式：高地址存放高位字节，低地址存放低位字节</p>
<h3 id="2-通用寄存器"><a href="#2-通用寄存器" class="headerlink" title="2.通用寄存器"></a>2.通用寄存器</h3><p>通常用来存放一般性的数据，有AX、BX、CX、DX，它们可分为两个可独立使用的8位寄存器</p>
<table>
<thead>
<tr>
<th align="center">16位</th>
<th align="center">高八位</th>
<th align="center">低八位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AX</td>
<td align="center">AH</td>
<td align="center">AL</td>
</tr>
<tr>
<td align="center">BX</td>
<td align="center">BH</td>
<td align="center">BL</td>
</tr>
<tr>
<td align="center">CX</td>
<td align="center">CH</td>
<td align="center">CL</td>
</tr>
<tr>
<td align="center">DX</td>
<td align="center">DH</td>
<td align="center">DL</td>
</tr>
</tbody></table>
<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的</p>
<p>一个8位寄存器所能存储的数据范围是0 ~ 28-1。</p>
<h3 id="3-8086CPU给出物理地址的方法"><a href="#3-8086CPU给出物理地址的方法" class="headerlink" title="3.8086CPU给出物理地址的方法"></a>3.8086CPU给出物理地址的方法</h3><p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p>
<p>当8086CPU要读写内存时：</p>
<p>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；<br>地址加法器将两个16位地址合成为一个20位的物理地址；<br>地址加法器采用物理地址 &#x3D; 段地址×16 + 偏移地址的方法用段地址和偏移地址合成物理地址。</p>
<p>例如，8086CPU要访问地址为123C8H的内存单元，1230H左移一位(空出4位)加上00C8H合成123C8H</p>
<h3 id="4-段寄存器"><a href="#4-段寄存器" class="headerlink" title="4.段寄存器"></a>4.段寄存器</h3><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，可以用分段的方式来管理内存。</p>
<p>用一个段存放数据，将它定义为“数据段”；</p>
<p>用一个段存放代码，将它定义为“代码段”；</p>
<p>用一个段当作栈，将它定义为“栈段”。</p>
<p>注意：</p>
<p>一个段的起始地址一定是16的倍数；<br>偏移地址为16位，变化范围为0-FFFFH，所以一个段的长度最大为64KB。<br>CPU可以用不同的段地址和偏移地址形成同一个物理地址。<br>段寄存器：8086CPU有4个段寄存器：CS、DS、SS、ES，提供内存单元的段地址。</p>
<h4 id="1-CS和IP"><a href="#1-CS和IP" class="headerlink" title="1.CS和IP"></a>1.CS和IP</h4><p>CS为代码段寄存器，IP为指令指针寄存器，</p>
<p>CPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,</p>
<p>CPU将CS:IP指向的内容当作指令执行。(即PC)</p>
<p>8086CPU的工作过程简要描述</p>
<ol>
<li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP&#x3D;IP+所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。转到步骤1，重复这个过程</li>
</ol>
<h4 id="2-DS-和-address"><a href="#2-DS-和-address" class="headerlink" title="2.DS 和 [address]"></a>2.DS 和 [address]</h4><p>DS寄存器：通常用来存放要访问数据的段地址</p>
<p>[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中</p>
<p>通过数据段段地址和偏移地址即可定位内存单元。</p>
<h4 id="3-SS-和-SP"><a href="#3-SS-和-SP" class="headerlink" title="3.SS 和 SP"></a>3.SS 和 SP</h4><p>在基于8086CPU编程的时候，可以将一段内存当作栈来使用。</p>
<p>栈段寄存器SS，存放段地址，SP寄存器存放偏移地址，任意时刻，SS:SP指向栈顶元素</p>
<p>8086CPU中，入栈时，栈顶从高地址向低地址方向增长。</p>
<p>push ax表示将寄存器ax中的数据送入栈中，由两步完成。</p>
<p>SP&#x3D;SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；<br>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。</p>
<p>pop ax表示从栈顶取出数据送入ax，由以下两步完成。</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中；</li>
<li>SP&#x3D;SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ol>
<p>一看到这就想到脱壳了……</p>
<h2 id="三-第一个程序"><a href="#三-第一个程序" class="headerlink" title="三.第一个程序"></a>三.第一个程序</h2><p>汇编程序从写出到执行的过程：</p>
<p><img src="https://img-blog.csdnimg.cn/20190321114839761.png" alt="在这里插入图片描述"></p>
<p>加载后，CPU的CS:IP指向程序的第一条指令（即程序的入口）</p>
<h2 id="四-bx-和-loop指令"><a href="#四-bx-和-loop指令" class="headerlink" title="四.[bx] 和 loop指令"></a>四.[bx] 和 loop指令</h2><h3 id="1-bx-和-loop指令"><a href="#1-bx-和-loop指令" class="headerlink" title="1.[bx] 和 loop指令"></a>1.[bx] 和 loop指令</h3><p>[bx] 的含义：[bx]同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中</p>
<p>loop指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作:</p>
<p>(cx) &#x3D; (cx) - 1；</p>
<p>判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。</p>
<p>例如：计算2的12次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code <br><br>code segment <br>	mov ax, 2<br>	<br>	mov cx, 11 ;循环次数<br>s:  add ax, ax ;2+2  4+4  8+8<br>	loop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，<br>               ;这个地址处有一条指令：add ax，ax。<br>               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前<br>               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。<br>	<br>	mov ax,4c00h <br>	int 21h <br>code ends <br>end<br><br></code></pre></td></tr></table></figure>



<p>loop 和 [bx] 的联合应用</p>
<p>计算ffff:0 ~ ffff:b单元中的数据的和，结果存储在dx中</p>
<p>问题分析：</p>
<p>这些内存单元都是字节型数据范围0 ~ 255 ，12个字节数据和不会超过65535，dx可以存下<br>对于8位数据不能直接加到 dx<br>解决方案：</p>
<p>用一个16位寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器a中，再将ax中的数据加到dx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code <br><br>code segment <br>	mov ax, 0ffffh ;在汇编源程序中，数据不能以字母开头，所以要在前面加0。<br>	mov ds, ax    ;段地址默认在ds中<br>	mov bx, 0   ;初始化ds:bx指向ffff:0<br>	mov dx, 0   ;初始化累加寄存器dx，（dx）= 0<br>	<br>	mov cx, 12  ;初始化循环计数寄存器cx，（cx）= 12<br>s:  mov al, [bx]<br>	mov ah, 0<br>	add dx, ax  ;间接向dx中加上（（ds）* 16 +（bx））单元的数值<br>	inc bx      ;ds:bx指向下一个单元<br>	loop s <br>	<br>	mov ax, 4c00h <br>	int 21h <br>code ends <br>end<br><br></code></pre></td></tr></table></figure>



<h3 id="2-段前缀"><a href="#2-段前缀" class="headerlink" title="2.段前缀"></a>2.段前缀</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, ds:[bx]<br>mov ax, cs:[bx]<br>mov ax, ss:[bx]<br>mov ax, es:[bx]<br>mov ax, ss:[0]<br>mov ax, cs:[0]<br></code></pre></td></tr></table></figure>

<p>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址<br>的“ds:”，“cs:”，“ss:”，“es:”，在汇编语言中称为段前缀。</p>
<h3 id="3-段前缀的使用"><a href="#3-段前缀的使用" class="headerlink" title="3.段前缀的使用"></a>3.段前缀的使用</h3><p>将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code <br><br>code segment <br>	mov ax, 0ffffh <br>	mov ds, ax   ;（ds）= 0ffffh <br>	mov ax, 0020h<br>    mov es, ax   ;（es）= 0020h     0:200 等效于 0020:0<br>    mov bx, 0    ;（bx）= 0，此时ds:bx指向ffff:0，es:bx指向0020:0<br>    <br>	mov cx，12   ;（cx）=12，循环12次<br>s:  mov dl，[bx] ;（d1）=（（ds）* 16+（bx）），将ffff:bx中的字节数据送入dl <br>	mov es:[bx]，dl ;（（es）*16+（bx））=（d1），将dl中的数据送入0020:bx <br>	inc bx  ;（bx）=（bx）+1<br>	loop s <br>	<br>	mov ax，4c00h <br>	int 21h <br>code ends <br>end<br><br></code></pre></td></tr></table></figure>

<h2 id="五-包含多个段的程序"><a href="#五-包含多个段的程序" class="headerlink" title="五.包含多个段的程序"></a>五.包含多个段的程序</h2><p>在代码段中使用数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算 8 个数据的和存到 ax 寄存器<br>assume cs:code <br><br>code segment <br><br>	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据<br><br>	start:	mov bx, 0  ;标号start<br>			mov ax, 0  <br>			<br>			mov cx, 8<br>	s:		add ax, cs:[bx]<br>			add bx, 2<br>			loop s <br>			<br>			mov ax, 4c00h <br>			int 21h <br>code ends<br>end start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方<br>	     	 ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。<br><br></code></pre></td></tr></table></figure>

<p>在代码段中使用栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;利用栈，将程序中定义的数据逆序存放。<br>assume cs:codesg <br><br>codesg segment <br>	dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元<br>	dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用<br>			<br>	start:	mov ax, cs <br>			mov ss, ax <br>			mov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d<br>			mov bx, 0<br>			<br>			mov cx, 8<br>	s:		push cs:[bx]<br>			add bx, 2<br>			loop s    ;以上将代码段0~15单元中的8个字型数据依次入栈<br>			<br>			mov bx, 0<br>			<br>			mov cx, 8<br>	s0:		pop cs:[bx]		<br>			add bx，2<br>			loop s0   ;以上依次出栈8个字型数据到代码段0~15单元中<br>			<br>			mov ax，4c00h <br>			int 21h <br>codesg ends <br>end start	;指明程序的入口在start处<br><br></code></pre></td></tr></table></figure>

<h2 id="六-更灵活的定位内存地址的方法"><a href="#六-更灵活的定位内存地址的方法" class="headerlink" title="六.更灵活的定位内存地址的方法"></a>六.更灵活的定位内存地址的方法</h2><h3 id="1-and-和-or"><a href="#1-and-和-or" class="headerlink" title="1.and 和 or"></a>1.and 和 or</h3><p>and指令：逻辑与指令，按位进行与运算。</p>
<p>mov al, 01100011B<br>and al, 00111011B</p>
<p>执行后：al&#x3D;00100011B即都为1才为1</p>
<p>or指令：逻辑或指令，按位进行或运算。</p>
<p>mov al, 01100011B<br>or al, 00111011B<br>执行后：al&#x3D;01111011B 即只要有一个为1就为1</p>
<h3 id="2-bx-idata"><a href="#2-bx-idata" class="headerlink" title="2.[bx+idata]"></a>2.[bx+idata]</h3><p>[bx+idata]表示一个内存单元, 例如：<code>mov ax, [bx+200]</code><br>该指令也可以写成如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, [200+bx]<br><br>mov ax, 200[bx]<br><br>mov ax, [bx].200<br></code></pre></td></tr></table></figure>



<p>用[bx+idata]的方式进行数组的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg,ds:datasg <br><br>datasg segment <br>	db &#x27;BaSiC&#x27;;转为大写<br>	db &#x27;MinIx&#x27;;转为小写<br>datasg ends<br><br>codesg segment<br>	start:<br>		mov ax, datasg <br>		mov ds, ax <br>		mov bx, 0  ;初始ds:bx<br>	<br>		mov cx, 5<br>	s:	mov al, 0[bx]  ;注意这种写法，有三种等效写法<br>		and al, 11011111b ;转为大写字母<br>		mov 0[bx], al ;写回<br>		mov al, 5[bx]  ;[5 + bx]<br>		or al, 00100000b ;转为小写字母<br>		mov 5[bx], al <br>		inc bx<br>		loop s<br>		<br>		mov ax, 4c00h <br>		int 21h<br>codesg ends<br>end start<br><br></code></pre></td></tr></table></figure>

<p>用c语言表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">char</span> a[] = <span class="hljs-string">&quot;BaSic&quot;</span>;<br>	<span class="hljs-type">char</span> b[] = <span class="hljs-string">&quot;MinIX&quot;</span>;<br>	<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-keyword">do</span><br>	&#123;<br>		a[i] = a[i] &amp; <span class="hljs-number">0xDF</span>;<br>		b[i] = b[i] | <span class="hljs-number">0x20</span>;<br>		i++;<br>	&#125; <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">5</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br><br></code></pre></td></tr></table></figure>

<h3 id="3-SI-、DI-与-寻址方式的灵活应用"><a href="#3-SI-、DI-与-寻址方式的灵活应用" class="headerlink" title="3.SI 、DI 与 寻址方式的灵活应用"></a>3.SI 、DI 与 寻址方式的灵活应用</h3><h4 id="1-si-、di"><a href="#1-si-、di" class="headerlink" title="1.si 、di"></a>1.si 、di</h4><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs: codesg, ds: datasg <br><br>datasg segment <br>	db &#x27;welcome to masm!&#x27;;用si和di实现将字符串‘welcome to masm！&quot;复制到它后面的数据区中。<br>	db &#x27;................&#x27;<br>datasg ends<br><br>codesg segment <br>	start:	mov ax, datasg <br>			mov ds, ax <br>			mov si, 0<br>			<br>			mov cx, 8<br>	s:		mov ax, 0[si] ;[0 + si]<br>			mov 16[si], ax ;[16 + si] 使用[bx +idata]方式代替di，使程序更简洁<br>			add si, 2 <br>			loop s <br>			<br>			mov ax, 4c00h <br>			int 21h <br>codesg ends <br>end start<br><br></code></pre></td></tr></table></figure>

<h4 id="2-bx-si-和-bx-di"><a href="#2-bx-si-和-bx-di" class="headerlink" title="2.[bx + si] 和 [bx + di]"></a>2.[bx + si] 和 [bx + di]</h4><p>[bx+si]和[bx+di]的含义相似</p>
<p>[bx+si]表示一个内存单元，它的偏移地址为（bx）+（si）</p>
<p>指令mov ax, [bx + si]的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p>
<p>该指令也可以写成如下格式：mov ax, [bx] [si]</p>
<h4 id="3-bx-si-idata-和-bx-di-idata"><a href="#3-bx-si-idata-和-bx-di-idata" class="headerlink" title="3.[bx+si+idata]和[bx+di+idata]"></a>3.[bx+si+idata]和[bx+di+idata]</h4><p>[bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+idata</p>
<p>指令mov ax，[bx+si+idata]的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p>
<h4 id="4-不同的寻址方式的灵活应用"><a href="#4-不同的寻址方式的灵活应用" class="headerlink" title="4.不同的寻址方式的灵活应用"></a>4.不同的寻址方式的灵活应用</h4><ul>
<li>[idata]用一个常量来表示地址，可用于直接定位一个内存单元；</li>
<li>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；</li>
<li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；</li>
<li>[bx+si]用两个变量表示地址；</li>
<li>[bx+si+idata]用两个变量和一个常量表示地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs assembly"><br>;将datasg段中每个单词改为大写字母<br>assume cs:codesg,ds:datasg,ss:stacksg <br><br>datasg segment<br>	db &#x27;ibm            &#x27; ;16<br>	db &#x27;dec            &#x27; <br>	db &#x27;dos            &#x27;<br>	db &#x27;vax            &#x27;  ;看成二维数组<br>datasg ends <br><br>stacksg segment ;定义一个段，用来做栈段，容量为16个字节<br>	dw 0, 0, 0, 0, 0, 0, 0, 0<br>stacksg ends <br><br>codesg segment <br>	start:	mov ax, stacksg <br>			mov ss, ax<br>			mov sp, 16 <br>			mov ax, datasg <br>			mov ds, ax <br>			mov bx, 0 ;初始ds:bx<br>			<br>			;cx为默认循环计数器，二重循环只有一个计数器，所以外层循环先保存cx值，再恢复，我们采用栈保存<br>			mov cx, 4<br>	s0:		push cx	;将外层循环的cx值入栈<br>			mov si, 0<br>			mov cx, 3	;cx设置为内层循环的次数<br>	s:		mov al, [bx+si]<br>			and al, 11011111b ;每个字符转为大写字母<br>			mov [bx+si], al <br>			inc si<br>			loop s <br>			<br>			add bx, 16 ;下一行<br>			pop cx	;恢复cx值<br>			loop s0 ;外层循环的loop指令将cx中的计数值减1<br>			<br>			mov ax，4c00H <br>			int 21H <br>codesg ends<br>end start<br><br></code></pre></td></tr></table></figure>

<h2 id="七、数据处理的两个基本问题"><a href="#七、数据处理的两个基本问题" class="headerlink" title="七、数据处理的两个基本问题"></a>七、数据处理的两个基本问题</h2><h3 id="1-bx、si、di和bp"><a href="#1-bx、si、di和bp" class="headerlink" title="1. bx、si、di和bp"></a>1. bx、si、di和bp</h3><p>在8086CPU中，只有这4个寄存器可以用在“[…]”中来进行内存单元的寻址。</p>
<p>在[ ]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di。</p>
<p>只要在[……]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中</p>
<h3 id="2-机器指令处理的数据在什么地方"><a href="#2-机器指令处理的数据在什么地方" class="headerlink" title="2.机器指令处理的数据在什么地方"></a>2.机器指令处理的数据在什么地方</h3><p>数据处理大致可分为3类：读取、写入、运算。</p>
<p>在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：<strong>CPU内部、内存、端口</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2019032120283492.png" alt="在这里插入图片描述"></p>
<h3 id="3-汇编语言中数据位置的表达"><a href="#3-汇编语言中数据位置的表达" class="headerlink" title="3.汇编语言中数据位置的表达"></a>3.汇编语言中数据位置的表达</h3><p>汇编语言中用3个概念来表达数据的位置</p>
<ul>
<li>立即数（idata）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, 1                 ;对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）<br>add bx, 2000h             ;在汇编语言中称为：立即数（idata）<br>or bx, 00010000b<br>mov al, &#x27;a&#x27;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>寄存器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, bx     ;指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。<br>mov ds, ax <br>push bx <br>mov ds:[0], bx <br>push ds <br>mov ss, ax<br>mov sp, ax<br></code></pre></td></tr></table></figure>

<ul>
<li>段地址（SA）和偏移地址（EA）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。<br>mov ax, [0]<br>mov ax, [di]<br>mov ax, [bx+8]<br>mov ax, [bx+si]<br>mov ax, [bx+si+8]   ;以上段地址默认在ds中<br><br>mov ax, [bp]<br>mov ax, [bp+8]<br>mov ax, [bp+si]<br>mov ax, [bp+si+8]   ;以上段地址默认在ss中<br><br>mov ax, ds:[bp]<br>mov ax, es:[bx]<br>mov ax, ss:[bx+si]<br>mov ax, cs:[bx+si+8] ;显式给出存放段地址的寄存器<br><br></code></pre></td></tr></table></figure>

<p>寻址方式</p>
<p><img src="https://img-blog.csdnimg.cn/20190321213006102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-指令要处理的数据有多长"><a href="#4-指令要处理的数据有多长" class="headerlink" title="4.指令要处理的数据有多长"></a>4.指令要处理的数据有多长</h3><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word</p>
<ul>
<li>通过寄存器名指明要处理的数据的尺寸。<br>例如： mov al, ds:[0] 寄存器al指明了数据为1字节</li>
<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。<br>例如：mov byte ptr ds:[0], 1 byte ptr 指明了指令访问的内存单元是一个字节单元</li>
<li>有些指令默认了访问的是字单元还是字节单元<br>例如，push [1000H]，push 指令只进行字操作。</li>
</ul>
<h3 id="5-寻址方式的综合应用"><a href="#5-寻址方式的综合应用" class="headerlink" title="5.寻址方式的综合应用"></a>5.寻址方式的综合应用</h3><p>eg：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, seg <br>mov ds, ax <br>mov bx, 60h   ;确定记录地址，ds:bx <br><br>mov word ptr [bx+0ch], 38   ;排名字段改为38  [bx].0ch<br>add word ptr [bx+0eh], 70   ;收入字段增加70  [bx].0eh<br>mov si, 0   ;用si来定位产品字符串中的字符<br>mov byte ptr [bx+10h+si], &#x27;V&#x27;   ;[bx].10h[si]<br>inc si <br>mov byte ptr [bx+10h+si], &#x27;A&#x27;<br>inc si <br>mov byte ptr [bx+10h+si], &#x27;X&#x27;<br><br></code></pre></td></tr></table></figure>

<p>C语言描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs assembly">/*定义一个公司记录的结构体*/<br>struct company<br>&#123;<br>    char cn[3];/*公司名称*/<br>    char hn[9];/*总裁姓名*/<br>    int pm;/*排名*/<br>    int sr;/*收入*/<br>    char cp[3];/*著名产品*/<br>&#125;;<br>//sizeof (struct company) == 24<br><br>int main()<br>&#123;<br>    /*定义一个公司记录的变量，内存中将存有一条公司的记录*/<br>    struct company dec = &#123;&quot;DEC&quot;, &quot;Ken Olsen&quot;, 137, 40, &quot;PDP&quot;&#125;;<br><br>    int i;<br><br>    dec.pm = 38;<br>    dec.sr = dec.sr + 70;<br><br>    i = 0;<br>    dec.cp[i] = &#x27;V&#x27;; //mov byte ptr [bx].10h[si], &#x27;V&#x27;<br>    i++;<br>    dec.cp[i] = &#x27;A&#x27;;<br>    i++;<br>    dec.cp[i] = &#x27;X&#x27;;<br><br>    return 0;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h3 id="6-div指令、dd、dup、mul指令"><a href="#6-div指令、dd、dup、mul指令" class="headerlink" title="6.div指令、dd、dup、mul指令"></a>6.div指令、dd、dup、mul指令</h3><p>div是除法指令</p>
<p>除数：有8位和16位两种，在一个<strong>寄存器</strong>或<strong>内存单元</strong>中。</p>
<p>被除数：默认放在<strong>AX</strong>或<strong>DX和AX</strong>中，<br>如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除数为16位，被除数则为32位，在DX和AX中存放，<strong>DX存放高16位，AX存放低16位。</strong></p>
<p>结果：<br>如果除数为8位，则<strong>AL存储除法操作的商，AH存储除法操作的余数；</strong><br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;利用除法指令计算100001/100。<br>;100001D = 186A1H<br>mov dx, 1;高16位<br>mov ax, 86A1H ;(dx)*10000H+(ax)=100001  低16位<br>mov bx, 100;除数<br>div bx   ;div 除数  被除数默认在dx和ax中存放<br><br>;利用除法指令计算1001/100  这个是8位的除法<br>mov ax, 1001<br>mov bl, 100<br>div b1<br><br></code></pre></td></tr></table></figure>

<p><strong>伪指令dd</strong></p>
<p>db和dw定义字节型数据和字型数据。</p>
<p>dd是用来定义dword（double word，双字）型数据的伪指令</p>
<p><strong>操作符dup</strong></p>
<p>dup在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。<br>它和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">db 3 dup (0)       ;定义了3个字节，它们的值都是0，相当于db 0，0，0。<br>db 3 dup (0, 1, 2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0，1，2，0，1，2，0，1，2。<br>db 3 dup (&#x27;abc&#x27;, &#x27;ABC&#x27;) ;定义了18个字节，它们是abcABCabcABCabcABCC，相当于db &#x27;abc&#x27;, &#x27;ABC&#x27; ,&#x27;abc&#x27; , &#x27;ABC, &#x27;abc&#x27;, &#x27;ABC&#x27;。<br><br></code></pre></td></tr></table></figure>

<p><strong>mul 指令</strong></p>
<p>mul是乘法指令，使用 mul 做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。</p>
<p>8 位： AL中和 8位寄存器或内存字节单元中；</p>
<p>16 位： AX中和 16 位寄存器或内存字单元中。</p>
<p>结果</p>
<p>8位：AX中；</p>
<p>16位：DX（高位）和 AX（低位）中。</p>
<p>格式：&#x3D;&#x3D;mul 寄存器&#x3D;&#x3D; 或 &#x3D;&#x3D;mul 内存单元&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算100*10<br>;100和10小于255，可以做8位乘法<br>mov al,100<br>mov bl,10<br>mul bl ;默认其中一个就是在al中（八位）<br><br>;结果： (ax)=1000（03E8H） <br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算100*10000<br>;100小于255，可10000大于255，所以必须做16位乘法，程序如下：<br>mov ax,100<br>mov bx,10000<br>mul bx<br><br>;结果： (ax)=4240H，(dx)=000FH     （F4240H=1000000）<br></code></pre></td></tr></table></figure>

<h2 id="八、转移指令的原理"><a href="#八、转移指令的原理" class="headerlink" title="八、转移指令的原理"></a>八、转移指令的原理</h2><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
<p>8086CPU的转移行为有以下几类。</p>
<p>只修改IP时，称为&#x3D;&#x3D;段内转移&#x3D;&#x3D;，比如：&#x3D;&#x3D;jmp ax&#x3D;&#x3D;。<br>同时修改CS和IP时，称为&#x3D;&#x3D;段间转移&#x3D;&#x3D;，比如：&#x3D;&#x3D;jmp 1000:0&#x3D;&#x3D;。</p>
<p>由于转移指令对IP的修改范围不同，段内转移又分为：&#x3D;&#x3D;短转移和近转移&#x3D;&#x3D;</p>
<p>短转移IP的修改范围为&#x3D;&#x3D;-128 ~ 127&#x3D;&#x3D;。<br>近转移IP的修改范围为&#x3D;&#x3D;-32768 ~ 32767&#x3D;&#x3D;。</p>
<p>8086CPU的转移指令分为以下几类</p>
<ul>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
<h3 id="1-操作符offset"><a href="#1-操作符offset" class="headerlink" title="1.操作符offset"></a>1.操作符offset</h3><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;将s处的一条指令复制到s0处<br>assume cs:codesg<br>codesg segment<br> s:   mov ax, bx           ;（mov ax,bx 的机器码占两个字节）<br>      mov si, offset s     ;获得标号s的偏移地址<br>      mov di, offset s0    ;获得标号s0的偏移地址<br>      <br>      mov ax, cs:[si]<br>      mov cs:[di], ax<br> s0:  nop                     ;（nop的机器码占一个字节）<br>      nop<br> codesg ends<br> ends<br><br></code></pre></td></tr></table></figure>



<h3 id="2-jmp指令"><a href="#2-jmp指令" class="headerlink" title="2.jmp指令"></a>2.jmp指令</h3><p>jmp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；</p>
<p>jmp指令要给出两种信息：</p>
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移，段内近转移）</li>
</ul>
<p> jmp short 标号， jmp near ptr 标号， jcxz 标号， loop 标号   等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p>
<p><strong>依据位移进行转移的jmp指令</strong><br><strong>jmp short 标号&#x3D;&#x3D;（段内短转移）&#x3D;&#x3D;</strong></p>
<p>指令“jmp short 标号”的功能为(IP)&#x3D;(IP)+8位位移，转到标号处执行指令</p>
<p>（1）8位位移 &#x3D; “标号”处的地址 - jmp指令后的第一个字节的地址；</p>
<p>（2）short指明此处的位移为8位位移；</p>
<p>（3）8位位移的范围为-128~127，用补码表示</p>
<p>（4）8位位移由编译程序在编译时算出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br>codesg segment<br>  start:mov ax,0<br>        jmp short s ;s不是被翻译成目的地址<br>        add ax, 1<br>      s:inc ax ;程序执行后， ax中的值为 1 <br>codesg ends<br>end start<br><br></code></pre></td></tr></table></figure>

<p>CPU不需要这个目的地址就可以实现对IP的修改。这里是依据&#x3D;&#x3D;位移进行转移&#x3D;&#x3D;</p>
<p><strong>jmp short s指令的读取和执行过程：</strong></p>
<p>(CS)&#x3D;0BBDH，(IP)&#x3D;0006，上一条指令执行结束后CS:IP指向EB 03（jmp short s的机器码）；<br>读取指令码EB 03进入指令缓冲器；<br>(IP) &#x3D; (IP) + 所读取指令的长度 &#x3D; (IP) + 2 &#x3D; 0008，CS:IP指向add ax,1；<br>CPU指行指令缓冲器中的指令EB 03；<br>指令EB 03执行后，(IP)&#x3D;000BH，CS:IP指向inc ax</p>
<p><strong>jmp near ptr 标号 &#x3D;&#x3D;（段内近转移）&#x3D;&#x3D;</strong></p>
<p>指令“jmp near ptr 标号”的功能为：**(IP) &#x3D; (IP) + 16位位移**。</p>
<p><strong>转移的目的地址在指令中的jmp指令</strong></p>
<p><strong>jmp far ptr 标号&#x3D;&#x3D;（段间转移或远转移）&#x3D;&#x3D;</strong></p>
<p>指令jmp far ptr 标号 功能如下：</p>
<ul>
<li>(CS) &#x3D; 标号所在段的段地址；</li>
<li>(IP) &#x3D; 标号所在段中的偏移地址。</li>
<li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br>codesg segment<br>   start: mov ax, 0<br>		  mov bx, 0<br>          jmp far ptr  s ;s被翻译成转移的目的地址0B01 BD0B<br>          db 256 dup (0) ;转移的段地址：0BBDH，偏移地址：010BH<br>    s:    add ax,1<br>          inc ax<br>codesg ends<br>end start<br><br></code></pre></td></tr></table></figure>

<h3 id="3-转移地址在寄存器或内存中的jmp指令"><a href="#3-转移地址在寄存器或内存中的jmp指令" class="headerlink" title="3.转移地址在寄存器或内存中的jmp指令"></a>3.转移地址在寄存器或内存中的jmp指令</h3><p>jmp 16位寄存器<code> 功能：</code>IP &#x3D;（16位寄存器）</p>
<p>转移地址在内存中的jmp指令有两种格式：</p>
<ul>
<li><code>jmp word ptr 内存单元地址</code>（段内转移）</li>
</ul>
<p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, 0123H<br>mov ds:[0], ax<br>jmp word ptr ds:[0]<br>;执行后，(IP)=0123H<br></code></pre></td></tr></table></figure>

<ul>
<li><code>jmp dword ptr 内存单元地址</code>（段间转移）</li>
</ul>
<p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p>
<ol>
<li>(CS)&#x3D;(内存单元地址+2)</li>
<li>(IP)&#x3D;(内存单元地址)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, 0123H<br>mov ds:[0], ax;偏移地址<br>mov word ptr ds:[2], 0;段地址<br>jmp dword ptr ds:[0]<br>;执行后，<br>;(CS)=0<br>;(IP)=0123H<br>;CS:IP 指向 0000:0123。<br></code></pre></td></tr></table></figure>

<h3 id="4-jcxz指令和loop指令"><a href="#4-jcxz指令和loop指令" class="headerlink" title="4.jcxz指令和loop指令"></a>4.jcxz指令和loop指令</h3><p><strong>jcxz指令</strong></p>
<p>jcxz指令为有条件转移指令，所有的有条件转移指令都是<strong>短转移</strong>，</p>
<p>在对应的机器码中包含<strong>转移的位移</strong>，而不是目的地址。对IP的修改范围都为-128~127。</p>
<p>指令格式：<strong>jcxz 标号</strong>（如果(cx)&#x3D;0，则转移到标号处执行。）</p>
<p>当(cx) &#x3D; 0时，(IP) &#x3D; (IP) + 8位位移</p>
<p>8位位移 &#x3D; “标号”处的地址 - jcxz指令后的第一个字节的地址；<br>8位位移的范围为-128~127，用补码表示；<br>8位位移由编译程序在编译时算出。<br>当(cx)!&#x3D;0时，什么也不做（程序向下执行）</p>
<p><strong>loop指令</strong></p>
<p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。</p>
<p>对IP的修改范围都为-128~127。</p>
<p>指令格式：loop 标号 ((cx) &#x3D; (cx) - 1，如果(cx) ≠ 0，转移到标号处执行)。</p>
<p>(cx) &#x3D; (cx) - 1；如果 (cx) !&#x3D; 0，(IP) &#x3D; (IP) + 8位位移。</p>
<p>8位位移 &#x3D; 标号处的地址 - loop指令后的第一个字节的地址；<br>8位位移的范围为-128~127，用补码表示；<br>8位位移由编译程序在编译时算出。<br>如果（cx）&#x3D; 0，什么也不做（程序向下执行）。</p>
<h2 id="九、call和ret指令"><a href="#九、call和ret指令" class="headerlink" title="九、call和ret指令"></a>九、call和ret指令</h2><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。</p>
<h3 id="1-ret-和-retf"><a href="#1-ret-和-retf" class="headerlink" title="1.ret 和 retf"></a>1.ret 和 retf</h3><ul>
<li><p>ret指令用栈中的数据，修改IP的内容，从而实现<strong>近</strong>转移；</p>
</li>
<li><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现<strong>远</strong>转移。</p>
</li>
</ul>
<p>CPU执行ret指令时，相当于进行： pop IP：</p>
<p>（1）(IP) &#x3D; ( (ss) * 16 + (sp) )</p>
<p>（2）(sp) &#x3D; (sp) + 2</p>
<p>CPU执行retf指令时，相当于进行：pop IP, pop CS：</p>
<p>（1）(IP) &#x3D; ( (ss) * 16 + (sp) )</p>
<p>（2）(sp) &#x3D; (sp) + 2</p>
<p>（3）(CS) &#x3D; ( (ss) * 16 + (sp) )</p>
<p>（4）(sp) &#x3D; (sp) + 2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code <br>stack seqment<br>	db 16 dup (0)<br>stack ends <br><br>code segment<br>		mov ax, 4c00h<br>		int 21h <br> start:	mov ax, stack <br> 		mov ss, ax<br> 		mov sp, 16<br>		mov ax, 0<br>		push ax ;ax入栈<br>		mov bx, 0<br>		ret ;ret指令执行后，(IP)=0，CS:IP指向代码段的第一条指令。可以push cs  push ax  retf<br>code ends<br>end start<br><br></code></pre></td></tr></table></figure>

<h3 id="2-call-指令"><a href="#2-call-指令" class="headerlink" title="2.call 指令"></a>2.call 指令</h3><p>call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：</p>
<p>（1）将当前的 IP 或 CS和IP 压入栈中；</p>
<p>（2）转移（jmp）。</p>
<p><strong>call指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。</strong></p>
<ul>
<li>call 标号（近转移）</li>
</ul>
<p>CPU执行此种格式的call指令时，相当于进行 push IP   jmp near ptr 标号</p>
<ul>
<li>call far ptr 标号（段间转移）</li>
</ul>
<p>CPU执行此种格式的call指令时，相当于进行：push CS，push IP   jmp far ptr 标号</p>
<ul>
<li>call 16位寄存器</li>
</ul>
<p>CPU执行此种格式的call指令时，相当于进行： push IP   jmp 16位寄存器</p>
<ul>
<li>call word ptr 内存单元地址</li>
</ul>
<p>CPU执行此种格式的call指令时，相当于进行：push IP   jmp word ptr 内存单元地址</p>
<ul>
<li>call dword ptr 内存单元地址</li>
</ul>
<p>CPU执行此种格式的call指令时，相当于进行：push CS    push IP   jmp dword ptr 内存单元地址</p>
<h3 id="3-call-和-ret-的配合使用"><a href="#3-call-和-ret-的配合使用" class="headerlink" title="3.call 和 ret 的配合使用"></a>3.call 和 ret 的配合使用</h3><p>示例程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br>code segment<br>start:	mov ax,1<br>	    mov cx,3<br>     	call s ;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP入栈，jmp<br>     	<br>	    mov bx,ax	;（4）IP重新指向这里  bx = 8<br>     	mov ax,4c00h<br>     	int 21h<br>     s: add ax,ax<br>     	loop s;（2）循环3次ax = 8<br>	    ret;（3）return : pop IP<br>code ends<br>end start<br><br></code></pre></td></tr></table></figure>

<h2 id="十、标志寄存器"><a href="#十、标志寄存器" class="headerlink" title="十、标志寄存器"></a>十、标志寄存器</h2><p>（这部分不太好记，<del>那就不记了</del>，实战过程中慢慢积累吧，看着看着就记住了）</p>
<h3 id="1-标志寄存器"><a href="#1-标志寄存器" class="headerlink" title="1.标志寄存器"></a>1.标志寄存器</h3><p>CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。</p>
<p>（1）用来存储相关指令的某些执行结果；</p>
<p>（2）用来为CPU执行相关指令提供行为依据；</p>
<p>（3）用来控制CPU的相关工作方式。</p>
<p>这种特殊的寄存器在8086CPU中，被称为<strong>标志寄存器</strong>（flag）。</p>
<p>8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW-Program Status Word）</p>
<p>flag寄存器是按位起作用的，它的每一位都有专门的含义，记录特定的信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20190322182130199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令</p>
<h4 id="1-零标志位-ZF"><a href="#1-零标志位-ZF" class="headerlink" title="1.零标志位 (ZF)"></a>1.零标志位 (ZF)</h4><p>零标志位（Zero Flag）。它记录相关指令执行后，其结果是否为0。</p>
<p>如果结果为0，那么zf &#x3D; 1(表示结果是0)；如果结果不为0，那么zf &#x3D; 0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, 1<br>sub ax, 1 ;执行后，结果为0，则zf = 1<br><br>mov ax, 2<br>sub ax, 1 ;执行后，结果不为0，则zf = 0<br><br></code></pre></td></tr></table></figure>

<h4 id="2-奇偶标志位-PF"><a href="#2-奇偶标志位-PF" class="headerlink" title="2.奇偶标志位 (PF)"></a>2.奇偶标志位 (PF)</h4><p>奇偶标志位（Parity Flag）。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。</p>
<p>如果1的个数为偶数，pf &#x3D; 1，如果为奇数，那么pf &#x3D; 0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al, 1<br>add al, 10 ;执行后，结果为00001011B，其中有3（奇数）个1，则pf = 0；<br><br>mov al, 1<br>or al, 2  ;执行后，结果为00000011B，其中有2（偶数）个1，则pf = 1；<br><br></code></pre></td></tr></table></figure>

<h4 id="3-符号标志位-SF"><a href="#3-符号标志位-SF" class="headerlink" title="3.符号标志位(SF)"></a>3.符号标志位(SF)</h4><p>符号标志位(Symbol Flag)。它记录相关指令执行后，其结果是否为负。</p>
<p>如果结果为负，sf &#x3D; 1；如果非负，sf &#x3D; 0。</p>
<p>计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。</p>
<p>00000001B，可以看作为无符号数1，或有符号数+1；<br>10000001B，可以看作为无符号数129，也可以看作有符号数-127。</p>
<p>对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算</p>
<p>CPU在执行add等指令的时候，就包含了两种含义:可以将add指令进行的运算当作无符号数的运算，也可以将add指令进行的运算当作有符号数的运算</p>
<p>SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，<strong>SF的值则没有意义</strong>，虽然相关的指令影响了它的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al, 10000001B <br>add al, 1   ;执行后，结果为10000010B，sf = 1，表示：如果指令进行的是有符号数运算，那么结果为负；<br><br><br>mov al, 10000001B<br>add al, 01111111B   ;执行后，结果为0，sf = 0，表示：如果指令进行的是有符号数运算，那么结果为非负<br></code></pre></td></tr></table></figure>

<h4 id="4-进位标志位-CF"><a href="#4-进位标志位-CF" class="headerlink" title="4.进位标志位(CF)"></a>4.进位标志位(CF)</h4><p>进位标志位(Carry Flag)。一般情况下，在进行<strong>无符号数</strong>运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p>
<h4 id="5-溢出标志位-OF"><a href="#5-溢出标志位-OF" class="headerlink" title="5.溢出标志位(OF)"></a>5.溢出标志位(OF)</h4><p>溢出标志位(Overflow Flag)。一般情况下，OF记录了<strong>有符号数</strong>运算的结果是否发生了溢出。</p>
<p>如果发生溢出，OF &#x3D; 1；如果没有，OF &#x3D; 0。</p>
<p>CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位</p>
<p>CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。</p>
<p>对于无符号数运算，CPU用CF位来记录是否产生了进位；<br>对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al, 98<br>add al, 99   ;执行后将产生溢出。因为进行的&quot;有符号数&quot;运算是：（al）=（al）+ 99 = 98 + 99=197 = C5H 为-59的补码<br>             ;而结果197超出了机器所能表示的8位有符号数的范围：-128-127。<br>             ;add 指令执行后：无符号运算没有进位CF=0，有符号运算溢出OF=1<br>             ;当取出的数据C5H按无符号解析C5H = 197, 当按有符号解析通过SP得知数据为负,即C5H为-59补码存储，<br>             <br>mov al，0F0H  ;F0H，为有符号数-16的补码   -Not(F0 - 1)<br>add al，088H  ;88H，为有符号数-120的补码   -Not(88- 1)<br>              ;执行后，将产生溢出。因为add al, 088H进行的有符号数运算结果是：（al）= -136 <br>              ;而结果-136超出了机器所能表示的8位有符号数的范围：-128-127。<br>              ;add 指令执行后：无符号运算有进位CF=1，有符号运算溢出OF=1<br><br></code></pre></td></tr></table></figure>

<h3 id="2-adc指令和sbb指令"><a href="#2-adc指令和sbb指令" class="headerlink" title="2.adc指令和sbb指令"></a>2.adc指令和sbb指令</h3><p><strong>adc指令</strong></p>
<p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>
<p>指令格式：<code>adc 操作对象1, 操作对象2</code></p>
<p>功能：操作对象1 &#x3D; 操作对象1 + 操作对象2 + CF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ax, 2<br>mov bx, 1<br>sub bx, ax  ;无符号运算借位CF=1，有符号运算OF = 0<br>adc ax, 1   ;执行后，（ax）= 4。adc执行时，相当于计算：(ax)+1+CF = 2+1+1 = 4。<br><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190323125737798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。<br>;将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。<br>mov ax, 001EH <br>mov bx, 0F000H <br>add bx, 1000H<br>adc ax, 0020H<br><br></code></pre></td></tr></table></figure>

<p><strong>sbb指令</strong></p>
<p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p>
<p>指令格式：<code>sbb 操作对象1, 操作对象2</code></p>
<p>功能：操作对象1 &#x3D; 操作对象1 - 操作对象2 - CF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算 003E1000H - 00202000H，结果放在ax，bx中，程序如下：<br>mov bx, 1000H<br>mov ax, 003EH<br>sub bx, 2000H<br>sbb ax, 0020H<br><br></code></pre></td></tr></table></figure>

<h3 id="3-cmp指令"><a href="#3-cmp指令" class="headerlink" title="3.cmp指令"></a>3.cmp指令</h3><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p>
<p>其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</p>
<p>cmp指令格式：cmp 操作对象1，操作对象2</p>
<p>例如：<br>指令cmp ax, ax，做（ax）-（ax）的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。<br>指令执行后：zf&#x3D;1，pf&#x3D;1，sf&#x3D;0，cf&#x3D;0，of&#x3D;0。</p>
<p>CPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。</p>
<table>
<thead>
<tr>
<th>cmp ax, bx</th>
<th>无符号比较时</th>
</tr>
</thead>
<tbody><tr>
<td>(ax) &#x3D; (bx)</td>
<td>zf &#x3D; 1</td>
</tr>
<tr>
<td>(ax) ≠ (bx)</td>
<td>zf &#x3D; 0</td>
</tr>
<tr>
<td>(ax) &lt; (bx)</td>
<td>cf &#x3D; 1</td>
</tr>
<tr>
<td>(ax) ≥ (bx)</td>
<td>cf &#x3D; 0</td>
</tr>
<tr>
<td>(ax) &gt; (bx)</td>
<td>cf &#x3D; 0 且 zf &#x3D; 0</td>
</tr>
<tr>
<td>(ax) ≤ (bx)</td>
<td>cf &#x3D; 1 且 zf &#x3D; 1</td>
</tr>
</tbody></table>
<p>上面的表格可以正推也可以逆推</p>
<p>如果用cmp来进行有符号数比较时：<br>SF只能记录实际结果的正负，发生溢出的时候，实际结果的正负不能说明逻辑上真正结果的正负。<br>但是逻辑上的结果的正负，才是cmp指令所求的真正结果，所以我们在考察SF的同时考察OF，就可以得知逻辑上真正结果的正负，同时就知道比较的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ah, 08AH  ; -Not(8A-1) = -118  即当成有符号数时为-118<br>mov bh, 070H  ; 有符号数时最高位为0为正数， 70H = 112<br>cmp ah, bh    ;（ah）-（bh）实际得到的结果是1AH <br>		      ; 在逻辑上，运算所应该得到的结果是：（-118）- 112 = -230<br>		      ; sf记录实际结果的正负，所以sf=0<br><br></code></pre></td></tr></table></figure>

<h3 id="4-检测比较结果的条件转移指令"><a href="#4-检测比较结果的条件转移指令" class="headerlink" title="4.检测比较结果的条件转移指令"></a>4.检测比较结果的条件转移指令</h3><p>可以根据某种条件，决定是否修改IP的指令</p>
<p>jcxz它可以检测cx中的数值，如果（cx）&#x3D;0，就修改IP，否则什么也不做。</p>
<p>所有条件转移指令的转移位移都是[-128，127]。</p>
<p>多数条件转移指令都<strong>检测标志寄存器的相关标志位</strong>，根据检测的结果来决定是否修改IP</p>
<p><strong>这些条件转移指令通常都和cmp相配合使用,它们所检测的标志位，都是cmp指令进行无符号数比较的时记录比较结果的标志位</strong></p>
<p>根据无符号数的比较结果进行转移的条件转移指令（它们检测zf、cf的值）</p>
<p>这个挺重要的：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td>je</td>
<td>等于则转移</td>
<td>zf &#x3D; 1</td>
</tr>
<tr>
<td>jne</td>
<td>不等于则转移</td>
<td>zf &#x3D; 0</td>
</tr>
<tr>
<td>jb</td>
<td>低于则转移</td>
<td>cf &#x3D; 1</td>
</tr>
<tr>
<td>jnb</td>
<td>不低于则转移</td>
<td>cf &#x3D; 0</td>
</tr>
<tr>
<td>ja</td>
<td>高于则转移</td>
<td>cf &#x3D; 0 且 zf &#x3D; 0</td>
</tr>
<tr>
<td>jna</td>
<td>不高于则转移</td>
<td>cf &#x3D; 1 且 zf &#x3D; 1</td>
</tr>
</tbody></table>
<h3 id="5-DF标志和串传送指令"><a href="#5-DF标志和串传送指令" class="headerlink" title="5.DF标志和串传送指令"></a>5.DF标志和串传送指令</h3><p>方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p>
<p>df &#x3D; 0每次操作后si、di递增；<br>df &#x3D; 1每次操作后si、di递减。</p>
<p>格式：movsb<br>功能：将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减</p>
<p>格式：movsw<br>功能：将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2。</p>
<p>格式：rep movsb<br>movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，<br>功能：rep的作用是根据cx的值，重复执行后面的串传送指令</p>
<p>8086CPU提供下面两条指令对df位进行设置。</p>
<p>cld指令：将标志寄存器的df位置0<br>std指令：将标志寄存器的df位置1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;将data段中的第一个字符串复制到它后面的空间中。<br>data segment <br>	db &#x27;Welcome to masm!&#x27;<br>	db 16 dup (0)<br>data ends<br><br>mov ax, data <br>mov ds, ax <br>mov si, 0   ;ds:si 指向data:0<br>mov es, ax <br>mov di, 16  ;es:di指向data:0010<br><br>mov cx, 16  ;（cx）=16，rep循环16次<br>cld  ;设置df=0，正向传送<br>rep movsb<br><br></code></pre></td></tr></table></figure>

<h3 id="6-pushf和popf"><a href="#6-pushf和popf" class="headerlink" title="6.pushf和popf"></a>6.pushf和popf</h3><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中</p>
<p>pushf和popf，为直接访问标志寄存器提供了一种方法。</p>
<p>接下来还有一些内容，但是目前来说是用不到的，就先不学了，什么时候用到了再说</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-start"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/11/24/ctf%E8%A7%A3%E9%A2%98%E5%BF%83%E5%BE%97/">← Next ctf解题积累</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://raw.githubusercontent.com/shimmer123456/img/main/img/touxiang.png" alt="Logo"></a><h1 id="Dr"><a href="/">shimmer</a></h1><div id="description"><p>一</p><p>些</p><p>小</p><p>笔</p><p>记</p><p>或</p><p>是</p><p>小</p><p>感</p><p>悟</p></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">一.基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">1.指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2.存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BA%BF"><span class="toc-number">1.3.</span> <span class="toc-text">3.总线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">二.寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1.寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2.通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8086CPU%E7%BB%99%E5%87%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">3.8086CPU给出物理地址的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4.段寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CS%E5%92%8CIP"><span class="toc-number">2.4.1.</span> <span class="toc-text">1.CS和IP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DS-%E5%92%8C-address"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.DS 和 [address]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SS-%E5%92%8C-SP"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.SS 和 SP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">三.第一个程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-bx-%E5%92%8C-loop%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">四.[bx] 和 loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bx-%E5%92%8C-loop%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">1.[bx] 和 loop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AE%B5%E5%89%8D%E7%BC%80"><span class="toc-number">4.2.</span> <span class="toc-text">2.段前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AE%B5%E5%89%8D%E7%BC%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3.段前缀的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">五.包含多个段的程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">六.更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-and-%E5%92%8C-or"><span class="toc-number">6.1.</span> <span class="toc-text">1.and 和 or</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-bx-idata"><span class="toc-number">6.2.</span> <span class="toc-text">2.[bx+idata]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SI-%E3%80%81DI-%E4%B8%8E-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">3.SI 、DI 与 寻址方式的灵活应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-si-%E3%80%81di"><span class="toc-number">6.3.1.</span> <span class="toc-text">1.si 、di</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-bx-si-%E5%92%8C-bx-di"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.[bx + si] 和 [bx + di]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-bx-si-idata-%E5%92%8C-bx-di-idata"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.[bx+si+idata]和[bx+di+idata]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">6.3.4.</span> <span class="toc-text">4.不同的寻址方式的灵活应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">七、数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bx%E3%80%81si%E3%80%81di%E5%92%8Cbp"><span class="toc-number">7.1.</span> <span class="toc-text">1. bx、si、di和bp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="toc-number">7.2.</span> <span class="toc-text">2.机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="toc-number">7.3.</span> <span class="toc-text">3.汇编语言中数据位置的表达</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%87%E4%BB%A4%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%89%E5%A4%9A%E9%95%BF"><span class="toc-number">7.4.</span> <span class="toc-text">4.指令要处理的数据有多长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.</span> <span class="toc-text">5.寻址方式的综合应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-div%E6%8C%87%E4%BB%A4%E3%80%81dd%E3%80%81dup%E3%80%81mul%E6%8C%87%E4%BB%A4"><span class="toc-number">7.6.</span> <span class="toc-text">6.div指令、dd、dup、mul指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">八、转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%AC%A6offset"><span class="toc-number">8.1.</span> <span class="toc-text">1.操作符offset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.</span> <span class="toc-text">2.jmp指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E6%88%96%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">8.3.</span> <span class="toc-text">3.转移地址在寄存器或内存中的jmp指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-jcxz%E6%8C%87%E4%BB%A4%E5%92%8Cloop%E6%8C%87%E4%BB%A4"><span class="toc-number">8.4.</span> <span class="toc-text">4.jcxz指令和loop指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81call%E5%92%8Cret%E6%8C%87%E4%BB%A4"><span class="toc-number">9.</span> <span class="toc-text">九、call和ret指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ret-%E5%92%8C-retf"><span class="toc-number">9.1.</span> <span class="toc-text">1.ret 和 retf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-call-%E6%8C%87%E4%BB%A4"><span class="toc-number">9.2.</span> <span class="toc-text">2.call 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-call-%E5%92%8C-ret-%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">3.call 和 ret 的配合使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">十、标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">1.标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%B6%E6%A0%87%E5%BF%97%E4%BD%8D-ZF"><span class="toc-number">10.1.1.</span> <span class="toc-text">1.零标志位 (ZF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A5%87%E5%81%B6%E6%A0%87%E5%BF%97%E4%BD%8D-PF"><span class="toc-number">10.1.2.</span> <span class="toc-text">2.奇偶标志位 (PF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AC%A6%E5%8F%B7%E6%A0%87%E5%BF%97%E4%BD%8D-SF"><span class="toc-number">10.1.3.</span> <span class="toc-text">3.符号标志位(SF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%9B%E4%BD%8D%E6%A0%87%E5%BF%97%E4%BD%8D-CF"><span class="toc-number">10.1.4.</span> <span class="toc-text">4.进位标志位(CF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%BA%A2%E5%87%BA%E6%A0%87%E5%BF%97%E4%BD%8D-OF"><span class="toc-number">10.1.5.</span> <span class="toc-text">5.溢出标志位(OF)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-adc%E6%8C%87%E4%BB%A4%E5%92%8Csbb%E6%8C%87%E4%BB%A4"><span class="toc-number">10.2.</span> <span class="toc-text">2.adc指令和sbb指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-cmp%E6%8C%87%E4%BB%A4"><span class="toc-number">10.3.</span> <span class="toc-text">3.cmp指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">10.4.</span> <span class="toc-text">4.检测比较结果的条件转移指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">10.5.</span> <span class="toc-text">5.DF标志和串传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-pushf%E5%92%8Cpopf"><span class="toc-number">10.6.</span> <span class="toc-text">6.pushf和popf</span></a></li></ol></li></ol></div></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>