<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>windows/win32编程 | shimmer's blog</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 共 $1 行","copy":"复制","copyFinish":"完成","expand":"展开"}}</script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://raw.githubusercontent.com/shimmer123456/img/main/img/202305010958580.png);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1>windows/win32编程</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-03-20T02:47:34.000Z" id="date"> 2023-03-20</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-03-24T11:59:41.556Z" id="updated"> 2023-03-24</time></div></span></div></div><hr><div id="post-content"><p>本文参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pB4y187VB/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1pB4y187VB/?spm_id_from=333.337.search-card.all.click</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_51604330/article/details/124741816?ops_request_misc=%7B%22request_id%22:%22167965680816800182196367%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167965680816800182196367&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124741816-null-null.142%5Ev76%5Einsert_down38,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=win32%E7%BC%96%E7%A8%8B&spm=1018.2226.3001.4187">(43条消息) 【Win32】初识Win32编程_半生瓜のblog的博客-CSDN博客</a></p>
<h2 id="Windows编程"><a href="#Windows编程" class="headerlink" title="Windows编程"></a>Windows编程</h2><h3 id="应用程序分类"><a href="#应用程序分类" class="headerlink" title="应用程序分类"></a>应用程序分类</h3><h4 id="控制台程序Console"><a href="#控制台程序Console" class="headerlink" title="控制台程序Console"></a>控制台程序Console</h4><p>DOS程序，本身没有窗口，通过Windows DOS窗口执行。(DOS是操作系统预留的)</p>
<h4 id="窗口程序"><a href="#窗口程序" class="headerlink" title="窗口程序"></a>窗口程序</h4><p>拥有自己的窗口，可以与用户交互。</p>
<h4 id="库程序"><a href="#库程序" class="headerlink" title="库程序"></a>库程序</h4><p>存放代码、数据的程序、执行文件可以从中取出代码执行和获取数据<br><strong>静态库程序</strong>:扩展名LIB,在编译链接程序时，将代码放入到执行文件中。<br><strong>动态库程序</strong>：扩展名DLL，在执行文件时从中获取代码 。<br>静态库中的代码是直接嵌入到你的项目中，而动态库中的内容是通过地址来找到。</p>
<p>静态库程序无法执行，也就是说它最终生成的文件无法进入内存。<br>动态库程序有入口函数，可以执行。<strong>但是它不能独立运行。</strong>谁调动态库里面的东西，它就依附于谁。</p>
<h3 id="应用程序对比"><a href="#应用程序对比" class="headerlink" title="应用程序对比"></a>应用程序对比</h3><h4 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h4><ul>
<li>控制台程序-main</li>
<li>窗口程序-WinMain</li>
<li>动态库程序-DllMain</li>
<li>静态库程序-无入口函数</li>
</ul>
<h4 id="文件存在方式"><a href="#文件存在方式" class="headerlink" title="文件存在方式"></a>文件存在方式</h4><ul>
<li>控制台程序、窗口程序-EXE文件</li>
<li>动态库程序-DLL文件</li>
<li>静态库程序-LIB文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">相关函数<br><span class="hljs-type">int</span> WINAPI <span class="hljs-title function_">wWinMain</span><span class="hljs-params">(</span><br><span class="hljs-params">    HINSTANCE hInstance,<span class="hljs-comment">//当前程序的实例句柄，找到你当前进程所占据的那块内存</span></span><br><span class="hljs-params">    HINSTANCE hPrevInstance,<span class="hljs-comment">//当前程序前一个示例句柄，废弃了</span></span><br><span class="hljs-params">    PWSTR pCmdLine, <span class="hljs-comment">//命令行参数字符串</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> nCmdShow<span class="hljs-comment">//窗口的显示方式</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>



<p><strong>暂时可以将句柄理解成，句柄是用来找到内存的东西，但绝对不是指针。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MessageBox</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in, optional] HWND    hWnd,<span class="hljs-comment">//父窗口句柄</span></span><br><span class="hljs-params">  [in, optional] LPCTSTR lpText,<span class="hljs-comment">//显示在消息框中的文字</span></span><br><span class="hljs-params">  [in, optional] LPCTSTR lpCaption,<span class="hljs-comment">//显示在标题栏中的文字</span></span><br><span class="hljs-params">  [in]           UINT    uType<span class="hljs-comment">//消息框中的按钮、图标显示了类型</span></span><br><span class="hljs-params">)</span>;<span class="hljs-comment">//返回点击的按钮ID</span><br><br><span class="hljs-comment">//能够将程序暂停在这里，说明它是个阻塞函数。它执行，可能不会立即返回。</span><br></code></pre></td></tr></table></figure>



<h3 id="窗口创建过程"><a href="#窗口创建过程" class="headerlink" title="窗口创建过程"></a>窗口创建过程</h3><ul>
<li>定义WinMain函数</li>
<li>定义窗口的处理函数(自定义，消息处理)</li>
<li>注册窗口类(向操作系统中写入一些数据)</li>
<li>创建窗口(内存中创建窗口)</li>
<li>显示窗口(绘制窗口的图像)</li>
<li>消息循环(获取&#x2F;翻译&#x2F;派发消息)</li>
<li>消息处理</li>
</ul>
<h3 id="第一个windows窗口"><a href="#第一个windows窗口" class="headerlink" title="第一个windows窗口"></a>第一个windows窗口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-comment">//窗口处理函数（自定义、处理消息）</span><br>LRESULT CALLBACK <span class="hljs-title function_">WndProc</span><span class="hljs-params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span><br>&#123;<br>	<span class="hljs-keyword">return</span> DefWindowProc(hWnd, msgID, wParam, lParam);<br>&#125;<br><br><span class="hljs-comment">//入口函数</span><br><span class="hljs-type">int</span> CALLBACK <span class="hljs-title function_">WinMain</span><span class="hljs-params">(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, <span class="hljs-type">int</span> nCmdShow)</span><br>&#123;<br>	<span class="hljs-comment">//注册窗口类</span><br>	WNDCLASS wc = &#123; <span class="hljs-number">0</span> &#125;;<br>	<span class="hljs-comment">//申请两种不用的缓冲区</span><br>	wc.cbClsExtra = <span class="hljs-number">0</span>;<br>	wc.cbWndExtra = <span class="hljs-number">0</span>;<br><br>	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="hljs-number">1</span>);<br>	wc.hCursor = <span class="hljs-literal">NULL</span>;<br>	wc.hIcon = <span class="hljs-literal">NULL</span>;<br>	wc.hInstance = hIns;<br>	wc.lpfnWndProc = WndProc;<br>	wc.lpszClassName = <span class="hljs-string">&quot;myWindow&quot;</span>;<br>	wc.lpszMenuName = <span class="hljs-literal">NULL</span>;<br>	wc.style = CS_HREDRAW | CS_VREDRAW;<br>	<span class="hljs-comment">//将上面赋的这些值全部写入操作系统</span><br>	RegisterClass(&amp;wc);<br>	<br>	<span class="hljs-comment">//在内存中创建窗口</span><br>	HWND hWnd = CreateWindow(<span class="hljs-string">&quot;myWindow&quot;</span>, <span class="hljs-string">&quot;menu&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, hIns, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-comment">//显示窗口</span><br>	ShowWindow(hWnd, SW_SHOW);<br>	<span class="hljs-comment">//再画一遍(刷新窗口)</span><br>	UpdateWindow(hWnd);<br>	<span class="hljs-comment">//消息循环</span><br>	MSG nMsg = &#123; <span class="hljs-number">0</span> &#125;;<br>	<span class="hljs-keyword">while</span> (GetMessage(&amp;nMsg,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>	&#123;<br>		TranslateMessage(&amp;nMsg);<br>		DispatchMessage(&amp;nMsg);<span class="hljs-comment">//将消息交给窗口处理函数来处理</span><br>	<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>窗口有无与进程退不退没有关系。</strong></p>
<h3 id="注册窗口类"><a href="#注册窗口类" class="headerlink" title="注册窗口类"></a>注册窗口类</h3><h4 id="窗口类的概念"><a href="#窗口类的概念" class="headerlink" title="窗口类的概念"></a>窗口类的概念</h4><ul>
<li><p>窗口类是包含了窗口的各种参数信息的数据结构。</p>
</li>
<li><p>每个窗口都具有窗口类，基于窗口类创建窗口。</p>
</li>
<li><p>每个窗口类都具有一个名称，使用前必须注册到系统。</p>
</li>
<li><p>在操作系统内核里存着就叫窗口类，在程序里存着就叫窗口类。</p>
</li>
</ul>
<h4 id="窗口类的分类："><a href="#窗口类的分类：" class="headerlink" title="窗口类的分类："></a>窗口类的分类：</h4><h5 id="系统窗口类"><a href="#系统窗口类" class="headerlink" title="系统窗口类"></a>系统窗口类</h5><p>系统已经定义好的窗口类，所有应用程序都可以直接使用。<br>不需要注册，直接使用窗口类即可。系统已经注册好了。<br>例如:按钮-BUTTON,编辑框-EDIT</p>
<h5 id="应用程序全局窗口类"><a href="#应用程序全局窗口类" class="headerlink" title="应用程序全局窗口类"></a>应用程序全局窗口类</h5><p>由用户自己定义，当前应用程序所有模块都可以使用。<br>应用程序局部窗口类<br>由用户自己定义，当前应用程序中本模块可以直接使用。</p>
<h5 id="全局及局部窗口类-："><a href="#全局及局部窗口类-：" class="headerlink" title="全局及局部窗口类 ："></a>全局及局部窗口类 ：</h5><p>注册窗口类的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">(ATOM——<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)<br><br>ATOM <span class="hljs-title function_">RegisterClass</span><span class="hljs-params">(</span><br><span class="hljs-params"></span><br><span class="hljs-params"> CONST WNDCLASS *lpWndClass<span class="hljs-comment">//窗口类的数据);</span></span><br><span class="hljs-params"></span><br><span class="hljs-params"><span class="hljs-comment">//注册成功后 ，返回一个数字标识。(0失败，非0成功。)</span></span><br></code></pre></td></tr></table></figure>



<h4 id="style窗口类风格"><a href="#style窗口类风格" class="headerlink" title="style窗口类风格"></a>style窗口类风格</h4><p>应用程序全局窗口类的注册，需要在窗口类的风格中添加CS_GLOBALCLASS。</p>
<p>应用程序局部类窗口类注册，无需添加如上风格。</p>
<p><strong>不建议使用全局窗口类</strong>——因为局部窗口类能完成全局窗口类的功能，并且全局窗口类可能会产生冗余。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">CS_HREDRAW ——当窗口水平变化时，窗口重新绘制<br>CS_VREDRAW ——当窗口垂直变化时，窗口重新绘制<br>CS_DBLCLKS ——允许窗口接收鼠标双击<br>CS_NOCLOSE ——窗口没有关闭按钮<br></code></pre></td></tr></table></figure>



<h3 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h3><h4 id="窗口创建-1"><a href="#窗口创建-1" class="headerlink" title="窗口创建"></a>窗口创建</h4><p><strong>CreateWindow &#x2F; CreateWindowEx</strong></p>
<p>CreateWindow内部是如何实现的</p>
<p>系统(CreateWindows函数内部)根据传入的窗口类名称，在应用程序局部窗口类中查找，如果找到执行2 ，没找到执行3。<br>比较局部窗口与创建窗口时传入的HINSTANCE变量。如果有发现相等。创建和注册类在同一模块，创建窗口返回。如果不相等，继续执行3。<br>在应用程序全局窗口类，如果找到，执行4， 没找到执行5。<br>使用找到的窗口类信息，创建窗口返回。<br>在系统窗口类中查找，如果找到创建窗口返回，否则创建窗口失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-comment">//窗口处理函数（自定义、处理消息）</span><br>LRESULT CALLBACK <span class="hljs-title function_">WndProc</span><span class="hljs-params">(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)</span><br>&#123;<br>	<span class="hljs-keyword">switch</span> (msgID)<br>	&#123;<br>	<span class="hljs-keyword">case</span> WM_DESTROY:<br>		PostQuitMessage(<span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> DefWindowProc(hWnd, msgID, wParam, lParam);<br>&#125;<br><br><span class="hljs-comment">//入口函数</span><br><span class="hljs-type">int</span> CALLBACK <span class="hljs-title function_">WinMain</span><span class="hljs-params">(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, <span class="hljs-type">int</span> nCmdShow)</span><br>&#123;<br><br>	<span class="hljs-comment">//注册窗口类</span><br>	WNDCLASS wc = &#123; <span class="hljs-number">0</span> &#125;;<br>	<span class="hljs-comment">//申请两种不用的缓冲区</span><br>	wc.cbClsExtra = <span class="hljs-number">0</span>;<br>	wc.cbWndExtra = <span class="hljs-number">0</span>;<br>	<br>	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="hljs-number">1</span>);<br>	wc.hCursor = <span class="hljs-literal">NULL</span>;<br>	wc.hIcon = <span class="hljs-literal">NULL</span>;<br>	wc.hInstance = hIns;<br>	wc.lpfnWndProc = WndProc;<br>	wc.lpszClassName = <span class="hljs-string">&quot;myWindow&quot;</span>;<br>	wc.lpszMenuName = <span class="hljs-literal">NULL</span>;<br>	wc.style = CS_HREDRAW | CS_VREDRAW;<br>	<span class="hljs-comment">//将上面赋的这些值全部写入操作系统</span><br>	RegisterClass(&amp;wc);<br>	<br>	<span class="hljs-comment">//在内存中创建窗口</span><br>	HWND hWnd = CreateWindow(<span class="hljs-string">&quot;myWindow&quot;</span>, <span class="hljs-string">&quot;menu&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, hIns, <span class="hljs-literal">NULL</span>);<br>	<span class="hljs-comment">//显示窗口</span><br>	ShowWindow(hWnd, SW_SHOW);<br>	<span class="hljs-comment">//再画一遍(刷新窗口)</span><br>	UpdateWindow(hWnd);<br>	<span class="hljs-comment">//消息循环</span><br>	MSG nMsg = &#123; <span class="hljs-number">0</span> &#125;;<br>	<span class="hljs-keyword">while</span> (GetMessage(&amp;nMsg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>	&#123;<br>		TranslateMessage(&amp;nMsg);<br>		DispatchMessage(&amp;nMsg);<span class="hljs-comment">//将消息交给窗口处理函数来处理</span><br>	<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="子窗口创建过程"><a href="#子窗口创建过程" class="headerlink" title="子窗口创建过程"></a>子窗口创建过程</h4><p>创建时要设置父窗口句柄<br>创建风格要增加WS_CHILD | WS_VISBLE<br>(根据注册的窗口类，来创建多个窗口。)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">HWND hChild1 = CreateWindowEx(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Child&quot;</span>, <span class="hljs-string">&quot;C1&quot;</span>, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>, hWnd, <span class="hljs-literal">NULL</span>, hIns, <span class="hljs-literal">NULL</span>);<br><br>HWND hChild2 = CreateWindowEx(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Child&quot;</span>, <span class="hljs-string">&quot;C2&quot;</span>, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, <span class="hljs-number">200</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>, hWnd, <span class="hljs-literal">NULL</span>, hIns, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure>



<h3 id="消息基础"><a href="#消息基础" class="headerlink" title="消息基础"></a>消息基础</h3><h4 id="消息的概念和作用"><a href="#消息的概念和作用" class="headerlink" title="消息的概念和作用"></a>消息的概念和作用</h4><h5 id="消息组成-windows平台下"><a href="#消息组成-windows平台下" class="headerlink" title="消息组成(windows平台下)"></a>消息组成(windows平台下)</h5><ul>
<li>​	窗口句柄</li>
<li>​	消息ID</li>
<li>​	消息的两个参数(两个附带信息)</li>
<li>​	消息产生的时间</li>
<li>​	消息产生时的鼠标位置</li>
</ul>
<h5 id="消息的作用"><a href="#消息的作用" class="headerlink" title="消息的作用"></a>消息的作用</h5><p>当系统通知窗口工作时，就采用消息的方式(DispatchMessage)派发给(调用)窗口的窗口处理函数(将MSG的前四个信息传递给消息处理函数)。<br><strong>每一个窗口都有窗口处理函数</strong></p>
<h4 id="MSG结构体接收消息"><a href="#MSG结构体接收消息" class="headerlink" title="MSG结构体接收消息"></a>MSG结构体接收消息</h4><p>结构体定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//对应解释同上消息组成</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagMSG</span> &#123;</span><br>    HWND        hwnd;<br>    UINT        message;<br>    WPARAM      wParam;<br>    LPARAM      lParam;<br>    DWORD       time;<br>    POINT       pt;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MAC</span><br>    DWORD       lPrivate;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;<br></code></pre></td></tr></table></figure>



<h4 id="DispatchMessage如何找到窗口处理函数"><a href="#DispatchMessage如何找到窗口处理函数" class="headerlink" title="DispatchMessage如何找到窗口处理函数"></a>DispatchMessage如何找到窗口处理函数</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">nMsg.hwnd-&gt;保存窗口数据的内存-&gt;找到对应的窗口处理函数-&gt;WndProc<br><br>回到你自己定义的消息处理函数-&gt;传递参数-&gt;处理消息<br>LRESULT CALLBACK WndProc(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)<br>传递这四个参数，不用关系后两个<br></code></pre></td></tr></table></figure>





<h4 id="窗口处理函数"><a href="#窗口处理函数" class="headerlink" title="窗口处理函数"></a>窗口处理函数</h4><p>每个窗口都必需有窗口处理函数，只要基于窗口类创建窗口，就肯定要有个窗口处理函数。</p>
<p>窗口处理依照如下结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">LRESULT CALLBACK <span class="hljs-title function_">WindowProc</span><span class="hljs-params">(</span><br><span class="hljs-params">	HWND hWnd;<span class="hljs-comment">//窗口句柄</span></span><br><span class="hljs-params">	UINT uMsg;<span class="hljs-comment">//消息ID</span></span><br><span class="hljs-params">	WPARAM wParam;<span class="hljs-comment">//消息参数</span></span><br><span class="hljs-params">	LPARAM lParam;<span class="hljs-comment">//消息参数</span></span><br><span class="hljs-params">   	)</span>;<br></code></pre></td></tr></table></figure>


<p>当系统通知窗口时，(DispatchMessage)会调用窗口处理函数，同时将消息ID和消息参数传递给窗口处理函数。</p>
<p>在窗口处理函数中，不处理的消息，使用缺省窗口处理函数。</p>
<p>例如:DefWindowProc(可以给各种消息做默认处理)。</p>
<p>消息循环中的相关函数(浅谈)<br>GetMessage-到系统的某个地方抓本进程的消息</p>
<p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">GetMessage</span><span class="hljs-params">(</span><br><span class="hljs-params">	LPMSG lpMsg,<span class="hljs-comment">//存放获取到消息的BUFF，</span></span><br><span class="hljs-params">    HWND hWndp;<span class="hljs-comment">//窗口句柄，要是定为NULL，将会抓取本进程中所有窗口中的消息</span></span><br><span class="hljs-params">    UNIT wMsgFilterMin,<span class="hljs-comment">//获取的最小ID</span></span><br><span class="hljs-params">    UNIT wMsgFilterMax<span class="hljs-comment">//获取消息的最大ID</span></span><br><span class="hljs-params">    <span class="hljs-comment">//最后两个参数都为0，就是不管ID有多大，只要是本进程的消息都抓过来</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>


<p>其中后三个参数可以限制抓取消息的范围，如果设置为NULL,0,0那其实就是没有进行限制，只要是本进程的消息我都把它抓过来。</p>
<p>GetMessage的返回值</p>
<p>消息WM_QUIT会使GetMessage返回0，从而中终止消息接收。</p>
<p>PostQuitMessage(0);会在进程中扔出WM_QUIT这个消息，get后从而使得消息循环终止。</p>
<p>TranslateMessage-翻译消息——它可不是什么消息都翻译。</p>
<p>将按键(可见字符按键，a~z)消息翻译成字符消息。</p>
<p>所以进入到它的内部， 它所做的第一件事就是检查这个消息是否合法，是否是它要翻译的消息类型。</p>
<p>如果不是按键类型消息，不做任何处理，继续执行。</p>
<p>函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL TranslateMessage<br>&#123;<br>    CONST  MSG* lpMsg;<span class="hljs-comment">//要翻译的消息地址	</span><br>&#125;<br></code></pre></td></tr></table></figure>


<p>DispatchMessage-派发消息(调用对应窗口的消息处理函数)</p>
<p>函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">LRESULT <span class="hljs-title function_">DispatchMessage</span><span class="hljs-params">(</span><br><span class="hljs-params">	CONST MSG* lpmsg<span class="hljs-comment">//要派发的消息</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>

<h3 id="常见消息"><a href="#常见消息" class="headerlink" title="常见消息"></a>常见消息</h3><h4 id="WM-DESTORY"><a href="#WM-DESTORY" class="headerlink" title="WM_DESTORY"></a>WM_DESTORY</h4><p>产生时间:窗口被销毁时产生<br>附带信息:wParam:为0，lParam:为0<br>一般用法:常用于在窗口被销毁前，做相应的善后处理，例如资源、内存等(该回收回收，该释放释放。)。</p>
<h4 id="WM-SYSCOMMAND"><a href="#WM-SYSCOMMAND" class="headerlink" title="WM_SYSCOMMAND"></a>WM_SYSCOMMAND</h4><p>产生时间：当点击窗口最大化，最小化，关闭等。<br>附带信息:<br>wParam:具体点击的位置，例如关闭SC_CLOSE等，<br>lParam:鼠标光标的位置(这个不重要，我们只需要知道点没点就行，具体在哪个位置其实无所谓(具体情况具体使用))，LOWORD(lParam);水平位置，HIWORD(lParam)；垂直位置。(高两字节传纵坐标，低两字节传横坐标。)<br>一般用法:常用在窗口关闭时，提示用户处理。</p>
<h4 id="WM-CREATE"><a href="#WM-CREATE" class="headerlink" title="WM_CREATE"></a>WM_CREATE</h4><p>产生时间:在窗口创建成功但还没显示时。<br>附带信息:<br>wParam:为0<br>lParam:为CREATESTRUCT类型的指针(强转成这个类型再用)，通过这个指针可以获取CreatWindowEx中全部12个参数的信息。<br>一般用法：常用于初始化窗口函数、资源等等，包括创建子窗口等。</p>
<h4 id="WM-SIZE"><a href="#WM-SIZE" class="headerlink" title="WM_SIZE"></a>WM_SIZE</h4><p>产生时间:在窗口的大小发生变化后。<br>附带信息:<br>wParam:窗口大小变化的原因。<br>lParam:窗口变化后的大小<br>LOWORD(lParam)变化后的宽度<br>HIWORD(lParam)变化后的高度<br>一般用法:常用于窗口大小发生变化后，调整窗口内各个部分的布局。</p>
<h4 id="WM-QUIT"><a href="#WM-QUIT" class="headerlink" title="WM_QUIT"></a>WM_QUIT</h4><p>产生时间:程序员发送。<br>附带信息:<br>wPram:PostQuitmessage函数传递的参数。<br>lParam：0。<br>一般用法:用于结束消息循环，当GetMessage收到这个消息后，会返回FALSE,结束while处理，退出消息循环。<br>这个消息不用我们去处理,进不去我们定义的窗口处理函数,GetMessage()返回了0，无法进入循环获取消息。</p>
<h3 id="消息循环的原理"><a href="#消息循环的原理" class="headerlink" title="消息循环的原理"></a>消息循环的原理</h3><h4 id="消息循环的阻塞"><a href="#消息循环的阻塞" class="headerlink" title="消息循环的阻塞"></a>消息循环的阻塞</h4><p>GetMessage-从系统获取消息，将消息从系统中移除，阻塞函数。当系统无消息时，会等候下一条消息。<br>对人来说消息是一直存在的，但是对于CPU来说(速度接近光速)，消息不是经常有的，所以会经常发生阻塞。这样程序的效率就不高，从而引出下面这个函数。</p>
<p>PeekMessage-以查看的方式从系统中获取消息，可以不将消息从系统出移除，非阻塞函数。当系统无消息时，返回FALSE,继续执行后续代码。<br>函数原型如下:</p>
<p>(前四个参数同GetMessage)</p>
<p>最后一个参数是，是否赋予它抓取消息的能力，一般是不给它的，也就是填写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">BOOL <span class="hljs-title function_">PeekMessageA</span><span class="hljs-params">(</span><br><span class="hljs-params">  [out]          LPMSG lpMsg,</span><br><span class="hljs-params">  [in, optional] HWND  hWnd,</span><br><span class="hljs-params">  [in]           UINT  wMsgFilterMin,</span><br><span class="hljs-params">  [in]           UINT  wMsgFilterMax,</span><br><span class="hljs-params">  [in]           UINT  wRemoveMsg</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>


<p>也就是说，更好的流程是，先派PeekMessage去侦查是否有消息，有就告诉GetMessage让它来处 理。没有就不要派Get去了，因为它会一直在那里等着消息的出现。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (PeekMessage(&amp;nMsg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, PM_NOREMOVE))<br>		&#123;<br>			<span class="hljs-comment">//有消息-判断是否是WM_QUIT</span><br>			<span class="hljs-keyword">if</span> (GetMessage(&amp;nMsg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>			&#123;<br>				TranslateMessage(&amp;nMsg);<br>				DispatchMessage(&amp;nMsg);<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//没有消息——空闲处理</span><br>			WriteConsole(g_HOUTPUT, <span class="hljs-string">&quot;空闲ing\n&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;空闲ing&quot;</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Windows平台上的消息，都是它们两个造出来的。</p>
<p>SendMessage-发送消息，会等候消息处理的结果。<br>PostMessage-投递消息，消息发出后立刻返回，不等候消息执行结果。<br>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">LRESULT <span class="hljs-title function_">SendMessage</span><span class="hljs-params">(</span><br><span class="hljs-params">  [in] HWND   hWnd,<span class="hljs-comment">//消息发送的目的创建</span></span><br><span class="hljs-params">  [in] UINT   Msg,<span class="hljs-comment">//消息ID</span></span><br><span class="hljs-params">  [in] WPARAM wParam,<span class="hljs-comment">//消息参数</span></span><br><span class="hljs-params">  [in] LPARAM lParam<span class="hljs-comment">//消息参数</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure>


<p>这四个参数就是一个消息的前四个参数，剩下的两个参数函数内部以某种手段自加来获取。</p>
<h4 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h4><p>系统消息-ID范围0~0x03FF<br>由系统定义好的消息，可以在程序中直接使用。<br>程序员只负责一头，要么发送不用处理，要么处理不用发送。<br>用户自定义的消息-ID范围0x0400(WM_USER) - 0x7FFF(31743)<br>由用户自己定义，满足用户自己的需求。由用户自己发出消息，并响应处理。<br>由程序员，自己定制，自己发送，自己处理。<br>自定义消息宏：WM_USER(叫什么都行)<br>例如:</p>
<p>定义消息名称</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WM_MYMESSAGE WM_USER+1001</span><br></code></pre></td></tr></table></figure>


<p>发送,在哪发都可以,附加消息，你自己的，附加什么都行。</p>
<p>PostMessage&#x2F;SendMessage(hWnd, WM_MYMESSAGE, 1, 2);</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="消息队列的概念"><a href="#消息队列的概念" class="headerlink" title="消息队列的概念"></a>消息队列的概念</h4><ul>
<li>消息队列是用于存放消息的队列。</li>
<li>消息在队列中先进先出。</li>
<li>所有窗口都具有消息队列。</li>
<li>程序(GetMessage())可以从队列中获取消息。</li>
</ul>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>Windows上静态库和Linux上的静态库在原理上没有任何区别，都是封装一堆东西等着别人去掉。</p>
<h4 id="静态库的特点"><a href="#静态库的特点" class="headerlink" title="静态库的特点"></a>静态库的特点</h4><p>运行不存在。<br>没有如何，不能执行，生成的文件无法形成静态影像，无法进内存。<br>静态库源码被链接到调用程序中。<br>目标程序的归档。</p>
<h4 id="C语言静态库"><a href="#C语言静态库" class="headerlink" title="C语言静态库"></a>C语言静态库</h4><h4 id="C静态库的创建"><a href="#C静态库的创建" class="headerlink" title="C静态库的创建"></a>C静态库的创建</h4><p>创建一个静态库程序。<br>添加库程序，源文件使用C文件。</p>
<h4 id="C静态库的使用"><a href="#C静态库的使用" class="headerlink" title="C静态库的使用"></a>C静态库的使用</h4><p>库路径设置:可以使用#pragma关键字设置<br>#pragma comment(lib,“…&#x2F;lib&#x2F;clib.lib”)</p>
<h3 id="C-静态库"><a href="#C-静态库" class="headerlink" title="C++静态库"></a>C++静态库</h3><h4 id="C-静态库的创建"><a href="#C-静态库的创建" class="headerlink" title="C++静态库的创建"></a>C++静态库的创建</h4><p>创建一个静态库项目<br>添加库程序，源文件使用CPP文件。</p>
<h4 id="C-静态库的使用"><a href="#C-静态库的使用" class="headerlink" title="C++静态库的使用"></a>C++静态库的使用</h4><p>库路径设置:可以使用pragma关键字设置<br>#pragma comment(lib,“…&#x2F;xx&#x2F;xxx.lib”)<br>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//给编译器看</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CLIB_add</span><span class="hljs-params">(<span class="hljs-type">int</span> add1, <span class="hljs-type">int</span> add2)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CLIB_sub</span><span class="hljs-params">(<span class="hljs-type">int</span> add1, <span class="hljs-type">int</span> add2)</span></span>;<br><span class="hljs-comment">//给链接器看</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;../Debug/CPPLIB.lib&quot;</span>)</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-built_in">CLIB_add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">CLIB_sub</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/17/goductf/">← Next goductf  逆向wp</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/03/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">逆向工程核心原理 Prev →</a></div></div></div><div id="Valine"></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="INDEX">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://raw.githubusercontent.com/shimmer123456/img/main/img/touxiang.png" alt="Logo"></a><h1 id="Dr"><a href="/">shimmer</a></h1><div id="description"><p>一</p><p>些</p><p>小</p><p>笔</p><p>记</p><p>或</p><p>是</p><p>小</p><p>感</p><p>悟</p></div></div><div id="aside-block"><div id="toc-div"><h1>INDEX</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Windows编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">应用程序分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8FConsole"><span class="toc-number">1.1.1.</span> <span class="toc-text">控制台程序Console</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">窗口程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">库程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.</span> <span class="toc-text">应用程序对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">入口函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">文件存在方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">窗口创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAwindows%E7%AA%97%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text">第一个windows窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%AA%97%E5%8F%A3%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">注册窗口类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">窗口类的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.5.2.</span> <span class="toc-text">窗口类的分类：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AA%97%E5%8F%A3%E7%B1%BB"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">系统窗口类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%85%A8%E5%B1%80%E7%AA%97%E5%8F%A3%E7%B1%BB"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">应用程序全局窗口类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%8A%E5%B1%80%E9%83%A8%E7%AA%97%E5%8F%A3%E7%B1%BB-%EF%BC%9A"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">全局及局部窗口类 ：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#style%E7%AA%97%E5%8F%A3%E7%B1%BB%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.5.3.</span> <span class="toc-text">style窗口类风格</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA"><span class="toc-number">1.6.</span> <span class="toc-text">窗口创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">窗口创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">子窗口创建过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%9F%BA%E7%A1%80"><span class="toc-number">1.7.</span> <span class="toc-text">消息基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">消息的概念和作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%BB%84%E6%88%90-windows%E5%B9%B3%E5%8F%B0%E4%B8%8B"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">消息组成(windows平台下)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">消息的作用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MSG%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">MSG结构体接收消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DispatchMessage%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E7%AA%97%E5%8F%A3%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">DispatchMessage如何找到窗口处理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.4.</span> <span class="toc-text">窗口处理函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.8.</span> <span class="toc-text">常见消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WM-DESTORY"><span class="toc-number">1.8.1.</span> <span class="toc-text">WM_DESTORY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WM-SYSCOMMAND"><span class="toc-number">1.8.2.</span> <span class="toc-text">WM_SYSCOMMAND</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WM-CREATE"><span class="toc-number">1.8.3.</span> <span class="toc-text">WM_CREATE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WM-SIZE"><span class="toc-number">1.8.4.</span> <span class="toc-text">WM_SIZE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WM-QUIT"><span class="toc-number">1.8.5.</span> <span class="toc-text">WM_QUIT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">消息循环的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">1.9.1.</span> <span class="toc-text">消息循环的阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.9.2.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB"><span class="toc-number">1.9.3.</span> <span class="toc-text">消息分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.10.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.10.1.</span> <span class="toc-text">消息队列的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.11.</span> <span class="toc-text">静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.11.1.</span> <span class="toc-text">静态库的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.11.2.</span> <span class="toc-text">C语言静态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.11.3.</span> <span class="toc-text">C静态库的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.11.4.</span> <span class="toc-text">C静态库的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-number">1.12.</span> <span class="toc-text">C++静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.12.1.</span> <span class="toc-text">C++静态库的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.2.</span> <span class="toc-text">C++静态库的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">1.13.</span> <span class="toc-text">动态库</span></a></li></ol></li></ol></div></div></div><footer><nobr>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{new Valine({
 el: '#Valine'
 , appId: 'fvW1eWgLvTdXfECCW1Bu9g6J-gzGzoHsz'
 , appKey: 'stD8FmxHNFFxhkzXholoBHdq' , placeholder: '此条评论委托企鹅物流发送'
});code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>