[{"title":"word笔记","url":"/2022/11/24/word%E7%AC%94%E8%AE%B0/","content":"word笔记一.删除空格1.打开替换\n2.查找内容内输入‘ ’ ，表示键入一个空格\n3.替换为内为空 \n4.全部替换即可\n二.删除空段1.打开”查找与替换”\n2.更多—-&gt;特殊格式—-&gt;段落标记(^p)—–&gt;两次,出现两个^p—-&gt;替换内容为^p(一个)\n3.全部替换即可\n4.原理:\n没有空格的空段是怎样产生的？不正是我们连打了两次回车之后才有的么？现在把两个连续的回车替换成一个，正好消除了那个空段。\n如果有连续的空段的话，一次替换不完，你可以多按几次“全部替换”，直到提示找不到替换的对象为止\n删除其余类似:“^l”表示软回车，“^p”表示硬回车，“^t”表示制表符，“^m”表示手动分页符，\n“^+”表示长划线(—)，“^&#x3D;”表示短划线(–)，“^l”表示人工换行符，^n表示分栏符\n三.将可以排列整齐的数据排列整齐1.ctrl+a 全选\n2.插入表格,强制使他们分开\n3.删除表格:布局–&gt;转换为文本.\n四.把不连续的编号变为连续\n1.ctrl+f9 创建一个空域  输入seq a  外面一个点\n2.剪切\n3.ctrl +h查找\n4.更多,使用通配符\n5.查找内容:(^13)[0-9]{1,}.     (硬回车)\n6.替换为:\\1^c  \n7.f9刷新\n 设置自动调整:\n1.ctrl +f9创建一个空域\n2.输入{autonum} 剪切\n3.查找替换重复以上\n4.f9更新\n","categories":["office"],"tags":["word"]},{"title":"算法基础","url":"/2022/11/24/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","content":"一.排序1.快排模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n, i, j;int q[N];void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return;int x = q[(l+r)/2]; i = l - 1; j = r + 1;while (i&lt;j)&#123;\tdo i++; while (q[i] &lt; x);\tdo j--; while (q[j] &gt; x);\tif (i&lt;j) swap(q[i], q[j]);&#125;quick_sort(q, l, j);quick_sort(q, j + 1, r);&#125;int main()&#123;\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;q[i]);\t&#125;\tquick_sort(q, 0, n - 1);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tprintf(&quot;%d&quot;, q[i]);\t&#125;\treturn 0;&#125;\n\n2.归并排序归并排序（acwing 逆序对的数量）\n个人理解，归并排序在递归完成之后会将整个数组相邻两个数分为一组，这时，只存在左右两边的情况，而本层计算完成之后，返回上一层计算，这里的同时在 一边的逆序数对刚刚已经计算完了（往上一层分组减少一半），所以只需要计算跨左右的情况就可以了\n #include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define array arrconst int N = 100010;int array[N];int nums;unsigned long result = 0;void merge_sort(int array[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = (l + r) / 2;    merge_sort(array, l, mid);//递归左右两边  递归结果就是两个为一组    merge_sort(array, mid + 1, r);//    int temp[r - l + 1];    int lptr = l;    int rptr = mid + 1;    int tempptr = 0;    while (lptr &lt;= mid &amp;&amp; rptr &lt;= r)    &#123;        if (array[lptr] &lt;= array[rptr])        &#123;            temp[tempptr++] = array[lptr++];        &#125;        else &#123;            temp[tempptr++] = array[rptr++];            result += (mid - lptr + 1);//注意这里，是直接加的，后面的不需要比较了。        &#125;    &#125;    while (lptr &lt;= mid)    &#123;        temp[tempptr++] = array[lptr++];    &#125;    while (rptr &lt;= r)    &#123;        temp[tempptr++] = array[rptr++];    &#125;    for (int i = l, j = 0; i &lt;= r; i++, j++)    &#123;        array[i] = temp[j];    &#125;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;nums);    for (int i = 0; i &lt; nums; i++)    &#123;        scanf(&quot;%d&quot;, &amp;array[i]);    &#125;    merge_sort(array, 0, nums - 1);    cout &lt;&lt; result;    return 0;&#125;\n\n二.查找1.二分查找#include &lt;iostream&gt;using namespace std;int main()&#123;\tint n, num[105], targe;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tcin &gt;&gt; num[i];\t&#125;\tcin &gt;&gt; targe;\tint l = 0, r = n - 1;\twhile (l &lt;= r)\t&#123;\t\tint mid = (l + r) &gt;&gt; 1;\t\tif (num[mid] == targe)\t\t&#123;\t\t\tcout &lt;&lt; targe &lt;&lt; &quot;in index&quot; &lt;&lt; mid &lt;&lt; endl;\t\t\treturn 0;\t\t&#125;\t\tif (num[mid] &gt; targe)\t\t&#123;\t\t\tr = mid - 1;\t\t&#125;\t\telse\t\t&#123;\t\t\tl = mid + 1;\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;no&quot; &lt;&lt; endl;\treturn 0;&#125;\n\n三.数据结构1.Trie树 高效的存储和查找字符串集合的数据结构\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26], cnt[N], idx;int i;void insert(char str[])//插入一个字符串&#123;\tint p = 0;//节点 从零开始\t\tfor ( i = 0; str[i]; i++)\t&#123;\t\tint u = str[i] - &#x27;a&#x27;;\t\tif (!son[p][u]) son[p][u] = ++idx;//如果没有对应的下一节点，创造一个 idx给了个编号\t\tp = son[p][u];       //idx是每次加一的，所以使得p每次加一；\t\t//也就是上一节点存储下一节点的位置，在接下来查找的时候才可以找到\t&#125;\tcnt[p]++;//以p为节点的结束次数！！！&#125;int query(char str[])//查找&#123;\tint p = 0;\tfor ( i = 0; str[i]; i++)\t&#123;\t\tint u = str[i] - &#x27;a&#x27;;\t\tif (!son[p][u]) return 0;\t\tp = son[p][u];//son[p][u]的值就是下一个节点的坐标\t&#125;\treturn cnt[p];&#125;char str[N];int main()&#123;\tint n;\tscanf(&quot;%d&quot;, &amp;n);\twhile (n--)\t&#123;\t\tchar op[2];\t\tscanf(&quot;%s%s&quot;, op,str);\t\tif (op[0] == &#x27;I&#x27;) insert(str);\t\telse printf(&quot;%d\\n&quot;, query(str));\t&#125;\treturn 0;&#125;\n\n2.并查集1.将两个集合合并2.询问两个元素是否在一个集合中\n原理：每个集合用一颗树来表示，树根的编号就是集合的编号；每个节点存储他的父节点p[x]表示x的父节点1.如何判断树根 p[x]&#x3D;x则是树根2.如何求x的树根编号： while(p[x]!&#x3D;x) x&#x3D;p[x];   只要不等，一直往上走；3.如何合并集合  两棵树 一颗插入另一颗px是x的集合编号 py是y的集合编号   p[x]&#x3D;y 即可\n对2. 优化：（路径压缩） 一旦往上走找到根节点，那么将该路径上的所有点直接指向根节点   大概为o1的时间复杂度\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int p[N]; int find(int x)//核心&#123;\tif (p[x] != x) p[x] = find(p[x]);//返回x的祖宗节点 并且加路径优化\treturn p[x];&#125; int main()&#123;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\tfor (int i = 0; i &lt;= n; i++) p[i] = i;\twhile (m--)\t&#123;\t\tchar op[2];\t\tint a, b;\t\tscanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b);\t\tif (op[0] == &#x27;M&#x27;)\t\t&#123;\t\t\tp[find(a)] = find(b);//把b的祖宗节点插入a的祖宗节点下当儿子\t\t&#125;\t\telse\t\t&#123;\t\t\tif (find(a) == find(b))\t\t\t&#123;\t\t\t\tputs(&quot;yes&quot;);\t\t\t&#125;\t\t\telse\t\t\t\tputs(&quot;No&quot;);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.前缀和求区间 [r,l] 之中数的和\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], s[N];int main()&#123;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);//n个数  m次操作\tfor (int i = 1; i &lt;= n; i++)//注意是1~n\t&#123;\t\tscanf(&quot;%d&quot;, &amp;a[i]);//读入n个数\t&#125;\tfor (int i = 1; i &lt;= n; i++)//注意1~n\t&#123;\t\ts[i] = s[i - 1] + a[i];//预处理\t&#125;\twhile (m--)\t&#123;\t\tint l, r;\t\tscanf(&quot;%d%d&quot;, &amp;l, &amp;r);//求l到r区间的和\t\tprintf(&quot;%d\\n&quot;, s[r] - s[l - 1]);\t&#125;\treturn 0;&#125;\n\n4.差分（前缀的逆运算）\n在指定区间都加c（原数组a[N]）由o(n) 到 o(1)\n#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], b[N];int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)//1~n    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        b[i] = a[i] - a[i - 1];      //构建差分数组    &#125;    int l, r, c;    while (m--)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);        b[l] += c;     //将序列中[l, r]之间的每个数都加上c        b[r + 1] -= c;    &#125;    for (int i = 1; i &lt;= n; i++)//1~n    &#123;        a[i] = b[i] + a[i - 1];    //前缀和运算        printf(&quot;%d &quot;, a[i]);    &#125;    return 0;&#125;\n\n5.单链表数组模拟的，但其实通常用stl\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int e[N], ne[N], head, idx;//对链表进行初始化void init() &#123;    head = -1;//最开始的时候，链表的头节点要指向-1，    //为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束    /*    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针    当它在初始化的时候指向-1，来表示链表里没有内容。    */    idx = 0;//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找    //第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下    //标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！    /*    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。    另外，我们遍历链表的时候也是这样，靠的是ne[]    */&#125;//将x插入到头节点上void int_to_head(int x) &#123;//和链表中间插入的区别就在于它有head头节点    e[idx] = x;//第一步，先将值放进去    ne[idx] = head;//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了    //先在只是做到了第一步，将元素x的指针指向了head原本指向的    head = idx;//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）    idx++;//指针向下移一位，为下一次插入元素做准备。&#125;//e[idx]=x;// ne[idx]=head;// head=idx;// idx++;//将x插入到下标为k的点的后面void add(int k, int x) &#123;    e[idx] = x;//先将元素插进去    e[idx]=x;ne[idx]=ne[k];ne[k]=idx;idx++;    ne[idx] = ne[k];//让元素x配套的指针，指向它要占位的元素的下一个位置    ne[k] = idx;//让原来元素的指针指向自己    idx++;//将idx向后挪    /*    为了将这个过程更好的理解，现在    将指针转变的这个过程用比喻描述一下，牛顿老师为了省事，想插个队，队里有两个熟人    张三和李四，所以，他想插到两个人中间，但是三个人平时关系太好了，只要在一起，就    要让后面的人的手插到前面的人的屁兜里。如果前面的人屁兜里没有基佬的手，将浑身不    适。所以，必须保证前面的人屁兜里有一只手。（张三在前，李四在后）    这个时候，牛顿大步向前，将自己的手轻轻的放入张三的屁兜里，（这是第一步）    然后，将李四放在张三屁兜里的手抽出来放到自己屁兜里。（这是第二步）    经过这一顿骚操作，三个人都同时感觉到了来自灵魂的战栗，打了个哆嗦。    */&#125;//将下标是k的点后面的点个删掉void remove(int k) &#123;    ne[k] = ne[ne[k]];//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。&#125;//ne[k]=ne[ne[k]]//传进来的是k-1int main() &#123;    cin &gt;&gt; n;    init();//初始化    for (int i = 0; i &lt; n; i++)     &#123;        char s;        cin &gt;&gt; s;        if (s == &#x27;H&#x27;) &#123;            int x;            cin &gt;&gt; x;            int_to_head(x);        &#125;        if (s == &#x27;D&#x27;) &#123;            int k;            cin &gt;&gt; k;            if (k == 0) head = ne[head];//删除头节点            else remove(k - 1);//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1        &#125;        if (s == &#x27;I&#x27;) &#123;            int k, x;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);//同样的，第k个数，和下标不同，所以要减1        &#125;    &#125;    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;    return 0;&#125;\n\n6.队列我觉得是一个双指针在维护这个数据结构吧先进的先出  后进的后出 tt就是维护队尾位置的下标 如果要队头出列的话 hh++就可以 遍历的时候i&lt;&#x3D;hh就可以了（输出时候队头开始遍历）\n#include&lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1e6 + 10;int qu[N], hh = 0, tt = -1;//初始化很重要！！！int main()&#123;    int n;    cin &gt;&gt; n;    while (n--)    &#123;        int x;        string a;        cin &gt;&gt; a;        if (a == &quot;push&quot;)            cin &gt;&gt; x, qu[++tt] = x;//元素只能队尾入队        else if (a == &quot;pop&quot;)            hh++;//注意元素只能队头弹出，且是 ++        else if (a == &quot;empty&quot;)//队内是否为空        &#123;            if (tt &lt; hh)                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else//查询队头            cout &lt;&lt; qu[hh] &lt;&lt; endl;    &#125;     for (int i = tt; i &lt;= hh; i++)    &#123;        printf(&quot;%d&quot;, qu[i]);    &#125;    return 0;&#125;\n\n\n\n四.搜索1.DFS输出n个数的全排列\n（DFS八皇后也仅仅是扩展到二维数组而已 （acwing））\n#include &lt;iostream&gt;using namespace std;const int N = 10;int n;bool book[N];int st[N];void dfs(int u)&#123;\tif (u &gt; n)\t&#123;\t\tfor (int i = 1; i &lt;= n; i++)\t\t&#123;\t\t\tprintf(&quot;%d&quot;, st[i]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\treturn;\t&#125;\tfor (int i = 1; i &lt;= n; i++)\t&#123;\t\tif (!book[i])\t\t&#123;\t\t\tst[u]=i;\t\t\tbook[i] = true;\t\t\tdfs(u + 1);\t\t\t\t\t\t\t\t\t //能走到这一步说明是打印完之后return的，来到了当时的上一层，在这\t\t\tst[u] = 0;  //回溯\t\t\tbook[i] = false;  \t\t\t////////悟了悟了卧槽！！！  忘了时候再仔细调试看看，终于懂了。\t\t&#125;\t&#125;&#125;int main()&#123;\tcin &gt;&gt; n;\tdfs(1);\treturn 0;&#125;\n\n1.1dfs的例题dfs的指数级枚举，真的妙！！！ \n#include &lt;iostream&gt;using namespace std;const int N = 1e1 + 6; //定义一个常量Nint n;int st[N];  //记录每个位置当前的状态：0表示还没考虑，1表示选它，2表示不选它void dfs(int u) // 枚举的第几个数字&#123;    if (u &gt; n) &#123;        //终止条件，因为题目要求一个就n个数 所以只有 u &gt; n 就输出枚举的方案        for (int i = 1; i &lt;= n; i++)            if (st[i] == 1)                printf(&quot;%d &quot;, i);        puts(&quot;&quot;);        return;    &#125;    st[u] = 1;   //选它的分支    dfs(u + 1);    st[u] = 0;   //恢复现场，以便进行下一个分支    st[u] = 2; //  不选它的分支    dfs(u + 1);    st[u] = 0;  // 恢复现场&#125;int main(void)&#123;    scanf(&quot;%d&quot;, &amp;n);    dfs(1);    return 0;&#125;\n\n\n\n2.BFS在DFS中我们说关键点是递归以及回溯，\n在BFS中，关键点则是状态的选取和标记\n 悟了悟了！！！！\n​       BFS 迷宫：  一个while大循环，只要不空就以一直走  每次取出队头  下面一个for的四个方向的循环 符合条件就会向外扩展 注意都是扩展在t的基础上的（一个点） 然后：每个被扩展出来的都会进队列，继续扩展，如果扩展不了就四个for都不满足，在下一次循环中他就被弹出了！  okay！！！\n#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;#define x first#define y second int n, m;typedef pair&lt;int, int&gt;PII;int a[110][110];   //储存地图int dis[110][110];  //储存距离int pos[4][2] = &#123; -1,0,0,1,1,0,0,-1 &#125;; //偏移量数组void bfs(PII start)&#123;    queue&lt;PII&gt; q;    q.push(start);\t\t//初始状态入队        while (!q.empty()) \t//队列不空时        &#123;            PII t = q.front();       // 取出队首元素，存放到 t 变量里 ，元素出队            q.pop(); \t\t\t\t//元素出队            for (int i = 0; i &lt; 4; i++)//\t扩展 t 结点        &#123;           int tx = t.x + pos[i][0],ty = t.y + pos[i][1];           if (a[tx][ty] == -1 || a[tx][ty] == 1)continue; //判断是否越界或者碰到障碍           if (a[tx][ty] == 0)\t\t//如果未被访问，           &#123;               dis[tx][ty] = dis[t.x][t.y] + 1; //记录当前点到起点的距离               a[tx][ty] = -1;\t\t\t    //标记扩展的新结点被访问               q.push(&#123;tx,ty&#125;);\t\t\t\t//将扩展的新节点入队           &#125;           if (tx == n &amp;&amp; ty == m) //如果到达右下角           &#123;           cout &lt;&lt; dis[tx][ty]; //返回右下角到起点的距离           return;           &#125;        &#125;        &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(a, -1, sizeof a); //初始化为 - 1 ，这样方便 判断边界        for (int i = 1; i &lt;= n; i++) //从1开始读入地图方便判断边界，这样地图都会被初始化的 - 1 包围            for (int j = 1; j &lt;= m; j++) //这样判断扩展的点是否越界时，只要判断是不是 - 1 即可            &#123;                cin &gt;&gt; a[i][j];            &#125;    PII start; //定义一个二元组，储存起点，传入到BFS函数里        start.x = 1, start.y = 1;    bfs(start);    return 0;&#125;\n\n五.感悟1.csp  201403-2（窗口）\n独立完成，有点开心，放在这吧\n#include &lt;iostream&gt;using namespace std;int n, m;int a[2600], b[1500], c[2600], d[1500];int s[2600][1500];void chu(int a, int b, int c, int d, int q)&#123;\tfor (int i = a; i &lt;= c; i++)\t&#123;\t\tfor (int j = b; j &lt;= d; j++)\t\t&#123;\t\t\ts[i][j] = q;\t\t&#125;\t&#125;&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int q=1;q&lt;=n;q++)\t&#123;\t\tcin &gt;&gt; a[q] &gt;&gt; b[q] &gt;&gt; c[q] &gt;&gt; d[q];\t\tchu(a[q], b[q], c[q], d[q], q);\t&#125;\twhile(m--)\t&#123;\t\tint x, y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tif (s[x][y] &gt; 0)\t\t&#123;\t\t\tcout &lt;&lt; s[x][y]&lt;&lt;endl;\t\t\t\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;IGNORED\\n&quot;;\t\t&#125;\t\tchu(a[s[x][y]], b[s[x][y]], c[s[x][y]], d[s[x][y]], s[x][y]);\t&#125;\treturn 0;&#125;\n\n","categories":["算法"],"tags":["基础"]}]