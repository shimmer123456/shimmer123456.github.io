[{"title":"算法基础","url":"/2022/11/24/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","content":"一.排序1.快排模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n, i, j;int q[N];void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return;int x = q[(l+r)/2]; i = l - 1; j = r + 1;while (i&lt;j)&#123;\tdo i++; while (q[i] &lt; x);\tdo j--; while (q[j] &gt; x);\tif (i&lt;j) swap(q[i], q[j]);&#125;quick_sort(q, l, j);quick_sort(q, j + 1, r);&#125;int main()&#123;\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;q[i]);\t&#125;\tquick_sort(q, 0, n - 1);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tprintf(&quot;%d&quot;, q[i]);\t&#125;\treturn 0;&#125;\n\n2.归并排序归并排序（acwing 逆序对的数量）\n个人理解，归并排序在递归完成之后会将整个数组相邻两个数分为一组，这时，只存在左右两边的情况，而本层计算完成之后，返回上一层计算，这里的同时在 一边的逆序数对刚刚已经计算完了（往上一层分组减少一半），所以只需要计算跨左右的情况就可以了\n #include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define array arrconst int N = 100010;int array[N];int nums;unsigned long result = 0;void merge_sort(int array[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = (l + r) / 2;    merge_sort(array, l, mid);//递归左右两边  递归结果就是两个为一组    merge_sort(array, mid + 1, r);//    int temp[r - l + 1];    int lptr = l;    int rptr = mid + 1;    int tempptr = 0;    while (lptr &lt;= mid &amp;&amp; rptr &lt;= r)    &#123;        if (array[lptr] &lt;= array[rptr])        &#123;            temp[tempptr++] = array[lptr++];        &#125;        else &#123;            temp[tempptr++] = array[rptr++];            result += (mid - lptr + 1);//注意这里，是直接加的，后面的不需要比较了。        &#125;    &#125;    while (lptr &lt;= mid)    &#123;        temp[tempptr++] = array[lptr++];    &#125;    while (rptr &lt;= r)    &#123;        temp[tempptr++] = array[rptr++];    &#125;    for (int i = l, j = 0; i &lt;= r; i++, j++)    &#123;        array[i] = temp[j];    &#125;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;nums);    for (int i = 0; i &lt; nums; i++)    &#123;        scanf(&quot;%d&quot;, &amp;array[i]);    &#125;    merge_sort(array, 0, nums - 1);    cout &lt;&lt; result;    return 0;&#125;\n\n二.查找1.二分查找#include &lt;iostream&gt;using namespace std;int main()&#123;\tint n, num[105], targe;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tcin &gt;&gt; num[i];\t&#125;\tcin &gt;&gt; targe;\tint l = 0, r = n - 1;\twhile (l &lt;= r)\t&#123;\t\tint mid = (l + r) &gt;&gt; 1;\t\tif (num[mid] == targe)\t\t&#123;\t\t\tcout &lt;&lt; targe &lt;&lt; &quot;in index&quot; &lt;&lt; mid &lt;&lt; endl;\t\t\treturn 0;\t\t&#125;\t\tif (num[mid] &lt; targe)\t\t&#123;\t\t\tr = mid - 1;\t\t&#125;\t\telse\t\t&#123;\t\t\tl = mid + 1;\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;no&quot; &lt;&lt; endl;\treturn 0;&#125;\n\n三.数据结构1.Trie树 高效的存储和查找字符串集合的数据结构\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26], cnt[N], idx;int i;void insert(char str[])//插入一个字符串&#123;\tint p = 0;//节点 从零开始\t\tfor ( i = 0; str[i]; i++)\t&#123;\t\tint u = str[i] - &#x27;a&#x27;;\t\tif (!son[p][u]) son[p][u] = ++idx;//如果没有对应的下一节点，创造一个 idx给了个编号\t\tp = son[p][u];       //idx是每次加一的，所以使得p每次加一；\t\t//也就是上一节点存储下一节点的位置，在接下来查找的时候才可以找到\t&#125;\tcnt[p]++;//以p为节点的结束次数！！！&#125;int query(char str[])//查找&#123;\tint p = 0;\tfor ( i = 0; str[i]; i++)\t&#123;\t\tint u = str[i] - &#x27;a&#x27;;\t\tif (!son[p][u]) return 0;\t\tp = son[p][u];//son[p][u]的值就是下一个节点的坐标\t&#125;\treturn cnt[p];&#125;char str[N];int main()&#123;\tint n;\tscanf(&quot;%d&quot;, &amp;n);\twhile (n--)\t&#123;\t\tchar op[2];\t\tscanf(&quot;%s%s&quot;, op,str);\t\tif (op[0] == &#x27;I&#x27;) insert(str);\t\telse printf(&quot;%d\\n&quot;, query(str));\t&#125;\treturn 0;&#125;\n\n2.并查集1.将两个集合合并2.询问两个元素是否在一个集合中\n原理：每个集合用一颗树来表示，树根的编号就是集合的编号；每个节点存储他的父节点p[x]表示x的父节点1.如何判断树根 p[x]&#x3D;x则是树根2.如何求x的树根编号： while(p[x]!&#x3D;x) x&#x3D;p[x];   只要不等，一直往上走；3.如何合并集合  两棵树 一颗插入另一颗px是x的集合编号 py是y的集合编号   p[x]&#x3D;y 即可\n对2. 优化：（路径压缩） 一旦往上走找到根节点，那么将该路径上的所有点直接指向根节点   大概为o1的时间复杂度\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int p[N]; int find(int x)//核心&#123;\tif (p[x] != x) p[x] = find(p[x]);//返回x的祖宗节点 并且加路径优化\treturn p[x];&#125; int main()&#123;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\tfor (int i = 0; i &lt;= n; i++) p[i] = i;\twhile (m--)\t&#123;\t\tchar op[2];\t\tint a, b;\t\tscanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b);\t\tif (op[0] == &#x27;M&#x27;)\t\t&#123;\t\t\tp[find(a)] = find(b);//把b的祖宗节点插入a的祖宗节点下当儿子\t\t&#125;\t\telse\t\t&#123;\t\t\tif (find(a) == find(b))\t\t\t&#123;\t\t\t\tputs(&quot;yes&quot;);\t\t\t&#125;\t\t\telse\t\t\t\tputs(&quot;No&quot;);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.前缀和求区间 [r,l] 之中数的和\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], s[N];int main()&#123;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);//n个数  m次操作\tfor (int i = 1; i &lt;= n; i++)//注意是1~n\t&#123;\t\tscanf(&quot;%d&quot;, &amp;a[i]);//读入n个数\t&#125;\tfor (int i = 1; i &lt;= n; i++)//注意1~n\t&#123;\t\ts[i] = s[i - 1] + a[i];//预处理\t&#125;\twhile (m--)\t&#123;\t\tint l, r;\t\tscanf(&quot;%d%d&quot;, &amp;l, &amp;r);//求l到r区间的和\t\tprintf(&quot;%d\\n&quot;, s[r] - s[l - 1]);\t&#125;\treturn 0;&#125;\n\n4.差分（前缀的逆运算）\n在指定区间都加c（原数组a[N]）由o(n) 到 o(1)\n#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], b[N];int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)//1~n    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        b[i] = a[i] - a[i - 1];      //构建差分数组    &#125;    int l, r, c;    while (m--)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);        b[l] += c;     //将序列中[l, r]之间的每个数都加上c        b[r + 1] -= c;    &#125;    for (int i = 1; i &lt;= n; i++)//1~n    &#123;        a[i] = b[i] + a[i - 1];    //前缀和运算        printf(&quot;%d &quot;, a[i]);    &#125;    return 0;&#125;\n\n5.单链表数组模拟的，但其实通常用stl\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int e[N], ne[N], head, idx;//对链表进行初始化void init() &#123;    head = -1;//最开始的时候，链表的头节点要指向-1，    //为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束    /*    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针    当它在初始化的时候指向-1，来表示链表里没有内容。    */    idx = 0;//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找    //第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下    //标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！    /*    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。    另外，我们遍历链表的时候也是这样，靠的是ne[]    */&#125;//将x插入到头节点上void int_to_head(int x) &#123;//和链表中间插入的区别就在于它有head头节点    e[idx] = x;//第一步，先将值放进去    ne[idx] = head;//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了    //先在只是做到了第一步，将元素x的指针指向了head原本指向的    head = idx;//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）    idx++;//指针向下移一位，为下一次插入元素做准备。&#125;//e[idx]=x;// ne[idx]=head;// head=idx;// idx++;//将x插入到下标为k的点的后面void add(int k, int x) &#123;    e[idx] = x;//先将元素插进去    e[idx]=x;ne[idx]=ne[k];ne[k]=idx;idx++;    ne[idx] = ne[k];//让元素x配套的指针，指向它要占位的元素的下一个位置    ne[k] = idx;//让原来元素的指针指向自己    idx++;//将idx向后挪&#125;//将下标是k的点后面的点个删掉void remove(int k) &#123;    ne[k] = ne[ne[k]];//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。&#125;//ne[k]=ne[ne[k]]//传进来的是k-1int main() &#123;    cin &gt;&gt; n;    init();//初始化    for (int i = 0; i &lt; n; i++)     &#123;        char s;        cin &gt;&gt; s;        if (s == &#x27;H&#x27;) &#123;            int x;            cin &gt;&gt; x;            int_to_head(x);        &#125;        if (s == &#x27;D&#x27;) &#123;            int k;            cin &gt;&gt; k;            if (k == 0) head = ne[head];//删除头节点            else remove(k - 1);//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1        &#125;        if (s == &#x27;I&#x27;) &#123;            int k, x;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);//同样的，第k个数，和下标不同，所以要减1        &#125;    &#125;    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;    return 0;&#125;\n\n6.队列我觉得是一个双指针在维护这个数据结构吧先进的先出  后进的后出 tt就是维护队尾位置的下标 如果要队头出列的话 hh++就可以 遍历的时候i&lt;&#x3D;hh就可以了（输出时候队头开始遍历）\n#include&lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1e6 + 10;int qu[N], hh = 0, tt = -1;//初始化很重要！！！int main()&#123;    int n;    cin &gt;&gt; n;    while (n--)    &#123;        int x;        string a;        cin &gt;&gt; a;        if (a == &quot;push&quot;)            cin &gt;&gt; x, qu[++tt] = x;//元素只能队尾入队        else if (a == &quot;pop&quot;)            hh++;//注意元素只能队头弹出，且是 ++        else if (a == &quot;empty&quot;)//队内是否为空        &#123;            if (tt &lt; hh)                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else//查询队头            cout &lt;&lt; qu[hh] &lt;&lt; endl;    &#125;     for (int i = tt; i &lt;= hh; i++)    &#123;        printf(&quot;%d&quot;, qu[i]);    &#125;    return 0;&#125;\n\n\n\n四.搜索1.DFS输出n个数的全排列\n（DFS八皇后也仅仅是扩展到二维数组而已 （acwing））\n#include &lt;iostream&gt;using namespace std;const int N = 10;int n;bool book[N];int st[N];void dfs(int u)&#123;\tif (u &gt; n)\t&#123;\t\tfor (int i = 1; i &lt;= n; i++)\t\t&#123;\t\t\tprintf(&quot;%d&quot;, st[i]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\treturn;\t&#125;\tfor (int i = 1; i &lt;= n; i++)\t&#123;\t\tif (!book[i])\t\t&#123;\t\t\tst[u]=i;\t\t\tbook[i] = true;\t\t\tdfs(u + 1);\t\t\t\t\t\t\t\t\t //能走到这一步说明是打印完之后return的，来到了当时的上一层，在这\t\t\tst[u] = 0;  //回溯\t\t\tbook[i] = false;  \t\t\t////////  忘了时候再仔细调试看看，终于懂了。\t\t&#125;\t&#125;&#125;int main()&#123;\tcin &gt;&gt; n;\tdfs(1);\treturn 0;&#125;\n\n1.1dfs的例题dfs的指数级枚举，真的妙！！！ \n#include &lt;iostream&gt;using namespace std;const int N = 1e1 + 6; //定义一个常量Nint n;int st[N];  //记录每个位置当前的状态：0表示还没考虑，1表示选它，2表示不选它void dfs(int u) // 枚举的第几个数字&#123;    if (u &gt; n) &#123;        //终止条件，因为题目要求一个就n个数 所以只有 u &gt; n 就输出枚举的方案        for (int i = 1; i &lt;= n; i++)            if (st[i] == 1)                printf(&quot;%d &quot;, i);        puts(&quot;&quot;);        return;    &#125;    st[u] = 1;   //选它的分支    dfs(u + 1);    st[u] = 0;   //恢复现场，以便进行下一个分支    st[u] = 2; //  不选它的分支    dfs(u + 1);    st[u] = 0;  // 恢复现场&#125;int main(void)&#123;    scanf(&quot;%d&quot;, &amp;n);    dfs(1);    return 0;&#125;\n\n\n\n2.BFS在DFS中我们说关键点是递归以及回溯，\n在BFS中，关键点则是状态的选取和标记\nBFS 迷宫：一个while大循环，只要不空就以一直走  每次取出队头下面一个for的四个方向的循环 符合条件就会向外扩展 注意都是扩展在t的基础上的（一个点） 然后：每个被扩展出来的都会进队列，继续扩展，如果扩展不了就四个for都不满足，在下一次循环中他就被弹出了\n#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;#define x first#define y second int n, m;typedef pair&lt;int, int&gt;PII;int a[110][110];   //储存地图int dis[110][110];  //储存距离int pos[4][2] = &#123; -1,0,0,1,1,0,0,-1 &#125;; //偏移量数组void bfs(PII start)&#123;    queue&lt;PII&gt; q;    q.push(start);\t\t//初始状态入队        while (!q.empty()) \t//队列不空时        &#123;            PII t = q.front();       // 取出队首元素，存放到 t 变量里 ，元素出队            q.pop(); \t\t\t\t//元素出队            for (int i = 0; i &lt; 4; i++)//\t扩展 t 结点        &#123;           int tx = t.x + pos[i][0],ty = t.y + pos[i][1];           if (a[tx][ty] == -1 || a[tx][ty] == 1)continue; //判断是否越界或者碰到障碍           if (a[tx][ty] == 0)\t\t//如果未被访问，           &#123;               dis[tx][ty] = dis[t.x][t.y] + 1; //记录当前点到起点的距离               a[tx][ty] = -1;\t\t\t    //标记扩展的新结点被访问               q.push(&#123;tx,ty&#125;);\t\t\t\t//将扩展的新节点入队           &#125;           if (tx == n &amp;&amp; ty == m) //如果到达右下角           &#123;           cout &lt;&lt; dis[tx][ty]; //返回右下角到起点的距离           return;           &#125;        &#125;        &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(a, -1, sizeof a); //初始化为 - 1 ，这样方便 判断边界        for (int i = 1; i &lt;= n; i++) //从1开始读入地图方便判断边界，这样地图都会被初始化的 - 1 包围            for (int j = 1; j &lt;= m; j++) //这样判断扩展的点是否越界时，只要判断是不是 - 1 即可            &#123;                cin &gt;&gt; a[i][j];            &#125;    PII start; //定义一个二元组，储存起点，传入到BFS函数里        start.x = 1, start.y = 1;    bfs(start);    return 0;&#125;\n\n五.感悟1.csp  201403-2（窗口）\n独立完成，有点开心，放在这吧\n#include &lt;iostream&gt;using namespace std;int n, m;int a[2600], b[1500], c[2600], d[1500];int s[2600][1500];void chu(int a, int b, int c, int d, int q)&#123;\tfor (int i = a; i &lt;= c; i++)\t&#123;\t\tfor (int j = b; j &lt;= d; j++)\t\t&#123;\t\t\ts[i][j] = q;\t\t&#125;\t&#125;&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int q=1;q&lt;=n;q++)\t&#123;\t\tcin &gt;&gt; a[q] &gt;&gt; b[q] &gt;&gt; c[q] &gt;&gt; d[q];\t\tchu(a[q], b[q], c[q], d[q], q);\t&#125;\twhile(m--)\t&#123;\t\tint x, y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tif (s[x][y] &gt; 0)\t\t&#123;\t\t\tcout &lt;&lt; s[x][y]&lt;&lt;endl;\t\t\t\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;IGNORED\\n&quot;;\t\t&#125;\t\tchu(a[s[x][y]], b[s[x][y]], c[s[x][y]], d[s[x][y]], s[x][y]);\t&#125;\treturn 0;&#125;\n\n","categories":["数据结构与算法"],"tags":["基础"]},{"title":"css基础","url":"/2022/11/24/CSS3/","content":"CSS31.初识CSS3CSS3给我们带来了什么好处呢？简单的说，CSS3把很多以前需要使用图片和脚本来实现的效果、甚至动画效果，只需要短短几行代码就能搞定。比如圆角，图片边框，文字阴影和盒阴影，过渡、动画等。\n选择器以前我们通常用class、 ID 或 tagname 来选择HTML元素，CSS3的选择器强大的难以置信。它们可以减少在标签中的class和ID的数量更方便的维护样式表、更好的实现结构与表现的分离。\n\n圆角效果以前做圆角通常使用背景图片，或繁琐的元素拼凑，现在很简单了 border-radius 帮你轻松搞定。\n\n块阴影与文字阴影可以对任意DIV和文字增加投影效果。\n\n色彩CSS3支持更多的颜色和更广泛的颜色定义。新颜色CSS3支持HSL ， CMYK ，HSLA and RGBA。\n\n渐变效果以前只能用Photoshop做出的图片渐变效果，现在可以用CCS写出来了。IE中的滤镜也可以实现。\n\n个性化字体网页上的字体太单一？使用@Font-Face 轻松实现定制字体。\n\n多背景图一个元素上添加多层背景图片。\n\n边框背景图边框应用背景图片。\n\n变形处理你可以对HTML元素进行旋转、缩放、倾斜、移动、甚至以前只能用JavaScript实现的强大动画。\n\n多栏布局可以让你不用使用多个div标签就能实现多栏布局。浏览器解释这个属性并生成多栏，让文本实现一个仿报纸的多栏结构。\n\n媒体查询针对不同屏幕分辨率，应用不同的样式。\n\n等等 ……\n2. 边框2.1 圆角效果 border-radius border-radius是向元素添加圆角边框。\n使用方法：\nborder-radius:10px; &#x2F;* 所有角都使用半径为10px的圆角 *&#x2F; \nborder-radius: 5px 4px 3px 2px; &#x2F;* 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 *&#x2F; \n不要以为border-radius的值只能用px单位，你还可以用百分比或者em，但兼容性目前还不太好。\n实心上半圆：\n方法：把高度(height)设为宽度（width）的一半，并且只设置左上角和右上角的半径与元素的高度一致（大于也是可以的）。\ndiv&#123;    height:50px;/*是width的一半*/    width:100px;    background:#9da;    border-radius:50px 50px 0 0;/*半径至少设置为height的值*/    &#125;\n\n实心圆：方法：把宽度（width）与高度(height)值设置为一致（也就是正方形），并且四个圆角值都设置为它们值的一半。如下代码：\ndiv&#123;    height:100px;/*与width设置一致*/    width:100px;    background:#9da;    border-radius:50px;/*四个圆角值都设置为宽度或高度值的一半*/    &#125;\n\n2.2 阴影 box-shadow（一）box-shadow是向盒子添加阴影。支持添加一个或者多个。\n很简单的一段代码，就实现了投影效果，酷毙了。我们来看下语法：\nbox-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];参数介绍：\n\n注意：inset 可以写在参数的第一个或最后一个，其它位置是无效的。\n为元素设置外阴影：\n示例代码：\n.box_shadow&#123;  box-shadow:4px 2px 6px #333333; &#125;\n\n为元素设置内阴影：\n示例代码：\n.box_shadow&#123;  box-shadow:4px 2px 6px #333333 inset; &#125;\n\n添加多个阴影：\n以上的语法的介绍，就这么简单，如果添加多个阴影，只需用逗号隔开即可。如：\n.box_shadow&#123;    box-shadow:4px 2px 6px #f00, -4px -2px 6px #000, 0px 0px 12px 5px #33CC00 inset;&#125;效果：\n\n\n\n2.3 阴影 box-shadow（二）1、阴影模糊半径与阴影扩展半径的区别\n阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；\n阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；\n2、X轴偏移量和Y轴偏移量值可以设置为负数\nbox-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];\n\nX轴偏移量为负数：\n.boxshadow-outset&#123;    width:100px;    height:100px;    box-shadow:-4px 4px 6px #666;&#125;\n\n\n\n\n\nY轴偏移量为负数：\n.boxshadow-outset&#123;    width:100px;    height:100px;    box-shadow:4px -4px 6px #666;&#125;\n\n\n\n2.4 为边框应用图片 border-image顾名思义就是为边框应用背景图片，它和我们常用的background属性比较相似。例如：\nbackground:url(xx.jpg) 10px 20px no-repeat;\n\n但是又比背景图片复杂一些。\n想象一下：一个矩形，有四个边框。如果应用了边框图片，图片该怎么分布呢？ 图片会自动被切割分成四等分。用于四个边框。可以理解为它是一个切片工具，会自动把用做边框的图片切割。怎么切割呢？为了方便理解，做了一张特殊的图片，由9个矩形（70*70像素）拼成的一张图（210*210像素），并标注好序号，是不是像传说中的九宫图，如下：\n\n根据border-image的语法：\n#border-image&#123;   background:#F4FFFA;   width:210px; height:210px; border:70px solid #ddd;   border-image:url(borderimg.png) 70 repeat  &#125;\n\n从序号可以看出div的四个角分别对应了背景图片的四个角。而2,4,6,8 被重复。5在哪？因为是从四周向中心切割图片的所以，5显示不出来。而在chrome浏览器中5是存在的，下图的样子：repeat的意思就是重复，目前因为是刚好被整除，效果看不出来。如果改下DIV的宽高，再来看重复的效果：\n\n边角部分为裁掉了，可见repeat就是一直重复，然后超出部分剪裁掉，而且是居中开始重复。\nRound 参数：Round可以理解为圆满的铺满。为了实现圆满所以会压缩（或拉伸）；\n#border-image &#123;     width:170px;     height:170px;     border:70px solid;     border-image:url(borderimg.png) 70 round; &#125;\n\n3. 颜色相关3.1 颜色之RGBARGB是一种色彩标准，是由红(R)、绿(G)、蓝(B)的变化以及相互叠加来得到各式各样的颜色。RGBA是在RGB的基础上增加了控制alpha透明度的参数。\n语法：\ncolor：rgba(R,G,B,A)\n\n以上R、G、B三个参数，正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限。并非所有浏览器都支持使用百分数值。A为透明度参数，取值在0~1之间，不可为负值。\n代码示例：\nbackground-color:rgba(100,120,60,0.5);\n\n3.2 渐变色彩CSS3 Gradient 分为**线性渐变(linear)和径向渐变(radial)**。由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。\n这一小节我们来说一下线性渐变：\n参数：\n第一个参数:指定渐变方向，可以用“角度”的关键词或“英文”来表示：\n第一个参数省略时，默认为“180deg”，等同于“to bottom”。\n第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。\nbackground-image:linear-gradient(to left, red, orange,yellow,green,blue,indigo,violet);\n\n4. 文字与字体4.1 text-overflow 与 word-wraptext-overflow用来设置是否使用一个省略标记（…）标示对象内文本的溢出。\n但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：\ntext-overflow:ellipsis; overflow:hidden; white-space:nowrap; \n\n同时，word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行。\nnormal为浏览器默认值，break-word设置在长单词或 URL地址内部进行换行，此属性不常用，用浏览器默认值即可。\n4.2 嵌入字体@font-face@font-face能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体。\n语法：\n@font-face &#123;    font-family : 字体名称;    src : 字体文件在服务器上的相对或绝对路径;&#125;\n\n这样设置之后，就可以像使用普通字体一样在（font-*）中设置字体样式。\n比如：\np &#123;    font-size :12px;    font-family : &quot;My Font&quot;;    /*必须项，设置@font-face中font-family同样的值*/&#125;\n\n4.3 文本阴影text-shadowtext-shadow可以用来设置文本的阴影效果。\n语法：\ntext-shadow: X-Offset Y-Offset blur color;\n\nX-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移；   \nY-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移；\nBlur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0；\nColor：是指阴影的颜色，其可以使用rgba色。\n比如，我们可以用下面代码实现设置阴影效果。\ntext-shadow: 0 1px 1px #fff\n\n5.与背景相关的样式5.1 background-origin设置元素背景图片的原始起始位置。\n语法：\nbackground-origin ： border-box | padding-box | content-box;\n\n参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。\n需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。\n5.2 background-clip用来将背景图片做适当的裁剪以适应实际需要。\n语法：\nbackground-clip ： border-box | padding-box | content-box | no-clip\n\n参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。backgroud-clip默认值为border-box。\n5.3 background-size设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。\n语法：\nbackground-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain\n\n取值说明：\n1、auto：默认值，不改变背景图片的原始高度和宽度；\n2、&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；\n**3、&lt;百分比&gt;**：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；\n4、cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；\n5、contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。\n5.4 multiple backgrounds？？？多重背景，也就是CSS2里background的属性外加origin、clip和size组成的新background的多次叠加，缩写时为用逗号隔开的每组值；用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。\n语法缩写如下：\nbackground ： [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],...\n\n可以把上面的缩写拆解成以下形式：\nbackground-image:url1,url2,…,urlN;\nbackground-repeat : repeat1,repeat2,...,repeatN;backround-position : position1,position2,...,positionN;background-size : size1,size2,...,sizeN;background-attachment : attachment1,attachment2,...,attachmentN;background-clip : clip1,clip2,...,clipN;background-origin : origin1,origin2,...,originN;background-color : color;\n\n注意：\n\n用逗号隔开每组 background 的缩写值；\n如果有 size 值，需要紧跟 position 并且用 “&#x2F;“ 隔开；\n如果有多个背景图片，而其他属性只有一个（例如 background-repeat 只有一个），表明所有背景图片应用该属性值。\nbackground-color 只能设置一个。\n\n6. CSS3选择器6.1 属性选择器  在HTML中，通过各种各样的属性可以给元素增加很多附加的信息。例如，通过id属性可以将不同div元素进行区分。\n  在CSS2中引入了一些属性选择器，而CSS3在CSS2的基础上对属性选择器进行了扩展，新增了3个属性选择器，使得属性选择器有了通配符的概念，这三个属性选择器与CSS2的属性选择器共同构成了CSS功能强大的属性选择器。如下表所示：\n 实例展示：\nhtml代码：\n&lt;a href=&quot;xxx.pdf&quot;&gt;我链接的是PDF文件&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;icon&quot;&gt;我类名是icon&lt;/a&gt;&lt;a href=&quot;#&quot; title=&quot;我的title是more&quot;&gt;我的title是more&lt;/a&gt;\n\ncss代码 \na[class^=icon]&#123;  background: green;  color:#fff;&#125;a[href$=pdf]&#123;  background: orange;  color: #fff;&#125;a[title*=more]&#123;  background: blue;  color: #fff;&#125;\n\n\n\n6.2 结构性伪类选择器—root:root选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是。\n示例演示：\n通过“:root”选择器设置背景颜色\nHTML代码：\n&lt;div&gt;:root选择器的演示&lt;/div&gt;\n\nCSS代码：\n:root &#123;  background:orange;&#125;\n\n\n\n“:root”选择器等同于元素，简单点说：\n:root&#123;background:orange&#125;html &#123;background:orange;&#125;\n\n得到的效果等同。\n建议使用:root方法。\n另外在IE９以下还可以借助“:root”实现hack功能。\n6.3 结构性伪类选择器—not:not选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。就拿form元素来说，比如说你想给表单中除submit按钮之外的input元素添加红色边框，CSS代码可以写成：\nform &#123;  width: 200px;  margin: 20px auto;&#125;div &#123;  margin-bottom: 20px;&#125;input:not([type=&quot;submit&quot;])&#123;  border:1px solid red;&#125;\n\n相关HTML代码：\n&lt;form action=&quot;#&quot;&gt;  &lt;div&gt;    &lt;label for=&quot;name&quot;&gt;Text Input:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;John Smith&quot; /&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;label for=&quot;name&quot;&gt;Password Input:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;John Smith&quot; /&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  &lt;/div&gt;&lt;/form&gt;  \n\n\n\n6.4 结构性伪类选择器—empty:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。\n示例显示：\n比如说，你的文档中有三个段落p元素，你想把没有任何内容的P元素隐藏起来。我们就可以使用“:empty”选择器来控制。\nHTML代码：\n&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n\nCSS代码：\np&#123; background: orange; min-height: 30px;&#125;p:empty &#123;  display: none;&#125;\n\n\n\n6.5 CSS3 结构性伪类选择器—target:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。我们先来上个例子，然后再做分析。\n示例展示\n点击链接显示隐藏的段落。\nHTML代码：\n&lt;h2&gt;&lt;a href=&quot;#brand&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;menuSection&quot; id=&quot;brand&quot;&gt;    content for Brand&lt;/div&gt;\n\nCSS代码：\n.menuSection&#123;  display: none;&#125;:target&#123;/*这里的:target就是指id=&quot;brand&quot;的div对象*/  display:block;&#125;\n\n\n\n分析：\n1、具体来说，触发元素的URL中的标志符通常会包含一个**#号，后面带有一个标志符名称**，上面代码中是：#brand\n2、：target就是用来匹配id为“brand”的元素（id&#x3D;”brand”的元素）,上面代码中是那个div元素。\n多个url（多个target）处理：\n就像上面的例子，#brand与后面的id&#x3D;”brand”是对应的，当同一个页面上有很多的url的时候你可以取不同的名字，只要#号后对的名称与id&#x3D;””中的名称对应就可以了。如下面例子：html代码：  \n&lt;h2&gt;&lt;a href=&quot;#brand&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;menuSection&quot; id=&quot;brand&quot;&gt;  content for Brand&lt;/div&gt;&lt;h2&gt;&lt;a href=&quot;#jake&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;menuSection&quot; id=&quot;jake&quot;&gt; content for jake&lt;/div&gt;&lt;h2&gt;&lt;a href=&quot;#aron&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;menuSection&quot; id=&quot;aron&quot;&gt;    content for aron&lt;/div&gt;\n\ncss代码：\n#brand:target &#123;  background: orange;  color: #fff;&#125;#jake:target &#123;  background: blue;  color: #fff;&#125;#aron:target &#123;  background: red;  color: #fff;&#125;\n\n上面的代码可以对不同的target对象分别设置不的样式。\n6.6 CSS3 结构性伪类选择器—first-child“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。\n示例演示\n通过“:first-child”选择器定位列表中的第一个列表项，并将序列号颜色变为红色。\nHTML代码：\n&lt;ol&gt;  &lt;li&gt;&lt;a href=&quot;##&quot;&gt;Link1&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;##&quot;&gt;Link2&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;##&quot;&gt;link3&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;\n\nCSS代码：\nol &gt; li&#123;  font-size:20px;  font-weight: bold;  margin-bottom: 10px;&#125;ol a &#123;  font-size: 16px;  font-weight: normal;&#125;ol &gt; li:first-child&#123;  color: red;&#125;\n\n\n\n6.7 CSS3 结构性伪类选择器—last-child“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。例如，需要改变的是列表中的最后一个“li”的背景色，就可以使用这个选择器，\nul&gt;li:last-child&#123;background:blue;&#125;\n\n示例演示\n在博客的排版中，每个段落都有15px的margin-bottom，假设不想让博客“post”中最后一个段落不需要底部的margin值，可以使用“:last-child”选择器。\nHTML代码：\n&lt;div class=&quot;post&quot;&gt;  &lt;p&gt;第一段落&lt;/p&gt;  &lt;p&gt;第二段落&lt;/p&gt;  &lt;p&gt;第三段落&lt;/p&gt;  &lt;p&gt;第四段落&lt;/p&gt;  &lt;p&gt;第五段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.post &#123;  padding: 10px;  border: 1px solid #ccc;  width: 200px;  margin: 20px auto;&#125;.post p &#123;  margin:0 0 15px 0;&#125;.post p:last-child &#123;  margin-bottom:0;&#125;\n\n\n\n6.8 CSS3 结构性伪类选择器—nth-child(n)“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。\n经验与技巧:当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素。\n案例演示\n 通过“:nth-child(n)”选择器，并且参数使用表达式“2n”，将偶数行列表背景色设置为橙色。\nHTML代码：\n&lt;ol&gt;  &lt;li&gt;item1&lt;/li&gt;  &lt;li&gt;item2&lt;/li&gt;  &lt;li&gt;item3&lt;/li&gt;  &lt;li&gt;item4&lt;/li&gt;  &lt;li&gt;item5&lt;/li&gt;  &lt;li&gt;item6&lt;/li&gt;  &lt;li&gt;item7&lt;/li&gt;  &lt;li&gt;item8&lt;/li&gt;  &lt;li&gt;item9&lt;/li&gt;  &lt;li&gt;item10&lt;/li&gt;&lt;/ol&gt;\n\nCSS代码：\nol &gt; li:nth-child(2n)&#123;  background: orange;&#125;\n\n\n\n6.9 CSS3 结构性伪类选择器—nth-last-child(n)“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。\n案例演示\n选择列表中倒数第五个列表项，将其背景设置为橙色。\nHTML代码：\n&lt;ol&gt;  &lt;li&gt;item1&lt;/li&gt;  &lt;li&gt;item2&lt;/li&gt;  &lt;li&gt;item3&lt;/li&gt;  &lt;li&gt;item4&lt;/li&gt;  &lt;li&gt;item5&lt;/li&gt;  &lt;li&gt;item6&lt;/li&gt;  &lt;li&gt;item7&lt;/li&gt;  &lt;li&gt;item8&lt;/li&gt;  &lt;li&gt;item9&lt;/li&gt;  &lt;li&gt;item10&lt;/li&gt;  &lt;li&gt;item11&lt;/li&gt;  &lt;li&gt;item12&lt;/li&gt;  &lt;li&gt;item13&lt;/li&gt;  &lt;li&gt;item14&lt;/li&gt;  &lt;li&gt;item15&lt;/li&gt;&lt;/ol&gt;\n\n**CSS代码：\n6.10 CSS3 first-of-type选择器“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。\n示例演示：\n通过“:first-of-type”选择器，定位div容器中的第一个p元素（p不一定是容器中的第一个子元素），并设置其背景色为橙色。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;div&gt;我是一个块元素，我是.wrapper的第一个子元素&lt;/div&gt;  &lt;p&gt;我是一个段落元素，我是不是.wrapper的第一个子元素，但是他的第一个段落元素&lt;/p&gt;  &lt;p&gt;我是一个段落元素&lt;/p&gt;  &lt;div&gt;我是一个块元素&lt;/div&gt;&lt;/div&gt;\n\nCSS代码：\n.wrapper &#123;  width: 500px;  margin: 20px auto;  padding: 10px;  border: 1px solid #ccc;  color: #fff;&#125;.wrapper &gt; div &#123;  background: green;&#125;.wrapper &gt; p &#123;  background: blue;&#125;/*我要改变第一个段落的背景为橙色*/.wrapper &gt; p:first-of-type &#123;  background: orange;&#125;\n\n\n\n6.11 CSS3 nth-of-type(n)选择器“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词。\n示例演示\n通过“:nth-of-type(2n)”选择器，将容器“div.wrapper”中偶数段数的背景设置为橙色。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落元素&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.wrapper &gt; p:nth-of-type(2n)&#123;  background: orange;&#125;\n\n\n\n6.12 CSS3 last-of-type选择器“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素。\n示例演示\n通过“:last-of-type”选择器，将容器“div.wrapper”中最后一个段落元素背景设置为橙色\n（提示：这个段落不是“div.wrapper”容器的最后一个子元素）。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;p&gt;我是第一个段落&lt;/p&gt;  &lt;p&gt;我是第二个段落&lt;/p&gt;  &lt;p&gt;我是第三个段落&lt;/p&gt;  &lt;div&gt;我是第一个Div元素&lt;/div&gt;  &lt;div&gt;我是第二个Div元素&lt;/div&gt;  &lt;div&gt;我是第三个Div元素&lt;/div&gt;&lt;/div&gt;\n\n\nCSS代码：\n .wrapper &gt; p:last-of-type&#123;  background: orange;&#125;\n\n\n\n6.13 CSS3 nth-last-of-type(n)选择器“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。\n示例演示\n通过“:nth-last-of-type(n)”选择器将容器“div.wrapper”中的倒数第三个段落背景设置为橙色。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;p&gt;我是第一个段落&lt;/p&gt;  &lt;p&gt;我是第二个段落&lt;/p&gt;  &lt;p&gt;我是第三个段落&lt;/p&gt;  &lt;p&gt;我是第四个段落&lt;/p&gt;  &lt;p&gt;我是第五个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是第六个段落&lt;/p&gt;  &lt;p&gt;我是第七个段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.wrapper &gt; p:nth-last-of-type(3)&#123;  background: orange;&#125;\n\n\n\n6.14 CSS3 only-child选择器“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。\n示例演示\n通过“:only-child”选择器，来控制仅有一个子元素的背景样式，为了更好的理解，我们这个示例通过对比的方式来向大家演示。\nHTML代码：\n&lt;div class=&quot;post&quot;&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;post&quot;&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.post p &#123;  background: green;  color: #fff;  padding: 10px;&#125;.post p:only-child &#123;  background: orange;&#125;\n\n\n\n6.15 CSS3 only-of-type选择器“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。\n示例演示\n通过“:only-of-type”选择器来修改容器中仅有一个div元素的背景色为橙色。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;wrapper&quot;&gt;  &lt;div&gt;我是一个Div&lt;/div&gt;  &lt;ul&gt;    &lt;li&gt;我是一个列表项&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.wrapper &gt; div:only-of-type &#123;  background: orange;&#125;\n\n\n\n6.16 CSS3选择器 :enabled选择器在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“**:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled**”对这些表单元素设置样式。\n示例演示\n通过“:enabled”选择器，修改文本输入框的边框为2像素的红色边框，并设置它的背景为灰色。\nHTML代码:\n&lt;form action=&quot;#&quot;&gt;  &lt;div&gt;    &lt;label for=&quot;name&quot;&gt;Text Input:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;可用输入框&quot;  /&gt;  &lt;/div&gt;   &lt;div&gt;    &lt;label for=&quot;name&quot;&gt;Text Input:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;禁用输入框&quot;  disabled=&quot;disabled&quot; /&gt;  &lt;/div&gt;&lt;/form&gt;  \n\nCSS代码：\ndiv&#123;  margin: 20px;&#125;input[type=&quot;text&quot;]:enabled &#123;  background: #ccc;  border: 2px solid red;&#125;\n\n\n\n6.17 CSS3选择器 :disabled选择器“**:disabled”选择器刚好与“:enabled**”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。\n示例演示\n通过“**:disabled**”选择器，给不可用输入框设置明显的样式。\nHTML代码：\n&lt;form action=&quot;#&quot;&gt;  &lt;div&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;我是可用输入框&quot; /&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;我是不可用输入框&quot; disabled /&gt;  &lt;/div&gt;&lt;/form&gt;  \n\n\nCSS代码\nform &#123;  margin: 50px;&#125;div &#123;  margin-bottom: 20px;&#125;input &#123;  background: #fff;  padding: 10px;  border: 1px solid orange;  border-radius: 3px;&#125;input[type=&quot;text&quot;]:disabled &#123;  background: rgba(0,0,0,.15);  border: 1px solid rgba(0,0,0,.15);  color: rgba(0,0,0,.15);&#125;\n\n\n\n6.18 CSS3选择器 :checked选择器在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“**:checked**”表示的是选中状态。\n示例演示：\n通过“:checked”状态来自定义复选框效果。\nHTML代码\n&lt;form action=&quot;#&quot;&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;usename&quot; /&gt;&lt;span&gt;√&lt;/span&gt;    &lt;/div&gt;    &lt;lable for=&quot;usename&quot;&gt;我是选中状态&lt;/lable&gt;  &lt;/div&gt;    &lt;div class=&quot;wrapper&quot;&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;input type=&quot;checkbox&quot;  id=&quot;usepwd&quot; /&gt;&lt;span&gt;√&lt;/span&gt;    &lt;/div&gt;    &lt;label for=&quot;usepwd&quot;&gt;我是未选中状态&lt;/label&gt;  &lt;/div&gt;&lt;/form&gt; \n\nCSS代码：\nform &#123;  border: 1px solid #ccc;  padding: 20px;  width: 300px;  margin: 30px auto;&#125;.wrapper &#123;  margin-bottom: 10px;&#125;.box &#123;  display: inline-block;  width: 20px;  height: 20px;  margin-right: 10px;  position: relative;  border: 2px solid orange;  vertical-align: middle;&#125;.box input &#123;  opacity: 0;  position: absolute;  top:0;  left:0;&#125;.box span &#123;  position: absolute;  top: -10px;  right: 3px;  font-size: 30px;  font-weight: bold;  font-family: Arial;  -webkit-transform: rotate(30deg);  transform: rotate(30deg);  color: orange;&#125;input[type=&quot;checkbox&quot;] + span &#123;  opacity: 0;&#125;input[type=&quot;checkbox&quot;]:checked + span &#123;  opacity: 1;&#125;\n\n\n\n6.19 CSS3选择器 ::selection选择器“**::selection”伪元素是用来匹配突出显示**的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示的，效果如下图所示：\n从上图中可以看出，用鼠标选中“专注IT、互联网技术”、“纯干货、学以致用”、“没错、这是免费的”这三行文本中，默认显示样式为：蓝色背景、白色文本。\n有的时候设计要求,不使用上图那种浏览器默认的突出文本效果，需要一个与众不同的效果，此时“**::selection”伪元素就非常的实用。不过在Firefox浏览器**还需要添加前缀。\n示例演示:\n通过“::selection”选择器，将Web中选中的文本背景变成红色，文本变成绿色。\nHTML代码：\n&lt;p&gt;“::selection”伪元素是用来匹配突出显示的文本。浏览器默认情况下，选择网站文本是深蓝的背景，白色的字体，&lt;/p&gt;\n\nCSS代码：\n::-moz-selection &#123;  background: red;  color: green;&#125;::selection &#123;  background: red;  color: green;&#125;\n\n\n\n注意：\n1、IE9+、Opera、Google Chrome 以及 Safari 中支持 ::selection 选择器。\n2、Firefox 支持替代的 ::-moz-selection。\n","categories":["开发"],"tags":["前端"]},{"title":"c语言讲座","url":"/2022/12/13/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E9%A2%98/","content":"c语言程序设计题一.分支与跳转（if else switch continue break case default goto)\n1．利用条件运算符的嵌套来完成此题：学习成绩&gt;&#x3D;90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。\n#include &lt;stdio.h&gt;int main()&#123;\tint sc;\tscanf(&quot;%d&quot;, &amp;sc);\tif (sc &gt;= 90)\t&#123;\t\tprintf(&quot;A\\n&quot;);\t&#125;\telse if (sc &gt;= 60 &amp;&amp; sc &lt;= 89)//注意这里不可以写成 60&lt;=sc &lt;=89 \t&#123;\t\tprintf(&quot;B\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;C\\n&quot;);\t&#125;\treturn 0;&#125;\n\n\n\n二.循环（while  for  do…while)\n1.计算下列表达式：s&#x3D;1！+2！+3！+4！+……+10！\n#include &lt;stdio.h&gt;int main()&#123;\tint i;\tint t=1, s=0;\tfor (i = 1; i &lt;= 10; i++)\t&#123;\t\tt *= i;\t\ts += t;\t&#125;\tprintf(&quot;%d&quot;, s);\treturn 0;&#125;\n\n2.九九乘法表（3种循环解决）\nfor循环：\n#include &lt;stdio.h&gt;int main()&#123;\tint i;      int j;\tfor (i = 1; i &lt;= 9; i++)\t&#123;\t\tfor (j = 1; j &lt;= i; j++)\t\t&#123;\t\t\tprintf(&quot;%d*%d=%2d &quot;, j, i, i * j);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\treturn 0;&#125;\n\nwhile：\n#include &lt;stdio.h&gt;int main()&#123;\tint row = 1;\twhile (row &lt;= 9)\t&#123;   \t  \tint col = 1;    \twhile (col &lt;= row)     \t&#123;       \t  \tprintf(&quot;%d * %d = %d\\t&quot;, col, row, col * row);         \tcol += 1;         &#125;    printf(&quot;\\n&quot;);     row += 1;      return 0;&#125;\n\n do while：\n#include&lt;stdio.h&gt;int main ()&#123;\tint i=1,j;\tdo&#123;\t\tj=1;\t\tdo&#123;\t\t\tprintf(&quot;%d*%d=%d &quot;,i,j,i*j);\t\t\tj++;\t\t&#125;while(j&lt;=i);\t\ti++; \t\tprintf(&quot;\\n&quot;); \t&#125;while(i&lt;=9);&#125; \n\n\n\n三.数组1.将一个一维数组{1,2,3,4,5,6,7,8,9,10}的成员逆序后输出\n正确的结果为：10 9 8 7 6 5 4 3 2 1\n#include&lt;stdio.h&gt;int main()&#123;  int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;  int t,i;  for(i=0;i&lt;5;i++)   &#123;    t=a[i];      a[i]=a[9-i];      a[9-i]=t;   &#125;  for(i=0;i&lt;10;i++)    printf(&quot;%d &quot;,a[i]);      printf(&quot;\\n&quot;);      return 0;&#125;\n\n2.打印杨辉三角前n行（二维数组）\n#include &lt;stdio.h&gt;int arr[31][31] = &#123; 0 &#125;;void init(int n)&#123;\tint i, j;\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tfor (j = 0; j &lt;= i; j++)\t\t&#123;\t\t\tif (j == 0 || j == i)\t\t\t\tarr[i][j] = 1;\t\t\telse\t\t\t\tarr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];\t\t&#125;\t&#125;&#125;int main()&#123;\tinit(30);\tint n, i, j;\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tfor (j = 0; j &lt;= i; j++)\t\t&#123;\t\t\tif (j != i)\t\t\t\tprintf(&quot;%d &quot;, arr[i][j]);\t\t\telse\t\t\t\tprintf(&quot;%d&quot;, arr[i][j]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;                1            1   2   1          1   3   3   1        1   4   6   4   1\n\n\n\n四.经典题1.输入两个正整数m和n，求其最大公约数。\n（辗转相除法）\n#include &lt;stdio.h&gt;int main()&#123;\tint a, b , temp;\tscanf(&quot;%d%d&quot; ,&amp;a, &amp;b);\tif (a &lt; b)\t&#123;\t\ttemp = a;\t\ta = b;\t\tb = temp;\t&#125;\t\t\twhile (b != 0)\t&#123;\t\ttemp = a % b;\t\ta = b;\t\tb = temp;\t&#125;\tprintf(&quot;最大公约数：%d\\n &quot;, a);\treturn 0;&#125;//求最大公约数可以使用gcd函数//自己实现：int gcd(int a,int b) &#123;    return b &gt; 0 ? gcd(b, a % b) : a;&#125;\n\n2.水仙花数：\n打印出所有得“水仙花数”，所谓“水仙花数”是指一个3位数，其各位数字的立方和等于该数本身，例如，152是水仙花数，因为153＝1×1×1＋5×5×5＋3×3×3。\n#include &lt;stdio.h&gt;int main()&#123;  int i,j,k,n;  printf(&quot;水仙花数是:&quot;);  for(n=100;n&lt;1000;n++)  &#123;\t  \ti=n/100;/*分解出百位*/    j=n/10%10;/*分解出十位*/    k=n%10;/*分解出个位*/    if(i*100+j*10+k==i*i*i+j*j*j+k*k*k)      printf(&quot;%d &quot;,n);  &#125;    return 0;&#125;\n\n\n\n3.求素数（2–100之间）\nvoid FindPrime()&#123;\tint i = 0; int j = 0;\tfor (i = 1; i &lt;= 100; i++)//这里可以直接+=2，因为偶数不可能是素数\t&#123;\t\tfor ( j = 2; j &lt;= i; j++)//还可以优化为sqrt（i）\t\t&#123;\t\t\tif (i % j == 0)//如果余数为0，则不是素数，结束循环\t\t\t\tbreak;\t\t&#125;\t\tif(i==j)//如果j一直加到和i相等，证明i是素数\t\t\tprintf(&quot;%d &quot;, i);\t&#125;&#125;int main()&#123;\tFindPrime();    return 0;&#125;\n\n4.冒泡排序：（排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序） - VisuAlgo）\n从键盘输入的10个整数按从小到大的顺序排序后输出\n#include&lt;stdio.h&gt;\tint main()&#123;\tint n[10] = &#123; 25,35,68,79,21,13,98,7,16,62 &#125;;//定义一个大小为10的数组\tint i, j, temp;\tfor (i = 1; i &lt;= 9; i++)//外层循环是比较的轮数，数组内有10个数，那么就应该比较10-1=9轮\t&#123;\t\tfor (j = 0; j &lt;= 9 - i; j++)//内层循环比较的是当前一轮的比较次数，例如：第一轮比较9-1=8次，第二轮比较9-2=7次\t\t&#123;\t\t\tif (n[j] &gt; n[j + 1])//相邻两个数如果逆序，则交换位置\t\t\t&#123;\t\t\t\ttemp = n[j];\t\t\t\tn[j] = n[j + 1];\t\t\t\tn[j + 1] = temp;\t\t\t&#125;\t\t&#125;\t&#125;\tprintf(&quot;排序过后的数顺序:\\n&quot;);\tfor (i = 0; i &lt; 10; i++)\tprintf(&quot;%d &quot;, n[i]);\tprintf(&quot;\\n&quot;);&#125;\n\n五.指针1.使用指针方法，计算两个数组中各元素对应位置的和，和的结果存入第三个数组中，然后输出。\n#include &lt;stdio.h&gt;//void count(int *p1,int *p2,int *p3,int x)&#123;\tint i;\tfor(i=0;i&lt;x;i++)\t&#123;\t\t*(p3+i) = (*(p1+i))+ (*(p2+i));\t&#125; \tprintf(&quot;两个数组对应各元素和分别为：\\n&quot;);\tfor(i=0;i&lt;x;i++)\t&#123;\t\tprintf(&quot;%d &quot;,p3[i]);\t&#125;&#125;int main()&#123;\tint arr01[4]=&#123;2,4,5,8&#125;;\tint arr02[4]=&#123;1,0,4,6&#125;;\tint arr03[4];\tcount(arr01,arr02,arr03,4);&#125; \n\n2.输出值为：at\n（二级）\n#include &lt;stdio.h&gt;int main()&#123;\tchar* a[] = &#123; &quot;work&quot;,&quot;at&quot;,&quot;alibaba&quot; &#125;;\tchar** pa = a;\tpa++;\tprintf(&quot;%s\\n&quot;, *pa);\treturn 0;&#125;\n\nchar* a[]为指针数组，是数组用来存放指针，该数组有三个元素，分别是三个字符串的地址。\npa &#x3D; a；是将数组a的首元素的地址放入二级指针变量pa中。\npa++：即为a++，从数组首元素的地址变为第二个元素的地址。\n*pa：此时pa为a[1]，也就是第二个元素表示字符串的首地址，以%s的形式输出，依次打印字符串。\n六.递归1.用递归的方法求正整数N的阶乘\n#include&lt;stdio.h&gt;long jiecheng(int n)&#123;  long p;  if(n==0||n==1)//0的阶乘为1    p=1;      else     p=n*jiecheng(n-1);  return p;&#125;int main()&#123;  int n;  scanf(&quot;%d&quot;,&amp;n);  printf(&quot;%d&quot;,jiecheng(n));  return 0;&#125;\n\n至此，面向考试的题就都讲完了,最后祝大家都能在考试中取得自己满意的成绩！\n","categories":["讲座"],"tags":["c语言"]},{"title":"wifi攻击","url":"/2022/12/14/%E5%A5%BD%E7%8E%A9%E7%9A%84wifi%E7%A0%B4%E8%A7%A3/","content":"参考文章：kali攻击wifi、破解wifi密码详细教程（二）_wifi攻击_萧何以笙的博客-CSDN博客\n记录一下好玩的wifi破解仅供学习研究，不要非法攻击！\n\n​    fluxion 进入对应目录下\n\n​     .&#x2F;fluxion.sh 进入程序\n\n先输入2来查找周围wifi\n\n\n\n4.接下来按3就是扫描所有频段的wifi\n5.扫描到目标wifi后就可以按ctrl+c停止扫描\n6.输入目标wifi前的序号\n\n7.接下来一路按推荐走就可以了\n8.开始抓握手包\n成功后显示这个：\n9.接着开始选择攻击方式\n创建一个钓鱼wifi\n10继续一路推荐\n需要注意的是SSL证书那里选第三项没有证书\n11.再选断开网络，选择一个语言，这个是指目标接收到信息的语言，选中文\n12.此时，会弹出6个窗口，观察右上角的\n\n这个时候，目标断开网络并且会连上我们创建的虚假同名wifi，并会进行网页劫持（DNS劫持），强制用户输入密码：\n\n等用户上钩就可以了。\n","categories":["网安"],"tags":["web"]},{"title":"数据结构","url":"/2022/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"线性表顺序表单链表数组模拟：\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int e[N], ne[N], head, idx;//对链表进行初始化void init() &#123;    head = -1;//最开始的时候，链表的头节点要指向-1，    //为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束    /*    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针    当它在初始化的时候指向-1，来表示链表里没有内容。    */    idx = 0;//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找    //第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下    //标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！    /*    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。    另外，我们遍历链表的时候也是这样，靠的是ne[]    */&#125;//将x插入到头节点上void int_to_head(int x) &#123;//和链表中间插入的区别就在于它有head头节点    e[idx] = x;//第一步，先将值放进去    ne[idx] = head;//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了    //先在只是做到了第一步，将元素x的指针指向了head原本指向的    head = idx;//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）    idx++;//指针向下移一位，为下一次插入元素做准备。&#125;//e[idx]=x;// ne[idx]=head;// head=idx;// idx++;//将x插入到下标为k的点的后面void add(int k, int x) &#123;    e[idx] = x;//先将元素插进去    e[idx]=x;ne[idx]=ne[k];ne[k]=idx;idx++;    ne[idx] = ne[k];//让元素x配套的指针，指向它要占位的元素的下一个位置    ne[k] = idx;//让原来元素的指针指向自己    idx++;//将idx向后挪&#125;//将下标是k的点后面的点个删掉void remove(int k) &#123;    ne[k] = ne[ne[k]];//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。&#125;//ne[k]=ne[ne[k]]//传进来的是k-1int main() &#123;    cin &gt;&gt; n;    init();//初始化    for (int i = 0; i &lt; n; i++)     &#123;        char s;        cin &gt;&gt; s;        if (s == &#x27;H&#x27;) &#123;            int x;            cin &gt;&gt; x;            int_to_head(x);        &#125;        if (s == &#x27;D&#x27;) &#123;            int k;            cin &gt;&gt; k;            if (k == 0) head = ne[head];//删除头节点            else remove(k - 1);//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1        &#125;        if (s == &#x27;I&#x27;) &#123;            int k, x;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);//同样的，第k个数，和下标不同，所以要减1        &#125;    &#125;    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;        return 0;&#125;\n\n\n\n双链表指针域存下一个和上一个的地址\n循环链表头指尾，尾指头呗\n静态链表使用静态链表存储数据，需要预先申请足够大的一整块内存空间，也就是说，静态链表存储数据元素的个数从其创建的那一刻就已经确定，后期无法更改。\n可以融合顺序表和链表各自的优点，从而 既能快速访问元素，又能快速增加或删除数据元素。\n栈先进后出\n应用：括号匹配\n表达式求值（中缀转后缀&#x2F;前缀）\n队列先进先出\n数组模拟：\n我觉得是一个双指针在维护这个数据结构吧先进的先出  后进的后出 tt就是维护队尾位置的下标 如果要队头出列的话 hh++就可以 遍历的时候i&lt;&#x3D;hh就可以了（输出时候队头开始遍历）\n#include&lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1e6 + 10;int qu[N], hh = 0, tt = -1;//初始化很重要！！！int main()&#123;    int n;    cin &gt;&gt; n;    while (n--)    &#123;        int x;        string a;        cin &gt;&gt; a;        if (a == &quot;push&quot;)            cin &gt;&gt; x, qu[++tt] = x;//元素只能队尾入队        else if (a == &quot;pop&quot;)            hh++;//注意元素只能队头弹出，且是 ++        else if (a == &quot;empty&quot;)//队内是否为空        &#123;            if (tt &lt; hh)                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else//查询队头            cout &lt;&lt; qu[hh] &lt;&lt; endl;    &#125;         for (int i = tt; i &lt;= hh; i++)    &#123;        printf(&quot;%d&quot;, qu[i]);    &#125;        return 0;&#125;\n\n双端队列两端都可以出和进\n循环队列圈圈\n应用：bfs\n字符串KMP算法匹配字符串的一种优化\n原始匹配方法缺点：当字串能够与主串部分匹配时，主串的扫描指针i会经常回溯，最坏时间复杂度为O(mn)\nkmp算法：当字串能够与主串部分匹配时，不再让主串的指令i回溯，而是让字串的j指针回溯到j&#x3D;next[j]的位置，算法平均时间复杂度O(m+n)\n那么关键就在于如何求解next数组了，手算的方法就是在该位置前的串的最长相等前后缀长度+1， 特别的 next[1]&#x3D;0  next[2]&#x3D;1\neg：ababaa   在j&#x3D;6时 ：最长前后缀aba  所以next[6]&#x3D;4;\n​\t\t\t\t\t   在j&#x3D;5时： 最长前后缀ab 所以 next[5]&#x3D;3;\n也可以看出如果匹配过程中很少出现可以部分匹配的情况，kmp算法和朴素匹配也差不多\n初始化：\ntypedef struct s &#123;\tchar ch[1024];\tint length;&#125;sstring;\n\nKMP算法：\nint KMP(sstring s, sstring t)&#123;\tint i = 1;\tint j = 1;\tint next[1024];\tGet_next(t, next);\twhile (i &lt;= s.length &amp;&amp; j &lt;= t.length)\t&#123;\t\tif (j == 0 || s.ch[i] == t.ch[j])\t\t&#123;\t\t\ti++;\t\t\tj++;\t\t&#125;\t\telse\t\t&#123;\t\t\tj = next[j];\t\t&#125;\t&#125;\tif (j &gt; t.length)\t&#123;\t\treturn i - t.length;\t&#125;\telse\t\treturn 0;&#125;\n\n求解next数组：（这有两个公式）\nvoid Get_next(sstring t,int next[])&#123;\tint i=1,j=0;\tnext[1] = 0;\twhile (i &lt; t.length)\t&#123;\t\tif (j == 0 || t.ch[i] == t.ch[j])\t\t&#123;\t\t\ti++;\t\t\tj++;\t\t\tnext[i] = j;\t\t&#125;\t\telse\t\t&#123;\t\t\tj = next[j];\t\t&#125;\t&#125;&#125;\n\n优化求解next：\nint nextval[1024];nextval[1]=0;for(int j=2;j&lt;t.length;j++)&#123;    if(t.ch[next[j]]==t.ch[j])    &#123;        nextval[j]=nextval[next[j]];    &#125;    else        nextval[j]=next[j];&#125;\n\neg：           a b a b a a \n序号j           1 2 3 4 5 6 \nnext:           0 1 1 2 3 4  \nnextval：    0 1 0 1 0 4     \n从第二个开始，b与其对应的next[2]&#x3D;1即a比较，不相同，那么保持不动；\n第三个a与其next[3]&#x3D;1即a比较，相同，那么将他的nextval改为前面的next的值，就是循环里的else\n以此类推\n树二叉树的存储顺序存储（满二叉树）从左到右，由上至下依次将结点存入一个顺序表中，（由1开始）有以下性质：\n左儿子：i*2；\n右儿子：i*2+1；\n父节点：i&#x2F;2；\nstruct TreeNode &#123;\tint value;\tbool isEmpty;&#125;;TreeNode t[100];for (int i = 0; i &lt; 100; i++)&#123;\tt[i].isEmpty = true;&#125;\n\n链式存储当一颗二叉树不是满二叉树时，如果继续顺序存储，那么他们的下标将变得无序，若是强制补全二叉树（完全二叉树）再来存，那么可能会浪费很多空间，所以采用链式存储的方式：\nstruct BiTNode&#123;    int value;    struct BiTNode* lchild;    struct BiTNode* rchild;&#125;;\n\n二叉树的遍历先序遍历根左右\nvoid Preorder(BiTree T)&#123;    if(T!=NULL)    &#123;        visit(T);        Preorder(T-&gt;lchild);//递归遍历左子树        Preorder(T-&gt;rchild);//递归遍历右子树    &#125;&#125;\n\n中序遍历左根右\n后序遍历左右根\n（这三种就是那三句的顺序变一下就ok）\n层序遍历一层一层遍历\n利用一个队列来实现，有种bfs的感觉\n线索二叉树存储\nstruct BiTNode&#123;    int value;    struct BiTNode* lchild;    struct BiTNode* rchild;    int ltag,rtag //tag==0 表示指向儿子 ==1 表示指向线索&#125;;\n\n二叉排序树左子树结点值&lt;根结点值&lt;右子树结点值\n在二叉排序树上寻找值为key的结点 \nBSTNode* BST_Searchh(BSTree T,int k)&#123;    while(k!=NULL &amp;&amp; k!=T-&gt;key)    &#123;        if(k&lt;T-&gt;key)   T=T-&gt;lchild;        else   T=T-&gt;rchild;    &#125;    return T;&#125;\n\n平衡二叉树（AVL树）任意节点的子树的高度差都小于等于 1\n用于解决二叉排序树高度不确定的情况，如果二叉排序树的子树间的高度相差太大，就会让二叉排序树操作的时间复杂度升级为O(n)，为了避免这一情况，为最坏的情况做准备，就出现了平衡二叉树，使树的高度尽可能的小，其本质还是一棵二叉搜索树。\n哈夫曼树路径：指从根结点到该结点的分支序列。路径长度：指根结点到该结点所经过的分支数目。结点的带权路径长度：从树根到某一结点的路径长度与该结点的权的乘积。树的带权路径长度(WPL)：树中从根到所有叶子结点的各个带权路径长度之和。\n哈夫曼树是由 n 个带权叶子结点构成的所有二叉树中带权路径长度最短的二叉树，又称最优二叉树。\n构造方法：每次找最小的两个权值先组成一棵树，这颗树的权值就是两棵树权值的和。循环这个过程。\n\n哈夫曼编码是一种可变长编码（ VLC）方式，比起定长编码的 ASCII 编码来说，哈夫曼编码能节省很多的空间，因为每一个字符出现的频率不是一致的。\n出现频率为权值，编码方式就是上面构造哈夫曼树的方式，可以使WPL最小（电报）\n普通树普通树存储双亲表示法（顺序存储）每个结点的指针指向父亲结点\n优点：找父节点方便\n缺点：找儿子结点不方便\n孩子表示法（顺序＋链式存储）每个结点的指针指向儿子结点\n优点：找儿子节点方便\n缺点：找父节点不方便\n孩子兄弟表示法（链式存储）两个指针分别存左孩子和（左孩子的）右兄弟的指针 \n应用：树和二叉树的相互转换 ；森林和二叉树的相互转换\n普通树的遍历原理就是二叉树那样遍历的 ，没有了中序遍历，还剩三种\n森林遍历先序遍历等效于依次对子树进行先序遍历\n中序遍历等效于依次对子树进行后序遍历   注意是后序\n图概念有向图无向图简单图不存在重边，不存在顶点到自身的边\n多重图某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联\n多重图的定义和简单图是相对的\n完全图（也称简单完全图）对于无向图：有n ( n − 1 ) &#x2F; 2 条边的无向图称为完全图，即每两个点间均有边的图\n对于有向图：有n ( n − 1 ) 条弧的有向图称为有向完全图，即在有向完全图中任意两个顶点之间都存在方向相反的两条弧\n连通图无向图中：若图中任意两个顶点都是连通的，则称图为连通图，否则称为非连通图。\n连通分量无向图中的极大连通子图称为连通分量。\n极大连通子图：子图必须连通，并且包含尽可能多的顶点和边\n若一个图有n 个顶点，并且边数小于n − 1，则此图必是非连通图。\n强连通图有向图中：若从顶点v 到顶点w和从顶点w到顶点v之间都有路径,则称这两个顶点是强连通的\n强连通分量有向图中的极大强连通子图称为有向图的强连通分量\n生成树连通图的生成树是包含图中全部顶点的一个极小连通子图。（边要尽可能少，并要保持连通）\nn个顶点n-1条边\n生成森林在非连通图中，连通分量的生成树构成了非连通图的生成森林\n稀疏图 稠密图边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。\n顶点的度 入度 出度图中每个顶点的度定义为以该项点为一个端点的边的数目\n无向图中：顶点的度就是该顶点上边的数量\n有向图中：顶点的度分为入度和出度，入度：指向该顶点的有向边；出度：该顶点指别人的有向边。该点的度为入度和出度的和\n图的存储邻接矩阵图的邻接矩阵(Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息\n\n适用于稠密图\n邻接表指对图G中的每个顶点v 建立一个单链表，第i个单链表中的结点表示依附于顶点vi 的边(对于有向图则是以顶点vi为尾的弧)，这个单链表就称为顶点vi 的边表(对于有向图则称为出边表)。边表的头指针和顶点的数据信息采用顺序存储(称为顶点表）\n例：\n\n\n适用于稀疏图\n十字链表（存储有向图）邻接多重表（存储无向图）搜索DFS一条路走到黑，不能走就回溯\nBFS类似于层序遍历，利用一个队列来实现。\n在DFS中关键点是递归以及回溯，在BFS中，关键点则是状态的选取和标记\n搜索比较简单，例题在算法模块有，不细写了\n最小生成树Prim初始时从图中任取一顶点，如顶点加入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边。\n通俗点说就是：从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复“找最短的边并添加”的操作\nKruskal与Prim算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。\n初始时为只有n个顶点而无边的非连通图，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入T，否则舍弃此边而选择下一条权值最小的边。以此类推，直至T中所有顶点都在一个连通分量上。\n最短路径BFS算法适用于无权图的单源最短路径\n就是简单的搜索一遍，搜的过程中可以用一个path数组存路径\nDijkstra算法适用于无负权图\nDijkstra算法是解决单源最短路径问题的贪心算法它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径直到求出从源点到其他各个顶点的最短路径。\nFloyd算法适用于无负权环图\nFloyd算法核心利用动态规划，核心就是关于中转点的引入是否会引起最短路径变化\n//核心部分     //k为中间点     for(k = 0; k &lt; n; k++)//中间点    &#123;        for(v = 0 ; v &lt; n; v++)//邻接矩阵的行列遍历        &#123;            for(w =0; w &lt; n; w++)            &#123;                if(D[v][w] &gt; (D[v][k] + D[k][w]))                &#123;                    D[v][w] = D[v][k] + D[k][w];//更新最小路径                     P[v][w] = P[v][k];//更新最小路径中间顶点                 &#125;            &#125;        &#125;    &#125;\n\n拓扑排序适用于有向无环图，也可以判断一个图是否为有向无环图\nAOV网：用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网，简称AOV网\nbool TopologicalSort(Graph G)&#123;    InitStack(S);//初始化栈，存储入度为0的顶点    for(int i=0;i&lt;G.vexnum;i++)    &#123;        if(indegree[i]==0)            Push(S,i);//将所有入度为0的顶点入栈    &#125;    int cnt=0;//记录已经输出的顶点数    while(!IsEmpty(S))    &#123;        Pop(S,i);//栈顶出栈        print[cnt++]=i;        for(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)//将所有i指向的顶点入度减1，并将所有入度减为0的顶点压入栈        &#123;            v=p-&gt;adjvex;            if(!(--indegree[v])               Push(S,v);//入度为0，则入栈        &#125;    &#125;    if(cnt&lt;G.vexnum)               return false;//排序失败，有回路    else               return true;//成功               &#125;\n\n\n\n查找顺序查找额，没啥说的\n二分查找有序序列\n#include &lt;iostream&gt;using namespace std;int main()&#123;\tint n, num[105], targe;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tcin &gt;&gt; num[i];\t&#125;\tcin &gt;&gt; targe;\tint l = 0, r = n - 1;\twhile (l &lt;= r)\t&#123;\t\tint mid = (l + r) &gt;&gt; 1;\t\tif (num[mid] == targe)\t\t&#123;\t\t\tcout &lt;&lt; targe &lt;&lt; &quot;in index&quot; &lt;&lt; mid &lt;&lt; endl;\t\t\treturn 0;\t\t&#125;\t\tif (num[mid] &lt; targe)\t\t&#123;\t\t\tr = mid - 1;\t\t&#125;\t\telse\t\t&#123;\t\t\tl = mid + 1;\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;no&quot; &lt;&lt; endl;\treturn 0;&#125;\n\n分块查找对数据进行分块处理，每一块对应一个索引，实现块内无序，块间有序。\n在查找的时候，可以先用二分来找目标元素所对应的块间，再找块间对应的块内元素。\nB树B树和AVL树(平衡二叉树) 的差别就是 B树 属于多叉树，又名平衡多路查找树，即一个结点的查找路径不止左、右两个，而是有多个。\nB+树B+树内部有两种结点，一种是索引结点，一种是叶子结点。B+树的索引结点并不会保存记录，只用于索引，所有的数据都保存在B+树的叶子结点中。而B树则是所有结点都会保存数据。B+树的叶子结点都会被连成一条链表。叶子本身按索引值的大小从小到大进行排序。即这条链表是 从小到大的。多了条链表方便范围查找数据。B树的所有索引值是不会重复的，而B+树 非叶子结点的索引值 最终一定会全部出现在 叶子结点中\n散列表查找（哈希表）对于冲突，有两种方法，一种是拉链法，另一种是开放定址法，其中开放定址法又分为三种：线性探测法，平方探测法，伪随机序列法。\n理论上哈希值设置的越大，查找效率就是o（1），是一种以空间换时间的查找\n排序稳定性相同关键字在排序后相对位置保持不变为稳定的，反之不稳定\n稳定排序：插入、冒泡、基数、归并\n不稳定排序：希尔、选择、快排、堆\n插入排序void InsertSort(int A[],int n)&#123;    int i,j,tmp;    for(int i=1;i&lt;n;i++)    &#123;        if(A[i]&lt;A[i-1])  //如果这个数比前面的数小        &#123;            tmp=A[i];//暂存这个值            for(j=i-1;j&gt;=0&amp;&amp;A[j]&gt;tmp;j--)//把前面大于该数的值依次往后移            &#123;                A[j+1]=A[j];            &#125;            A[j+1]=tmp;//把这个值插进去        &#125;    &#125;&#125;\n\n有一个优化就是找该值插入的位置可以用二分，因为前面都是有序的\n冒泡排序不说了\n基数排序是一种非比较的算法\n例：原始数据：520 211 438 888 007 111 985 666 996 233 168\n创建十个队列（0-9）\n先按个位依次存入各个数据（分配）\n收集：438 888 168 007 666 996 985 233 211 111 520  （个位由大到小）\n再按十位进行分配和收集：996 888 985168 666 438 233  520 211 111 007 （十位由大到小，并且十位相同的，个位大的在前）\n再按百位进行分配和收集：996 985 888 666 520 438 233 211 168 111 007 （排序完成）\n归并排序#include &lt;iostream&gt;using namespace std;const int N = 100010;int B[N];int A[N]=&#123;5,4,7,2,1,6,8,3,9,10&#125;;void Merge(int A[], int low, int mid, int high)&#123;\tint i, j, k;\tfor (k = low; k &lt;= high; k++)\t&#123;\t\tB[k] = A[k];//B数组是一个tmp，先把A数组此时元素对应的拷贝一份\t&#125;\tfor (i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++)//注意i,j,k三个指针\t&#123;\t\tif (B[i] &lt;= B[j]) A[k] = B[i++];\t\telse  A[k] = B[j++];\t&#125;\twhile (i &lt;= mid) A[k++] = B[i++];//剩下的直接放进去\twhile (j &lt;= high) A[k++] = B[j++];&#125;void MergeSort(int A[], int low, int high)&#123;\tif (low &lt; high)\t&#123;\t\tint mid = (low + high) &gt;&gt; 1;\t\tMergeSort(A, low, mid);//递归处理左右两边，直到只剩一个元素\t\tMergeSort(A, mid + 1, high);\t\tMerge(A, low, mid, high);//归并\t&#125;&#125;int main(void)&#123;\tMergeSort(A, 0, 9);\t\treturn 0;&#125;\n\n希尔排序分组加插入排序的循环，循环过程是归并递归的思路…..\n#include &lt;iostream&gt;using namespace std;void ShellSort(int* arr, int n)&#123;\tint d = n;\twhile (d &gt; 1)\t&#123;\t\t//每次对d折半操作\t\td = d / 2;\t\t//单趟排序\t\tfor (int i = 0; i &lt; n - d; ++i)\t\t&#123;\t\t\tint end = i;\t\t\tint tem = arr[end + d];\t\t\twhile (end &gt;= 0)\t\t\t&#123;\t\t\t\tif (tem &lt; arr[end])\t\t\t\t&#123;\t\t\t\t\tarr[end + d] = arr[end];\t\t\t\t\tend -= d;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\t\t\tarr[end + d] = tem;\t\t&#125;\t&#125;&#125;int main()&#123;\tint A[10] = &#123; 4,5,6,7,8,9,0,1,2,3 &#125;;\tShellSort(A, 10);\treturn 0;&#125;\n\n\n\n快速排序一种分治的思想\n#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n, i, j;int q[N];void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return;\tint x = q[(l+r)/2]; //随意选择一个基准元素    i = l - 1;     j = r + 1;while (i&lt;j)&#123;\tdo i++; while (q[i] &lt; x);\tdo j--; while (q[j] &gt; x);\tif (i&lt;j) swap(q[i], q[j]);&#125;quick_sort(q, l, j);//递归处理左边quick_sort(q, j + 1, r);//递归处理右边&#125;int main()&#123;\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;q[i]);\t&#125;\tquick_sort(q, 0, n - 1);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tprintf(&quot;%d&quot;, q[i]);\t&#125;\treturn 0;&#125;\n\n简单选择排序真的很简单呐\n每一趟在待排序元素中选取关键字最小的加入有序序列\nvoid SelectSort(int A[],int n)&#123;    for(int i=0;i&lt;n-1;i++)    &#123;        int min=i;        for(int j+1;j&lt;n;j++)//找最小元素        &#123;            if(A[j]&lt;A[min]) min=j;        &#125;        if(min!=i) swap(A[i],A[min]);    &#125;&#125;\n\n堆排序选择排序的一种\n先将初始序列变为大根堆的存储，再进行排序并维持这个堆：\nvoid BuildMaxHeap(int A[],int len)&#123;    for(int i=len/2;i&gt;0;i--)//（len/2）前的所有元素，也就是非叶结点        HeadAdjust(A,i,len);&#125;void HeadAdjust(int A[];int k;int len)&#123;    A[0]=A[k];    for(int i=2*k;i&lt;=len;i*=2)//初始化就是指向左孩子  如果循环的话，就是不断指向孩子的孩子，效果是小元素的不断下沉    &#123;        if(i&lt;len&amp;&amp;A[i]&lt;A[i+1]) //i&lt;len才有右孩子 取较大的孩子            i++;        if(A[0]&gt;=A[i]) break;//满足根&gt;=孩子        else&#123;            A[k]=A[i];//更新根             k=i;//进入下一轮筛选循环        &#125;    &#125;    A[k]=A[0];&#125;//堆排序void HeapSort(int A[],int len)&#123;    BuildMaxHeap(A,len);//初始化为大根堆    for(int i=len;i&gt;1;i--)//n-1趟交换和建堆的过程    &#123;        swap(A[i],A[1]);//A[1]为每次的最大元素        HeadAdjust(A,1,i-1);//交换完A[1]就是原来的堆底，继续下沉建立新堆    &#125;&#125;\n\n","categories":["数据结构与算法"],"tags":["基础"]},{"title":"JavaScript","url":"/2022/11/24/JavaScript/","content":"本来是想着看视频学的，发现都是大概学过的东西，只是换一种表达方式，看视频学速度太慢，所以就跟着csdn上的教程学了，只记录了自己认为比较重要的东西，还有一些原本就学过的也没有记录，并不是完整的笔记，参考文章：(30条消息) 学习JavaScript这一篇就够了_轻松的小希的博客-CSDN博客\nJavaScript简介组成\n特点解释型语言\nJavaScript是一门解释型语言，所谓解释型值语言是指不需要被编译为机器码在执行，而是直接执行。由于少了编译这一步骤，所以解释型语言开发起来尤为轻松，但是解释型语言运行较慢也是它的劣势。不过解释型语言中使用了JIT技术，使得运行速度得以改善。\n动态语言\nJavaScript是一门动态语言，所谓的动态语言可以暂时理解为在语言中的一切内容都是不确定的。比如一个变量，这一时刻是个整型，下一时刻可能会变成字符串了。当然这个问题我们以后再谈。不过在补充一句动态语言相比静态语言性能上要差一些，不过由于JavaScript中应用的JIT技术，所以JavaScript可能是运行速度最快的动态语言了。\n类似于 C 和 Java 的语法结构\nJavaScript的语法结构与C和Java很像，向for、if、while等语句和Java的基本上是一模一样的。所以有过C和Java基础的同学学习起来会轻松很多。不过JavaScript和与Java的关系也仅仅是看起来像而已。\n引用方式有三种引用方式，最常用的还是单独写一个js文件，再引过来\n&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;\n\n输出页面输出&lt;script&gt;    document.write(&quot;Hello,World!&quot;);&lt;/script&gt;\n\n控制台输出按F12弹出控制台\n&lt;script&gt;    console.log(&quot;输出一条日志&quot;);//最常用    console.info(&quot;输出一条信息&quot;);    console.warn(&quot;输出一条警告&quot;);    console.error(&quot;输出一条错误&quot;);&lt;/script&gt;\n\n\n弹出窗口输出alert(&quot;Hello,World!&quot;);\n\n注释&#x2F;&#x2F;和&#x2F;*  *&#x2F;\nJavaScrpit基础语法变量的声明var a;//声明a=123;//赋值var a = 123;//同时进行\n\n数据类型JavaScript中一共有5种基本数据类型：\n\n字符串型（String）\n数值型（Number）\n布尔型（Boolean）\nundefined型（Undefined）\nnull型（Null）\n\n这5种之外的类型都称为Object，所以总的来看JavaScript中共有六种数据类型。\nUndefinedUndefined 类型只有一个值，即特殊的 undefined。\n在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。\n注意：使用typeof对没有初始化和没有声明的变量，会返回“undefined”。\nNullNull 类型是第二个只有一个值的数据类型，这个特殊的值是 null。\nundefined值实际上是由null值衍生出来的，所以如果比较undefined和null是否相等，会返回true。\n注意：从语义上看null表示的是一个空的对象，所以使用typeof检查null会返回一个Object。\n其他类型不再赘诉\n强制类型转换转换成string类型将其它数值转换为字符串有三种方式：toString()、String()、 拼串。\n方式一：调用被转换数据类型的toString()方法，该方法不会影响到原变量，它会将转换的结果返回，但是注意：null和undefined这两个值没有toString()方法，如果调用它们的方法，会报错。\nvar a = 123;a = a.toString();console.log(a);//123console.log(typeof a);//string\n\n方式二：调用String()函数，并将被转换的数据作为参数传递给函数，使用String()函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString()方法，但是对于null和undefined，就不会调用toString()方法，它会将 null 直接转换为 “null”，将 undefined 直接转换为 “undefined”。\nvar a = 123;a = String(a);console.log(a);//123console.log(typeof a);//string var b = undefined;b = String(b);console.log(b);//undefineconsole.log(typeof b);//stringvar c = null;c = String(c);console.log(c);//nullconsole.log(typeof c);//string\n\n方式三：为任意的数据类型 +&quot;&quot;\nvar a = 123;a = a + &quot;&quot;;console.log(a);//123console.log(typeof a);//string\n\n转换为number类型方式一：使用Number()函数\n字符串 –&gt; 数字\n纯数字的字符串可直接转换为数字，空串或全是空格的字符串转换为0\n如果有非数字内容，转化为NaN（not a number)\n布尔 –&gt; 数字true 转成 1false 转成 0null –&gt; 数字null 转成 0undefined –&gt; 数字undefined 转成 NaN\n方式二：这种方式专门用来对付字符串，parseInt() 把一个字符串转换为一个整数\nvar a = &quot;123&quot;;a = parseInt(a);console.log(a);//123console.log(typeof a);//number\n\n方式三：这种方式专门用来对付字符串，parseFloat() 把一个字符串转换为一个浮点数\nvar a = &quot;123.456&quot;;a = parseInt(a);console.log(a);//123console.log(typeof a);//number\n\n转换为Boolean类型\n使用Boolean()函数\n数字 —&gt; 布尔\n除了0和NaN，其余的都是true\n\n\n字符串 —&gt; 布尔\n除了空串，其余的都是true\n\n\nnull和undefined都会转换为false\n对象也会转换为true\n\n\n\n运算符&#x3D;&#x3D; ： 如果两个变量的类型不同，会自动进行类型转换，类型相同再比较\n&#x3D;&#x3D;&#x3D;：如果两个变量的类型不同，不会自动进行类型转换，类型不同直接返回false\n同理：！&#x3D; 和  ！&#x3D;&#x3D;\n数组创建\nvar arr = [12,&#x27;haha&#x27;];\n\n遍历\nfor (var i = 0; i &lt; arr.length; i++) &#123;    console.log(arr[i]);&#125;\n\npush()方法演示：该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度\nvar arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];var result = arr.push(&quot;唐僧&quot;, &quot;蜘蛛精&quot;, &quot;白骨精&quot;, &quot;玉兔精&quot;);console.log(arr);//[&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;，&quot;唐僧&quot;, &quot;蜘蛛精&quot;, &quot;白骨精&quot;, &quot;玉兔精&quot;]console.log(result);//7\n\npop()方法演示：该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回\nvar arr = [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;];var result = arr.pop();console.log(arr);// [&quot;孙悟空&quot;, &quot;猪八戒&quot;]console.log(result);//沙和尚\n\n还有好多方法，不再列举\n函数function 函数名(形参1，形参2，...)&#123;\t//函数体&#125;//调用：函数名(实参1,实参2,...)\n\n匿名函数：没有名字的函数就是匿名函数，它可以让一个变量来接收，也就是用 “函数表达式” 方式创建和接收。\nvar fun = function () &#123;    alert(&quot;我是一个匿名函数&quot;);&#125;fun();\n\n函数方法也有好多，这里先不写了\n预解析js引擎运行js分为两步：预解析  代码执行\n预解析：js引擎会把js里的所有var 和function声明提升到当前作用域的最前面。\n分为：变量预解析（变量提升）和函数预解析（函数提升）\n变量提升：把所有变量声明提升到当前作用域最前面，不提升赋值操作\n函数提升：把所有函数声明提升到当前作用域最前面，不调用函数\n代码执行：按照代码顺序从上到下执行。\neg：\nconsole.log(num);var num=10;//结果是undefine//相当于执行了以下代码var num;console.log(num);num=10;\n\nvar num=10;fun();function fun()&#123;    console.log(num);    var num=20;&#125;//执行结果是：undefine//相当于执行以下代码var num;function fun()&#123;    var num;    console.log(num);//根据作用域链，这个undefine指的是函数里的这个num    num=20;&#125;fun();\n\n对象Object类型，我们也称为一个对象，是JavaScript中的引用数据类型。它是一种复合值，它将很多值聚合到一起，可以通过名字访问这些值。对象也可以看做是属性的无序集合，每个属性都是一个名&#x2F;值对。对象除了可以创建自有属性，还可以通过从一个名为原型的对象那里继承属性。除了字符串、数字、true、false、null和undefined之外，JavaScript中的值都是对象。\n创建对象var person = new Object();person.name = &quot;孙悟空&quot;;person.age = 18;console.log(person);//或：var person = &#123;    name: &quot;孙悟空&quot;,    age: 18&#125;;console.log(person);\n\n访问方式对象.属性名对象[‘属性名’]\n\n删除属性delete 对象.属性名\n\n遍历对象枚举遍历对象中的属性，可以使用for … in语句循环，对象中有几个属性，循环体就会执行几次\nvar person = &#123;    name: &quot;zhangsan&quot;,    age: 18&#125;for (var personKey in person) &#123;    var personVal = person[personKey];    console.log(personKey + &quot;:&quot; + personVal);&#125;\n\nDOM","categories":["开发"],"tags":["前端"]},{"title":"操作系统","url":"/2023/02/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"本文参考https://www.bilibili.com/video/BV1YE411D7nH/?spm_id_from=333.337.search-card.all.click\n(49条消息) 操作系统笔记（含王道计算机考研——操作系统课件）_一只不吃老鼠的猫的博客-CSDN博客\n一.概述操作系统的基本概念操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机地工作和资源地分配，以提供给用户和其他软件方便地接口和环境，它是计算机系统中最基本的系统软件。\n功能\n作为系统资源的管理者\n作为用户和计算机硬件之间的接口\n作为最接近硬件的层次\n\n操作系统的特征\n并发\n\n并发是指两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，在微观上是交替发生的。\n易混淆的概念——并行：两个或多个事件在同一时刻同时发生\n\n共享\n\n共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。\n所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)\n\n虚拟\n\n虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。\n\n异步\n\n异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。\n并发性和共享性互为存在条件： \n\n如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义\n如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发\n\n中断和异常（内中断和外中断、中断处理过程）中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。\n\n当中断发生时，CPU立即进入核心态\n当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。\n对于不同的中断信号，会进行不同的处理。\n有了中断，才能实现多道程序并发执行。\n“用户态→核心态”是通过中断实现的，并且中断是唯一途径。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。\n\n\n系统调用含义“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。\n作用应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I&#x2F;o操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。\n系统调用和库函数的区别编程语言（c,java）中里边有很多库函数，其实它们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。\n其他系统调用发生在用户态，对系统调用的处理发生在核心态。执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进入核心态。\n二.进程管理进程的定义，组成，组织方式，特征程序： 就是指令序列\n引入多道程序（CPU可以并发执行多个程序）之后，为了方便操作系统进行管理，引入了进程，进程实体的概念。\nPCB，程序段，数据段三部分构成了进程实体（也叫作进程映像）。一般情况下，我们把进程实体简称为进程。\n例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB.\nPCB是进程存在的唯一标识。\n进程的组织方式在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。注: 进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。\n相当于java中的链表和数组。\n进程的特征\n进程的状态和转换\n进程是程序的一次执行。在这个过程中，进程的状态会有各种变化。为了方便各个进程的管理，操作系统将进程划分为几个状态。\n\n\n转换:\n\n进程控制进程控制由原语实现。所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。\n原语采用 “关中断指令” 和 “开中断指令” 来实现。 注意： 原语运行在核心态。\n\n那么原语是如何实现进程状态的转换呢？\n更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)a.所有的进程控制原语一定都会修改进程状态标志b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境c.某进程开始运行前必然要恢复期运行环境将PCB插入合适的队列分配&#x2F;回收资源具体实现如图所示：\n进程通信进程通信就是进程之间的信息交换。\n为了保证安全，一个进程不能直接访问另一个进程的地址空间。\n操作系统提供了三种方法：共享存储，消息传递，管道通信。\n共享存储\n2.管道通信1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。2.各进程要互斥地访问管道。3.数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。4.如果没写满，就不允许读。如果没读空，就不允许写。5．数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。\n\n消息传递进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息” 两个原语进行数据交换。\n类似于Http协议。\n\n线程概念和多线程模型概念有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能串行执行一系列程序。因此，引入“线程”，来增加并发度。\n\n可以把线程理解为轻量级的进程。\n\n线程是一个基本的CPU执行单元，也是程序执行流的最小单位。\n\n引入线程后，进程作为除CPU之外的系统资源的分配单元。\n\n\n\n线程分类用户级线程\n\n用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换)\n用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。\n在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)\n可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。\n\n内核级线程\n\n内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。\n可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。\n\n操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。\n多线程模型多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。\n\n优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高\n缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行\n\n一对一模型:一个用户级线程映射到一个内核级线程。\n\n优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。\n缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。\n\n多对多模型:n用户级线程映射到m个内核级线程(n &gt;&#x3D;m)。每个用户进程对应m个内核级线程。\n\n克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。\n\n处理机调度的概念和层次在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。\n处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。\n调度分为三个层次，分别为高级调度，中级调度，初级调度。\n高级调度\n\n由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。\n高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。\n高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。\n\n中级调度\n\n引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。\n暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。\n中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。\n一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。\n\n低级调度\n\n低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。\n进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。\n进程调度的频率很高，一般几十毫秒一次。\n\n\n","categories":["网安"],"tags":["基础"]},{"title":"ctf解题积累","url":"/2022/11/24/ctf%E8%A7%A3%E9%A2%98%E5%BF%83%E5%BE%97/","content":"不常见加密javascript加密：（jsfuck）\n形式：\n[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()最近又见了一种形式：-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~[]\n\n解密方式：浏览器控制台输入即可，或者也有专门的解密网站\nIDA手册IDA里改花指令或者动调改一些汇编代码值：edit-&gt;patch program-&gt;assemble\nIDA快捷键：h：16进制转10进制\nIDA附加动调题目：[INSHack2017]secure-garden-shed-v1\n这个题目给了两个附件，一个elf文件，一个存放数据的文件，elf文件不能单独运行，在linux里需要：\n./sgs-exec-release lock.sgsc\n\n单独一个文件可以使用远程linux动调的方式，那两个的话需要先运行程序，再附加到ida里，方法如下：\n先在Linux里运行该程序，并且运行linux_server（64），再空白打开ida，debugger下与linux建立连接，成功后它会自动跳出linux下的各个进程，选择目标程序的进程附加上去即可动调了\nz3在bin&#x2F;python目录下shift右键powshell进入\n变量有三种类型，整形，实型，向量\n其中向量类型（BitVec）才可以进行异或之类的操作，并且定义时需要表明字节数\neg：\nfrom z3 import*v1 = BitVec(&#x27;v1&#x27;,8)v2 =  BitVec(&#x27;v2&#x27;,8)v3 = BitVec(&#x27;v3&#x27;,8)v4 =  BitVec(&#x27;v4&#x27;,8)v5 =  BitVec(&#x27;v5&#x27;,8)v6 =  BitVec(&#x27;v6&#x27;,8)v7 =  BitVec(&#x27;v7&#x27;,8)v8 =  BitVec(&#x27;v8&#x27;,8)v9 =  BitVec(&#x27;v9&#x27;,8)v10=  BitVec (&#x27;v10&#x27;,8)v11 =  BitVec(&#x27;v11&#x27;,8)v12 =  BitVec(&#x27;v12&#x27;,8)v13 =  BitVec(&#x27;v13&#x27;,8)v14 =  BitVec(&#x27;v14&#x27;,8)v15 =  BitVec(&#x27;v15&#x27;,8)v16 =  BitVec(&#x27;v16&#x27;,8)v17 =  BitVec(&#x27;v17&#x27;,8)v18 =  BitVec(&#x27;v18&#x27;,8)v19 =  BitVec(&#x27;v19&#x27;,8)v20=   BitVec(&#x27;v20&#x27;,8)v21 =  BitVec(&#x27;v21&#x27;,8)v22 =  BitVec(&#x27;v22&#x27;,8)v23 =  BitVec(&#x27;v23&#x27;,8)v24 =  BitVec(&#x27;v24&#x27;,8)v25 =  BitVec(&#x27;v25&#x27;,8)v26 =  BitVec(&#x27;v26&#x27;,8)v27 =  BitVec(&#x27;v27&#x27;,8)v28 =  BitVec(&#x27;v28&#x27;,8)v29 =  BitVec(&#x27;v29&#x27;,8)v30=   BitVec(&#x27;v30&#x27;,8)v31 =  BitVec(&#x27;v31&#x27;,8)v32 =  BitVec(&#x27;v32&#x27;,8)v33 =  BitVec(&#x27;v33&#x27;,8)v34 =  BitVec(&#x27;v34&#x27;,8)v35 =  BitVec(&#x27;v35&#x27;,8)v36 =  BitVec(&#x27;v36&#x27;,8)v37 =  BitVec(&#x27;v37&#x27;,8)v38 =  BitVec(&#x27;v38&#x27;,8)v39 =  BitVec(&#x27;v39&#x27;,8)v40=   BitVec(&#x27;v40&#x27;,8)v41 =  BitVec(&#x27;v41&#x27;,8)v42 =  BitVec(&#x27;v42&#x27;,8)v43 =  BitVec(&#x27;v43&#x27;,8)v44 =  BitVec(&#x27;v44&#x27;,8)s = Solver()s.add((( v34 ^  v23 * 7 ^ ~ v36 + 13) &amp; 255) == 182)s.add((( v37 ^  v10 * 7 ^ ~ v21 + 13) &amp; 255) == 223)s.add((( v24 ^  v23 * 7 ^ ~ v19 + 13) &amp; 255) == 205)s.add((( v25 ^  v13 * 7 ^ ~ v23 + 13) &amp; 255) == 144)s.add((( v6 ^  v27 * 7 ^ ~ v25 + 13) &amp; 255) == 138)s.add((( v4 ^  v32 * 7 ^ ~ v22 + 13) &amp; 255) == 227)s.add((( v25 ^  v19 * 7 ^ ~ v1 + 13) &amp; 255) == 107)s.add((( v22 ^  v7 * 7 ^ ~ v29 + 13) &amp; 255) == 85)s.add((( v15 ^  v10 * 7 ^ ~ v20 + 13) &amp; 255) == 188)s.add((( v29 ^  v16 * 7 ^ ~ v12 + 13) &amp; 255) == 88)s.add((( v35 ^  v4 * 7 ^ ~ v33 + 13) &amp; 255) == 84)s.add((( v36 ^  v2 * 7 ^ ~ v4 + 13) &amp; 255) == 103 )s.add((( v26 ^  v3 * 7 ^ ~ v1 + 13) &amp; 255) == 216)s.add((( v12 ^  v6 * 7 ^ ~ v18 + 13) &amp; 255) == 165)s.add((( v12 ^  v28 * 7 ^ ~ v36 + 13) &amp; 255) == 151)s.add((( v20 ^  v0 * 7 ^ ~ v21 + 13) &amp; 255) == 101)s.add((( v27 ^  v36 * 7 ^ ~ v14 + 13) &amp; 255) == 248)s.add((( v35 ^  v2 * 7 ^ ~ v19 + 13) &amp; 255) == 44)s.add(((v13 ^  v11 * 7 ^ ~ v33 + 13) &amp; 255) == 242)s.add((( v33 ^  v11 * 7 ^ ~ v3 + 13) &amp; 255) == 235  )s.add((( v31 ^  v37 * 7 ^ ~ v29 + 13) &amp; 255) == 248)s.add((( v1 ^  v33 * 7 ^ ~ v31 + 13) &amp; 255) == 33)s.add(((v34 ^  v22 * 7 ^ ~ v35 + 13) &amp; 255) == 84)s.add((( v36 ^  v16 * 7 ^ ~ v4 + 13) &amp; 255) == 75   )s.add((( v8 ^  v3 * 7 ^ ~ v10 + 13) &amp; 255) == 214)s.add((( v20 ^  v5 * 7 ^ ~ v12 + 13) &amp; 255) == 193)s.add((( v28 ^  v34 * 7 ^ ~ v16 + 13) &amp; 255) == 210)s.add((( v3 ^  v35 * 7 ^ ~ v9 + 13) &amp; 255) == 205)s.add((( v27 ^  v22 * 7 ^ ~ v2 + 13) &amp; 255) == 46)s.add((( v27 ^  v18 * 7 ^ ~ v9 + 13) &amp; 255) == 54)s.add((( v3 ^  v29 * 7 ^ ~ v22 + 13) &amp; 255) == 32)s.add((( v24 ^  v4 * 7 ^ ~ v13 + 13) &amp; 255) == 99)s.add((( v22 ^  v16 * 7 ^ ~ v13 + 13) &amp; 255) == 108)s.add((( v12 ^  v8 * 7 ^ ~ v30 + 13) &amp; 255) == 117)s.add((( v25 ^  v27 * 7 ^ ~ v35 + 13) &amp; 255) == 146)s.add((( v16 ^  v10 * 7 ^ ~ v14 + 13) &amp; 255) == 250)s.add((( v21 ^  v25 * 7 ^ ~ v12 + 13) &amp; 255) == 195)s.add((( v26 ^  v10 * 7 ^ ~ v30 + 13) &amp; 255) == 203)s.add((( v20 ^  v2 * 7 ^ ~ v1 + 13) &amp; 255) == 47)s.add((( v34 ^  v12 * 7 ^ ~ v27 + 13) &amp; 255) == 121)s.add((( v19 ^  v34 * 7 ^ ~ v20 + 13) &amp; 255) == 246)s.add((( v25 ^  v22 * 7 ^ ~ v14 + 13) &amp; 255) == 61)s.add((( v19 ^  v28 * 7 ^ ~ v37 + 13) &amp; 255) == 189)s.add((( v24 ^  v9 * 7 ^ ~ v17 + 13) &amp; 255) == 185)print(s.check())print(s.model())\n\nangr的使用安环境时间跨度两个星期……\n真的好用呀，直接无脑爆破\n使用方法：先进入angr目录：cd angr\n再进入虚拟环境：source venv&#x2F;bin&#x2F;activate\n编脚本就ok\n\n例题：[网鼎杯 2020 青龙组]singal\nexp：（这估计是最简单的用法了）\nimport angrp = angr.Project(&#x27;signal.exe&#x27;)  state = p.factory.entry_state()  simgr = p.factory.simgr(state)  simgr.explore(find=0x0040179e ,avoid=0x004016E6) //成功地址与失败地址 flag = simgr.found[0].posix.dumps(0)[:15]    print(flag)\n\n五秒内爆破出来，真的强\npython打包的exe文件用pyinstxtractor-master解包，至于怎么发现是python打包的，可以看ida打开是否有——main——这种python特有的关键字。\n使用命令行打开，输入：\npython pyinstxtractor.py &#123;exe路径&#125;示例: python pyinstxtractor.py CreatFoder.exe\n\nbase64隐写脚本（例子）：\ndef base64_stego(lines):    alphabet = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;    flag = &#x27;&#x27;    temp = 0    digit = 0    for i in lines:        if i[-1] != &#x27;=&#x27;:            continue        elif i[-2] != &#x27;=&#x27;:            digit += 2            temp = (temp &lt;&lt; 2) + (alphabet.find(i[-2]) &amp; 0x3)        else:            digit += 4            temp = (temp &lt;&lt; 4) + (alphabet.find(i[-3]) &amp; 0xf)        if digit == 8:            digit = 0            flag += chr(temp)            temp = 0        elif digit &gt; 8:            digit = 2            flag += chr(temp &gt;&gt; 2)            temp = temp &amp; 0x3    return flaga = [&quot;55y85YmN6YeN5aSN55qE6aOO5pmvLG==&quot;,&quot;5riQ5riQ5qih57OK5LqG57qm5a6aLO==&quot;,&quot;5pif56m65LiL5rWB5rWq55qE5L2gLH==&quot;,&quot;5LuN54S256eY5a+G55qE6Led56a7LA==&quot;,&quot;5rip5bqm5raI5aSx55qE556s6Ze0LH==&quot;,&quot;5peg5rOV6Kem5pG455qE5piO5aSpLF==&quot;,&quot;5rKh5pyJ5byV5Yqb55qE5LiW55WMLG==&quot;,&quot;5rKh5pyJ6ISa5Y2w55qE5YWJ5bm0LD==&quot;,&quot;6L+Y5Zyo562J552A5L2g5Ye6546wLH==&quot;,&quot;5pel5pel5aSc5aSc6Ieq6L2s55qE6KGM5pifLE==&quot;,&quot;5Yiw5aSE6YGu5ruh5Yir5Lq655qE6IOM5b2xLG==&quot;,&quot;6K6p6aOO5ZC55pWj5re35Lmx55qE5ZG85ZC4LG==&quot;,&quot;5b+r5b+r5riF6YaSfn==&quot;,&quot;6Z2Z6Z2Z54Wn5Lqu5Y6f5p2l55qE6Ieq5bexLL==&quot;,&quot;5aSp56m65rSS5ruh5b+954S255qE5YWJ5piOLE==&quot;,&quot;55y85Lit5Y+q6KaB57ua54OC55qE5aSp6ZmFLG==&quot;,&quot;5YaN6aOe6KGMIW==&quot;,&quot;5oiR5YuH5pWi5Zyw5oqs6LW35aS0LM==&quot;,&quot;55yL552A6Iyr6Iyr55qE5a6H5a6ZLH==&quot;,&quot;5aSa5bCR5pyq55+l55qE5pif55CDLJ==&quot;,&quot;5pyJ5rKh5pyJ6YCa5ZCR5pyq5p2l6Lev5Y+jLD==&quot;,&quot;5Lqy54ix55qE5LyZ5Ly0LB==&quot;,&quot;6K6p5oiR5Lus5LiA6LW354K554eDLG==&quot;,&quot;5YuH5rCU5ZKM5L+h5b+1LO==&quot;,&quot;5Zyo6YGl6L+c55qE5aSp6L65LG==&quot;,&quot;6ZO25rKz6L6557yYLH==&quot;,&quot;5pyJ5LiA54mH56We5aWH55qE5b2p6Jm55rW3LC==&quot;,&quot;5ZKM5oiR5LiA6LW35YaS6ZmpLB==&quot;,&quot;6aOe5ZCR5Y+m5LiA5Liq5LiW55WMLC==&quot;,&quot;5Zyo6YGl6L+c55qE5aSp6L65LB==&quot;,&quot;6ZO25rKz6L6557yYLC==&quot;,&quot;5pyJ5LiA54mH56We5aWH55qE5b2p6Jm55rW3LB==&quot;,&quot;5ZKM5oiR5LiA6LW35YaS6ZmpLH==&quot;,&quot;6aOe5ZCR5Y+m5LiA5Liq5LiW55WMLN==&quot;,&quot;c3VwZXIgbWFnaWMgd29ybGR+fg==&quot;]print(base64_stego(a))#npuctf&#123;Fly1ng!!!&#125;\n\nRC4原理就不说了，关键是这是一个对称加密\n#include&lt;stdio.h&gt;typedef struct _RC4INFO&#123;\tunsigned char s_box[256];\tunsigned char t_box[256];&#125;RC4_INFO, * PRC4_INFO;\t\tvoid rc4_init(PRC4_INFO prc4, unsigned char key[], unsigned int keylen)&#123;\tint i = 0;\tint j = 0;\tunsigned char tmp;\tif (prc4 == NULL)\t&#123;\t\treturn;\t&#125;\t\tfor (i = 0; i &lt; 256; i++)\t&#123;\t\tprc4-&gt;s_box[i] = i;\t\tprc4-&gt;t_box[i] = key[i % keylen];\t&#125;\t\tfor (i = 0; i &lt; 256; i++)\t&#123;\t\tj = (j + prc4-&gt;s_box[i] + prc4-&gt;t_box[i]) % 256;\t\ttmp = prc4-&gt;s_box[i];\t\tprc4-&gt;s_box[i] = prc4-&gt;s_box[j];\t\tprc4-&gt;s_box[j] = tmp;\t&#125;&#125;void rc4_crypt(unsigned char data[], unsigned int datalen, unsigned char key[], unsigned int keylen)\t&#123;\tint dn = 0;\t\tint i = 0;\tint j = 0;\t\tint t = 0;\t\tunsigned char tmp;\tRC4_INFO rc4;\t\t\trc4_init(&amp;rc4, key, keylen);\t\t\tfor (dn = 0; dn &lt; datalen; dn++)    &#123;\t\t\ti = (i + 1) % 256;\t\tj = (j + rc4.s_box[i]) % 256;\t\t\ttmp = rc4.s_box[i];\t\trc4.s_box[i] = rc4.s_box[j];\t\trc4.s_box[j] = tmp;\t\t\tt = (rc4.s_box[i] + rc4.s_box[j]) % 256;\t\tdata[dn] ^= rc4.s_box[t];\t&#125;&#125;void EntryBuffer(unsigned char data[], unsigned int datalen)&#123;\tunsigned char key[] = &#123; 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF &#125;;//key\trc4_crypt(data, datalen, key, sizeof(key) / sizeof(key[0]));&#125;int main()&#123;\tchar Hell[] = &#123; 0x12, 0xF8, 0xA3, 0x80, 0x6B, 0x2E, 0x69, 0x0A, 0x74, 0x24,  0xB7, 0x32, 0x53, 0xFC, 0x7A, 0x9D, 0xE8, 0x7B, 0x9B, 0x2E,  0xEF, 0xF3, 0x0B, 0x45, 0x63, 0x01, 0x35, 0xB7, 0x76, 0x8C,  0xCB, 0xD9, 0xC6, 0x8B, 0x8C, 0x2A, 0xA8, 0xAD, 0x67, 0x09,  0x5C, 0x0F, 0x52, 0xD4, 0x9D, 0x27, 0xC3, 0xD0, 0xC5, 0x91,  0xC0, 0xEA, 0xBF, 0x0D, 0xE7, 0x6C, 0x1A, 0x6A, 0x1A, 0x12,  0xB7, 0xB8, 0x18, 0xB9, 0x46, 0xC3, 0x5B, 0x90, 0x45, 0x7B,  0x94, 0xE6, 0x5F, 0x4F, 0xF0, 0x66, 0x78, 0xCC, 0xE9, 0xBE,  0x0B, 0x94, 0x84, 0x0F, 0x33, 0xAE, 0x97, 0x88, 0x45, 0x4E,  0xD2, 0x76, 0x11, 0x8E, 0x99, 0xFC, 0xCA, 0xD5, 0xE6, 0x27,  0x57, 0x74, 0x01, 0x98, 0x0A, 0xCD, 0x7F, 0x0D, 0xA2, 0xC5,  0xAB, 0xA2, 0x05, 0xA2, 0x86, 0xD3, 0x0E, 0x3A, 0x8E, 0xBA,  0xCC, 0x43, 0xA0, 0xBC, 0x30, 0x1C, 0x7B, 0x42, 0x02, 0xDC,  0xA4, 0xAA, 0x06, 0x89, 0x97, 0xAF, 0x81, 0xC0, 0x8A, 0x0B,  0xF7, 0x6C, 0xFE, 0x30, 0x97, 0x17, 0xEA, 0x79, 0x4F, 0x48,  0x5B, 0xD3, 0xCF, 0x91, 0xD6, 0xF6, 0x73, 0xA9, 0x16, 0x46,  0xB7, 0x5E, 0x63, 0x08, 0x3A, 0x1F, 0x0C, 0xB8, 0xE4, 0xBB,  0x52, 0x2E, 0xAE, 0xED, 0x46, 0x51, 0x82, 0x22, 0xE7, 0x70,  0x33, 0x7C, 0xF8, 0x45, 0x45, 0x33, 0xCA, 0x72, 0x66, 0xCF,  0xC9, 0x2E, 0x5C, 0x45, 0xC1, 0xD1, 0x0A, 0x66, 0xD7, 0x51,  0xA1, 0x74, 0xCC, 0x4A, 0x71, 0xDF, 0xDC, 0x76, 0xEA, 0x9A,  0x11, 0x22, 0x1A, 0x6A, 0x5A, 0x75, 0x12, 0x46, 0x38, 0x6C,  0x63, 0x88, 0x75, 0x20, 0xD5, 0x3C, 0xF8, 0xB5, 0x2F, 0x45,  0x6F, 0x34, 0x8F, 0x9D, 0x10, 0xA8, 0xB3, 0x19, 0x4F, 0xCA,  0xEE, 0x0D, 0xD9, 0xE6, 0xA9, 0x76, 0xEE, 0x97, 0x8E, 0x12,  0x91, 0xED, 0x9A, 0x3C, 0x34, 0xA4, 0xB0, 0x33, 0xAF, 0xC9,  0xFE, 0x7F, 0x00, 0x00, 0xAF, 0x68, 0xCA, 0x91, 0x61, 0x7F &#125;;//密文或者是原文\t\tEntryBuffer((unsigned char*)Hell, sizeof(Hell) / sizeof(Hell[0])); \tprintf(&quot;%s\\n\\n&quot;, Hell);\t//EntryBuffer((unsigned char*)Hell, sizeof(Hell) / sizeof(Hell[0])); //由于异或运算的对合性，RC4加密解密使用同一套算法。\t//printf(&quot;解密后：pData=%s\\n\\n&quot;, Hell);\treturn 0;&#125;\n\n高版本pyc反编译对于python版本3.11以上的pyc，现在的在线网站就不支持了\n首先安装python3.11，配置好pycharm。\nimport disimport marshalPATH = &quot;./easyRE.exe_extracted/easyRE.pyc&quot;with open(PATH, &quot;rb&quot;) as f:    code = f.seek(16)    code = marshal.load(f)    with open(&quot;easyRE.pyc.txt&quot;, &quot;w&quot;) as f:        dis.dis(code, file=f)\n\n但是只能获得字节码\nidc提取数据auto addr = 0x0000000100008000;auto i = 0;for(i; i &lt; 10; i = i+1)&#123;\tMessage(&quot;%x&quot;,Byte(addr+i));\t//PatchByte(addr+i,Byte());&#125;auto addr = 0x000000000000006020C0;auto i = 0;for(i; addr+i &lt; 0x060213C; i = i+4)&#123;\tMessage(&quot;%d,&quot;,Byte(addr+i));\t//PatchByte(addr+i,Byte());&#125;\n\npython版本问题现在电脑上是有2.7,3.8,3.11三个版本的，在pycharm里切换的话就在setting里，挺方便的\n在cmd里切换的话，需要在环境变量里切换顺序，注意是下面那个系统环境变量，要用谁就把他上移到最前面。\n","categories":["网安"],"tags":["逆向"]},{"title":"8086汇编","url":"/2022/03/04/8086%E6%B1%87%E7%BC%96/","content":"仅作自己学习参考，内容仅记录自己认为比较重要的，对于知识体系来说不全 \n放在博客这格式就有点不对劲，代码块明明设置的assembly，但是显示的是text，高亮也显示不了，也许是这个主题的问题，但本地显示都没问题，不管了\n本文参考(40条消息) 王爽《汇编语言》笔记（详细）_汇编语言笔记_洋葱汪的博客-CSDN博客\n一.基础知识1.指令机器指令：CPU能直接识别并执行的二进制编码\n汇编指令：汇编指令是机器指令的助记符，同机器指令一一对应。\n指令：指令通常由操作码和地址码（操作数）两部分组成\n指令集：每种CPU都有自己的汇编指令集。\n编译器：够将汇编指令转换成机器指令的翻译程序每一种CPU都有自己的汇编指令集。\n2.存储器随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储\n只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失\n3.总线总线是连接各个部件的信息传输线，是各个部件共享的传输介质。\n根据传送信息的不同，系统总线从逻辑上分为3类，地址总线、控制总线和数据总线。\n二.寄存器1.寄存器CPU由运算器、控制器、寄存器等器件构成，这些器件靠片内总线相连。\n运算器进行信息处理；控制器控制各种器件进行工作；寄存器进行信息存储；\n8086CPU有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW都是16位\n8086采用小端模式：高地址存放高位字节，低地址存放低位字节\n2.通用寄存器通常用来存放一般性的数据，有AX、BX、CX、DX，它们可分为两个可独立使用的8位寄存器\n\n\n\n16位\n高八位\n低八位\n\n\n\nAX\nAH\nAL\n\n\nBX\nBH\nBL\n\n\nCX\nCH\nCL\n\n\nDX\nDH\nDL\n\n\n在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的\n一个8位寄存器所能存储的数据范围是0 ~ 28-1。\n3.8086CPU给出物理地址的方法8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。\n当8086CPU要读写内存时：\nCPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；地址加法器将两个16位地址合成为一个20位的物理地址；地址加法器采用物理地址 &#x3D; 段地址×16 + 偏移地址的方法用段地址和偏移地址合成物理地址。\n例如，8086CPU要访问地址为123C8H的内存单元，1230H左移一位(空出4位)加上00C8H合成123C8H\n4.段寄存器我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，可以用分段的方式来管理内存。\n用一个段存放数据，将它定义为“数据段”；\n用一个段存放代码，将它定义为“代码段”；\n用一个段当作栈，将它定义为“栈段”。\n注意：\n一个段的起始地址一定是16的倍数；偏移地址为16位，变化范围为0-FFFFH，所以一个段的长度最大为64KB。CPU可以用不同的段地址和偏移地址形成同一个物理地址。段寄存器：8086CPU有4个段寄存器：CS、DS、SS、ES，提供内存单元的段地址。\n1.CS和IPCS为代码段寄存器，IP为指令指针寄存器，\nCPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,\nCPU将CS:IP指向的内容当作指令执行。(即PC)\n8086CPU的工作过程简要描述\n\n从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；\nIP&#x3D;IP+所读取指令的长度，从而指向下一条指令；\n执行指令。转到步骤1，重复这个过程\n\n2.DS 和 [address]DS寄存器：通常用来存放要访问数据的段地址\n[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中\n通过数据段段地址和偏移地址即可定位内存单元。\n3.SS 和 SP在基于8086CPU编程的时候，可以将一段内存当作栈来使用。\n栈段寄存器SS，存放段地址，SP寄存器存放偏移地址，任意时刻，SS:SP指向栈顶元素\n8086CPU中，入栈时，栈顶从高地址向低地址方向增长。\npush ax表示将寄存器ax中的数据送入栈中，由两步完成。\nSP&#x3D;SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。\npop ax表示从栈顶取出数据送入ax，由以下两步完成。\n\n将SS:SP指向的内存单元处的数据送入ax中；\nSP&#x3D;SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。\n\n一看到这就想到脱壳了……\n三.第一个程序汇编程序从写出到执行的过程：\n\n加载后，CPU的CS:IP指向程序的第一条指令（即程序的入口）\n四.[bx] 和 loop指令1.[bx] 和 loop指令[bx] 的含义：[bx]同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中\nloop指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作:\n(cx) &#x3D; (cx) - 1；\n判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。\n例如：计算2的12次：\nassume cs:code code segment \tmov ax, 2\t\tmov cx, 11 ;循环次数s:  add ax, ax ;2+2  4+4  8+8\tloop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，               ;这个地址处有一条指令：add ax，ax。               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。\t\tmov ax,4c00h \tint 21h code ends end\n\n\n\nloop 和 [bx] 的联合应用\n计算ffff:0 ~ ffff:b单元中的数据的和，结果存储在dx中\n问题分析：\n这些内存单元都是字节型数据范围0 ~ 255 ，12个字节数据和不会超过65535，dx可以存下对于8位数据不能直接加到 dx解决方案：\n用一个16位寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器a中，再将ax中的数据加到dx\nassume cs:code code segment \tmov ax, 0ffffh ;在汇编源程序中，数据不能以字母开头，所以要在前面加0。\tmov ds, ax    ;段地址默认在ds中\tmov bx, 0   ;初始化ds:bx指向ffff:0\tmov dx, 0   ;初始化累加寄存器dx，（dx）= 0\t\tmov cx, 12  ;初始化循环计数寄存器cx，（cx）= 12s:  mov al, [bx]\tmov ah, 0\tadd dx, ax  ;间接向dx中加上（（ds）* 16 +（bx））单元的数值\tinc bx      ;ds:bx指向下一个单元\tloop s \t\tmov ax, 4c00h \tint 21h code ends end\n\n\n\n2.段前缀mov ax, ds:[bx]mov ax, cs:[bx]mov ax, ss:[bx]mov ax, es:[bx]mov ax, ss:[0]mov ax, cs:[0]\n\n这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的“ds:”，“cs:”，“ss:”，“es:”，在汇编语言中称为段前缀。\n3.段前缀的使用将内存ffff:0 ~ ffff:b单元中的数据复制到0:200 ~ 0:20b单元中。\nassume cs:code code segment \tmov ax, 0ffffh \tmov ds, ax   ;（ds）= 0ffffh \tmov ax, 0020h    mov es, ax   ;（es）= 0020h     0:200 等效于 0020:0    mov bx, 0    ;（bx）= 0，此时ds:bx指向ffff:0，es:bx指向0020:0    \tmov cx，12   ;（cx）=12，循环12次s:  mov dl，[bx] ;（d1）=（（ds）* 16+（bx）），将ffff:bx中的字节数据送入dl \tmov es:[bx]，dl ;（（es）*16+（bx））=（d1），将dl中的数据送入0020:bx \tinc bx  ;（bx）=（bx）+1\tloop s \t\tmov ax，4c00h \tint 21h code ends end\n\n五.包含多个段的程序在代码段中使用数据\n;计算 8 个数据的和存到 ax 寄存器assume cs:code code segment \tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据\tstart:\tmov bx, 0  ;标号start\t\t\tmov ax, 0  \t\t\t\t\t\tmov cx, 8\ts:\t\tadd ax, cs:[bx]\t\t\tadd bx, 2\t\t\tloop s \t\t\t\t\t\tmov ax, 4c00h \t\t\tint 21h code endsend start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方\t     \t ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。\n\n在代码段中使用栈\n;利用栈，将程序中定义的数据逆序存放。assume cs:codesg codesg segment \tdw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元\tdw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用\t\t\t\tstart:\tmov ax, cs \t\t\tmov ss, ax \t\t\tmov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d\t\t\tmov bx, 0\t\t\t\t\t\tmov cx, 8\ts:\t\tpush cs:[bx]\t\t\tadd bx, 2\t\t\tloop s    ;以上将代码段0~15单元中的8个字型数据依次入栈\t\t\t\t\t\tmov bx, 0\t\t\t\t\t\tmov cx, 8\ts0:\t\tpop cs:[bx]\t\t\t\t\tadd bx，2\t\t\tloop s0   ;以上依次出栈8个字型数据到代码段0~15单元中\t\t\t\t\t\tmov ax，4c00h \t\t\tint 21h codesg ends end start\t;指明程序的入口在start处\n\n六.更灵活的定位内存地址的方法1.and 和 orand指令：逻辑与指令，按位进行与运算。\nmov al, 01100011Band al, 00111011B\n执行后：al&#x3D;00100011B即都为1才为1\nor指令：逻辑或指令，按位进行或运算。\nmov al, 01100011Bor al, 00111011B执行后：al&#x3D;01111011B 即只要有一个为1就为1\n2.[bx+idata][bx+idata]表示一个内存单元, 例如：mov ax, [bx+200]该指令也可以写成如下格式：\nmov ax, [200+bx]mov ax, 200[bx]mov ax, [bx].200\n\n\n\n用[bx+idata]的方式进行数组的处理\nassume cs:codesg,ds:datasg datasg segment \tdb &#x27;BaSiC&#x27;;转为大写\tdb &#x27;MinIx&#x27;;转为小写datasg endscodesg segment\tstart:\t\tmov ax, datasg \t\tmov ds, ax \t\tmov bx, 0  ;初始ds:bx\t\t\tmov cx, 5\ts:\tmov al, 0[bx]  ;注意这种写法，有三种等效写法\t\tand al, 11011111b ;转为大写字母\t\tmov 0[bx], al ;写回\t\tmov al, 5[bx]  ;[5 + bx]\t\tor al, 00100000b ;转为小写字母\t\tmov 5[bx], al \t\tinc bx\t\tloop s\t\t\t\tmov ax, 4c00h \t\tint 21hcodesg endsend start\n\n用c语言表示：\nint main()&#123;\tchar a[] = &quot;BaSic&quot;;\tchar b[] = &quot;MinIX&quot;;\t\tint i = 0;\t\tdo\t&#123;\t\ta[i] = a[i] &amp; 0xDF;\t\tb[i] = b[i] | 0x20;\t\ti++;\t&#125; while(i &lt; 5);\treturn 0; &#125; \n\n3.SI 、DI 与 寻址方式的灵活应用1.si 、disi和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。\nassume cs: codesg, ds: datasg datasg segment \tdb &#x27;welcome to masm!&#x27;;用si和di实现将字符串‘welcome to masm！&quot;复制到它后面的数据区中。\tdb &#x27;................&#x27;datasg endscodesg segment \tstart:\tmov ax, datasg \t\t\tmov ds, ax \t\t\tmov si, 0\t\t\t\t\t\tmov cx, 8\ts:\t\tmov ax, 0[si] ;[0 + si]\t\t\tmov 16[si], ax ;[16 + si] 使用[bx +idata]方式代替di，使程序更简洁\t\t\tadd si, 2 \t\t\tloop s \t\t\t\t\t\tmov ax, 4c00h \t\t\tint 21h codesg ends end start\n\n2.[bx + si] 和 [bx + di][bx+si]和[bx+di]的含义相似\n[bx+si]表示一个内存单元，它的偏移地址为（bx）+（si）\n指令mov ax, [bx + si]的含义：将一个内存单元字数据的内容送入ax，段地址在ds中\n该指令也可以写成如下格式：mov ax, [bx] [si]\n3.[bx+si+idata]和[bx+di+idata][bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+idata\n指令mov ax，[bx+si+idata]的含义：将一个内存单元字数据的内容送入ax，段地址在ds中\n4.不同的寻址方式的灵活应用\n[idata]用一个常量来表示地址，可用于直接定位一个内存单元；\n[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；\n[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；\n[bx+si]用两个变量表示地址；\n[bx+si+idata]用两个变量和一个常量表示地址。\n\n;将datasg段中每个单词改为大写字母assume cs:codesg,ds:datasg,ss:stacksg datasg segment\tdb &#x27;ibm            &#x27; ;16\tdb &#x27;dec            &#x27; \tdb &#x27;dos            &#x27;\tdb &#x27;vax            &#x27;  ;看成二维数组datasg ends stacksg segment ;定义一个段，用来做栈段，容量为16个字节\tdw 0, 0, 0, 0, 0, 0, 0, 0stacksg ends codesg segment \tstart:\tmov ax, stacksg \t\t\tmov ss, ax\t\t\tmov sp, 16 \t\t\tmov ax, datasg \t\t\tmov ds, ax \t\t\tmov bx, 0 ;初始ds:bx\t\t\t\t\t\t;cx为默认循环计数器，二重循环只有一个计数器，所以外层循环先保存cx值，再恢复，我们采用栈保存\t\t\tmov cx, 4\ts0:\t\tpush cx\t;将外层循环的cx值入栈\t\t\tmov si, 0\t\t\tmov cx, 3\t;cx设置为内层循环的次数\ts:\t\tmov al, [bx+si]\t\t\tand al, 11011111b ;每个字符转为大写字母\t\t\tmov [bx+si], al \t\t\tinc si\t\t\tloop s \t\t\t\t\t\tadd bx, 16 ;下一行\t\t\tpop cx\t;恢复cx值\t\t\tloop s0 ;外层循环的loop指令将cx中的计数值减1\t\t\t\t\t\tmov ax，4c00H \t\t\tint 21H codesg endsend start\n\n七、数据处理的两个基本问题1. bx、si、di和bp在8086CPU中，只有这4个寄存器可以用在“[…]”中来进行内存单元的寻址。\n在[ ]中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si、bx和di、bp和si、bp和di。\n只要在[……]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中\n2.机器指令处理的数据在什么地方数据处理大致可分为3类：读取、写入、运算。\n在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口\n\n3.汇编语言中数据位置的表达汇编语言中用3个概念来表达数据的位置\n\n立即数（idata）\n\nmov ax, 1                 ;对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）add bx, 2000h             ;在汇编语言中称为：立即数（idata）or bx, 00010000bmov al, &#x27;a&#x27;\n\n\n寄存器\n\nmov ax, bx     ;指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。mov ds, ax push bx mov ds:[0], bx push ds mov ss, axmov sp, ax\n\n\n段地址（SA）和偏移地址（EA）\n\n;指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。mov ax, [0]mov ax, [di]mov ax, [bx+8]mov ax, [bx+si]mov ax, [bx+si+8]   ;以上段地址默认在ds中mov ax, [bp]mov ax, [bp+8]mov ax, [bp+si]mov ax, [bp+si+8]   ;以上段地址默认在ss中mov ax, ds:[bp]mov ax, es:[bx]mov ax, ss:[bx+si]mov ax, cs:[bx+si+8] ;显式给出存放段地址的寄存器\n\n寻址方式\n\n4.指令要处理的数据有多长8086CPU的指令，可以处理两种尺寸的数据，byte和word\n\n通过寄存器名指明要处理的数据的尺寸。例如： mov al, ds:[0] 寄存器al指明了数据为1字节\n在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte。例如：mov byte ptr ds:[0], 1 byte ptr 指明了指令访问的内存单元是一个字节单元\n有些指令默认了访问的是字单元还是字节单元例如，push [1000H]，push 指令只进行字操作。\n\n5.寻址方式的综合应用eg：\nmov ax, seg mov ds, ax mov bx, 60h   ;确定记录地址，ds:bx mov word ptr [bx+0ch], 38   ;排名字段改为38  [bx].0chadd word ptr [bx+0eh], 70   ;收入字段增加70  [bx].0ehmov si, 0   ;用si来定位产品字符串中的字符mov byte ptr [bx+10h+si], &#x27;V&#x27;   ;[bx].10h[si]inc si mov byte ptr [bx+10h+si], &#x27;A&#x27;inc si mov byte ptr [bx+10h+si], &#x27;X&#x27;\n\nC语言描述\n/*定义一个公司记录的结构体*/struct company&#123;    char cn[3];/*公司名称*/    char hn[9];/*总裁姓名*/    int pm;/*排名*/    int sr;/*收入*/    char cp[3];/*著名产品*/&#125;;//sizeof (struct company) == 24int main()&#123;    /*定义一个公司记录的变量，内存中将存有一条公司的记录*/    struct company dec = &#123;&quot;DEC&quot;, &quot;Ken Olsen&quot;, 137, 40, &quot;PDP&quot;&#125;;    int i;    dec.pm = 38;    dec.sr = dec.sr + 70;    i = 0;    dec.cp[i] = &#x27;V&#x27;; //mov byte ptr [bx].10h[si], &#x27;V&#x27;    i++;    dec.cp[i] = &#x27;A&#x27;;    i++;    dec.cp[i] = &#x27;X&#x27;;    return 0;&#125;\n\n6.div指令、dd、dup、mul指令div是除法指令\n除数：有8位和16位两种，在一个寄存器或内存单元中。\n被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。\n结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。\n;利用除法指令计算100001/100。;100001D = 186A1Hmov dx, 1;高16位mov ax, 86A1H ;(dx)*10000H+(ax)=100001  低16位mov bx, 100;除数div bx   ;div 除数  被除数默认在dx和ax中存放;利用除法指令计算1001/100  这个是8位的除法mov ax, 1001mov bl, 100div b1\n\n伪指令dd\ndb和dw定义字节型数据和字型数据。\ndd是用来定义dword（double word，双字）型数据的伪指令\n操作符dup\ndup在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。它和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复\ndb 3 dup (0)       ;定义了3个字节，它们的值都是0，相当于db 0，0，0。db 3 dup (0, 1, 2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0，1，2，0，1，2，0，1，2。db 3 dup (&#x27;abc&#x27;, &#x27;ABC&#x27;) ;定义了18个字节，它们是abcABCabcABCabcABCC，相当于db &#x27;abc&#x27;, &#x27;ABC&#x27; ,&#x27;abc&#x27; , &#x27;ABC, &#x27;abc&#x27;, &#x27;ABC&#x27;。\n\nmul 指令\nmul是乘法指令，使用 mul 做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。\n8 位： AL中和 8位寄存器或内存字节单元中；\n16 位： AX中和 16 位寄存器或内存字单元中。\n结果\n8位：AX中；\n16位：DX（高位）和 AX（低位）中。\n格式：&#x3D;&#x3D;mul 寄存器&#x3D;&#x3D; 或 &#x3D;&#x3D;mul 内存单元&#x3D;&#x3D;\n;计算100*10;100和10小于255，可以做8位乘法mov al,100mov bl,10mul bl ;默认其中一个就是在al中（八位）;结果： (ax)=1000（03E8H） \n\n;计算100*10000;100小于255，可10000大于255，所以必须做16位乘法，程序如下：mov ax,100mov bx,10000mul bx;结果： (ax)=4240H，(dx)=000FH     （F4240H=1000000）\n\n八、转移指令的原理可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。\n8086CPU的转移行为有以下几类。\n只修改IP时，称为&#x3D;&#x3D;段内转移&#x3D;&#x3D;，比如：&#x3D;&#x3D;jmp ax&#x3D;&#x3D;。同时修改CS和IP时，称为&#x3D;&#x3D;段间转移&#x3D;&#x3D;，比如：&#x3D;&#x3D;jmp 1000:0&#x3D;&#x3D;。\n由于转移指令对IP的修改范围不同，段内转移又分为：&#x3D;&#x3D;短转移和近转移&#x3D;&#x3D;\n短转移IP的修改范围为&#x3D;&#x3D;-128 ~ 127&#x3D;&#x3D;。近转移IP的修改范围为&#x3D;&#x3D;-32768 ~ 32767&#x3D;&#x3D;。\n8086CPU的转移指令分为以下几类\n\n无条件转移指令（如：jmp）\n条件转移指令\n循环指令（如：loop）\n过程\n中断\n\n1.操作符offset操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址\n;将s处的一条指令复制到s0处assume cs:codesgcodesg segment s:   mov ax, bx           ;（mov ax,bx 的机器码占两个字节）      mov si, offset s     ;获得标号s的偏移地址      mov di, offset s0    ;获得标号s0的偏移地址            mov ax, cs:[si]      mov cs:[di], ax s0:  nop                     ;（nop的机器码占一个字节）      nop codesg ends ends\n\n\n\n2.jmp指令jmp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；\njmp指令要给出两种信息：\n\n转移的目的地址\n转移的距离（段间转移、段内短转移，段内近转移）\n\n jmp short 标号， jmp near ptr 标号， jcxz 标号， loop 标号   等几种汇编指令，它们对 IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。\n依据位移进行转移的jmp指令jmp short 标号&#x3D;&#x3D;（段内短转移）&#x3D;&#x3D;\n指令“jmp short 标号”的功能为(IP)&#x3D;(IP)+8位位移，转到标号处执行指令\n（1）8位位移 &#x3D; “标号”处的地址 - jmp指令后的第一个字节的地址；\n（2）short指明此处的位移为8位位移；\n（3）8位位移的范围为-128~127，用补码表示\n（4）8位位移由编译程序在编译时算出。\nassume cs:codesgcodesg segment  start:mov ax,0        jmp short s ;s不是被翻译成目的地址        add ax, 1      s:inc ax ;程序执行后， ax中的值为 1 codesg endsend start\n\nCPU不需要这个目的地址就可以实现对IP的修改。这里是依据&#x3D;&#x3D;位移进行转移&#x3D;&#x3D;\njmp short s指令的读取和执行过程：\n(CS)&#x3D;0BBDH，(IP)&#x3D;0006，上一条指令执行结束后CS:IP指向EB 03（jmp short s的机器码）；读取指令码EB 03进入指令缓冲器；(IP) &#x3D; (IP) + 所读取指令的长度 &#x3D; (IP) + 2 &#x3D; 0008，CS:IP指向add ax,1；CPU指行指令缓冲器中的指令EB 03；指令EB 03执行后，(IP)&#x3D;000BH，CS:IP指向inc ax\njmp near ptr 标号 &#x3D;&#x3D;（段内近转移）&#x3D;&#x3D;\n指令“jmp near ptr 标号”的功能为：**(IP) &#x3D; (IP) + 16位位移**。\n转移的目的地址在指令中的jmp指令\njmp far ptr 标号&#x3D;&#x3D;（段间转移或远转移）&#x3D;&#x3D;\n指令jmp far ptr 标号 功能如下：\n\n(CS) &#x3D; 标号所在段的段地址；\n(IP) &#x3D; 标号所在段中的偏移地址。\nfar ptr指明了指令用标号的段地址和偏移地址修改CS和IP。\n\nassume cs:codesgcodesg segment   start: mov ax, 0\t\t  mov bx, 0          jmp far ptr  s ;s被翻译成转移的目的地址0B01 BD0B          db 256 dup (0) ;转移的段地址：0BBDH，偏移地址：010BH    s:    add ax,1          inc axcodesg endsend start\n\n3.转移地址在寄存器或内存中的jmp指令jmp 16位寄存器 功能：IP &#x3D;（16位寄存器）\n转移地址在内存中的jmp指令有两种格式：\n\njmp word ptr 内存单元地址（段内转移）\n\n功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。\nmov ax, 0123Hmov ds:[0], axjmp word ptr ds:[0];执行后，(IP)=0123H\n\n\njmp dword ptr 内存单元地址（段间转移）\n\n功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。\n\n(CS)&#x3D;(内存单元地址+2)\n(IP)&#x3D;(内存单元地址)\n\nmov ax, 0123Hmov ds:[0], ax;偏移地址mov word ptr ds:[2], 0;段地址jmp dword ptr ds:[0];执行后，;(CS)=0;(IP)=0123H;CS:IP 指向 0000:0123。\n\n4.jcxz指令和loop指令jcxz指令\njcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，\n在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。\n指令格式：jcxz 标号（如果(cx)&#x3D;0，则转移到标号处执行。）\n当(cx) &#x3D; 0时，(IP) &#x3D; (IP) + 8位位移\n8位位移 &#x3D; “标号”处的地址 - jcxz指令后的第一个字节的地址；8位位移的范围为-128~127，用补码表示；8位位移由编译程序在编译时算出。当(cx)!&#x3D;0时，什么也不做（程序向下执行）\nloop指令\nloop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。\n对IP的修改范围都为-128~127。\n指令格式：loop 标号 ((cx) &#x3D; (cx) - 1，如果(cx) ≠ 0，转移到标号处执行)。\n(cx) &#x3D; (cx) - 1；如果 (cx) !&#x3D; 0，(IP) &#x3D; (IP) + 8位位移。\n8位位移 &#x3D; 标号处的地址 - loop指令后的第一个字节的地址；8位位移的范围为-128~127，用补码表示；8位位移由编译程序在编译时算出。如果（cx）&#x3D; 0，什么也不做（程序向下执行）。\n九、call和ret指令call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。\n1.ret 和 retf\nret指令用栈中的数据，修改IP的内容，从而实现近转移；\n\nretf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。\n\n\nCPU执行ret指令时，相当于进行： pop IP：\n（1）(IP) &#x3D; ( (ss) * 16 + (sp) )\n（2）(sp) &#x3D; (sp) + 2\nCPU执行retf指令时，相当于进行：pop IP, pop CS：\n（1）(IP) &#x3D; ( (ss) * 16 + (sp) )\n（2）(sp) &#x3D; (sp) + 2\n（3）(CS) &#x3D; ( (ss) * 16 + (sp) )\n（4）(sp) &#x3D; (sp) + 2\nassume cs:code stack seqment\tdb 16 dup (0)stack ends code segment\t\tmov ax, 4c00h\t\tint 21h  start:\tmov ax, stack  \t\tmov ss, ax \t\tmov sp, 16\t\tmov ax, 0\t\tpush ax ;ax入栈\t\tmov bx, 0\t\tret ;ret指令执行后，(IP)=0，CS:IP指向代码段的第一条指令。可以push cs  push ax  retfcode endsend start\n\n2.call 指令call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：\n（1）将当前的 IP 或 CS和IP 压入栈中；\n（2）转移（jmp）。\ncall指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。\n\ncall 标号（近转移）\n\nCPU执行此种格式的call指令时，相当于进行 push IP   jmp near ptr 标号\n\ncall far ptr 标号（段间转移）\n\nCPU执行此种格式的call指令时，相当于进行：push CS，push IP   jmp far ptr 标号\n\ncall 16位寄存器\n\nCPU执行此种格式的call指令时，相当于进行： push IP   jmp 16位寄存器\n\ncall word ptr 内存单元地址\n\nCPU执行此种格式的call指令时，相当于进行：push IP   jmp word ptr 内存单元地址\n\ncall dword ptr 内存单元地址\n\nCPU执行此种格式的call指令时，相当于进行：push CS    push IP   jmp dword ptr 内存单元地址\n3.call 和 ret 的配合使用示例程序：\nassume cs:codecode segmentstart:\tmov ax,1\t    mov cx,3     \tcall s ;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP入栈，jmp     \t\t    mov bx,ax\t;（4）IP重新指向这里  bx = 8     \tmov ax,4c00h     \tint 21h     s: add ax,ax     \tloop s;（2）循环3次ax = 8\t    ret;（3）return : pop IPcode endsend start\n\n十、标志寄存器（这部分不太好记，那就不记了，实战过程中慢慢积累吧，看着看着就记住了）\n1.标志寄存器CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。\n（1）用来存储相关指令的某些执行结果；\n（2）用来为CPU执行相关指令提供行为依据；\n（3）用来控制CPU的相关工作方式。\n这种特殊的寄存器在8086CPU中，被称为标志寄存器（flag）。\n8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW-Program Status Word）\nflag寄存器是按位起作用的，它的每一位都有专门的含义，记录特定的信息。\n\n在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令\n1.零标志位 (ZF)零标志位（Zero Flag）。它记录相关指令执行后，其结果是否为0。\n如果结果为0，那么zf &#x3D; 1(表示结果是0)；如果结果不为0，那么zf &#x3D; 0。\nmov ax, 1sub ax, 1 ;执行后，结果为0，则zf = 1mov ax, 2sub ax, 1 ;执行后，结果不为0，则zf = 0\n\n2.奇偶标志位 (PF)奇偶标志位（Parity Flag）。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。\n如果1的个数为偶数，pf &#x3D; 1，如果为奇数，那么pf &#x3D; 0。\nmov al, 1add al, 10 ;执行后，结果为00001011B，其中有3（奇数）个1，则pf = 0；mov al, 1or al, 2  ;执行后，结果为00000011B，其中有2（偶数）个1，则pf = 1；\n\n3.符号标志位(SF)符号标志位(Symbol Flag)。它记录相关指令执行后，其结果是否为负。\n如果结果为负，sf &#x3D; 1；如果非负，sf &#x3D; 0。\n计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。\n00000001B，可以看作为无符号数1，或有符号数+1；10000001B，可以看作为无符号数129，也可以看作有符号数-127。\n对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算\nCPU在执行add等指令的时候，就包含了两种含义:可以将add指令进行的运算当作无符号数的运算，也可以将add指令进行的运算当作有符号数的运算\nSF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值\nmov al, 10000001B add al, 1   ;执行后，结果为10000010B，sf = 1，表示：如果指令进行的是有符号数运算，那么结果为负；mov al, 10000001Badd al, 01111111B   ;执行后，结果为0，sf = 0，表示：如果指令进行的是有符号数运算，那么结果为非负\n\n4.进位标志位(CF)进位标志位(Carry Flag)。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值\n5.溢出标志位(OF)溢出标志位(Overflow Flag)。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。\n如果发生溢出，OF &#x3D; 1；如果没有，OF &#x3D; 0。\nCF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位\nCPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。\n对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。\nmov al, 98add al, 99   ;执行后将产生溢出。因为进行的&quot;有符号数&quot;运算是：（al）=（al）+ 99 = 98 + 99=197 = C5H 为-59的补码             ;而结果197超出了机器所能表示的8位有符号数的范围：-128-127。             ;add 指令执行后：无符号运算没有进位CF=0，有符号运算溢出OF=1             ;当取出的数据C5H按无符号解析C5H = 197, 当按有符号解析通过SP得知数据为负,即C5H为-59补码存储，             mov al，0F0H  ;F0H，为有符号数-16的补码   -Not(F0 - 1)add al，088H  ;88H，为有符号数-120的补码   -Not(88- 1)              ;执行后，将产生溢出。因为add al, 088H进行的有符号数运算结果是：（al）= -136               ;而结果-136超出了机器所能表示的8位有符号数的范围：-128-127。              ;add 指令执行后：无符号运算有进位CF=1，有符号运算溢出OF=1\n\n2.adc指令和sbb指令adc指令\nadc是带进位加法指令，它利用了CF位上记录的进位值。\n指令格式：adc 操作对象1, 操作对象2\n功能：操作对象1 &#x3D; 操作对象1 + 操作对象2 + CF\nmov ax, 2mov bx, 1sub bx, ax  ;无符号运算借位CF=1，有符号运算OF = 0adc ax, 1   ;执行后，（ax）= 4。adc执行时，相当于计算：(ax)+1+CF = 2+1+1 = 4。\n\n\n;计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。;将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。mov ax, 001EH mov bx, 0F000H add bx, 1000Hadc ax, 0020H\n\nsbb指令\nsbb是带借位减法指令，它利用了CF位上记录的借位值。\n指令格式：sbb 操作对象1, 操作对象2\n功能：操作对象1 &#x3D; 操作对象1 - 操作对象2 - CF\n;计算 003E1000H - 00202000H，结果放在ax，bx中，程序如下：mov bx, 1000Hmov ax, 003EHsub bx, 2000Hsbb ax, 0020H\n\n3.cmp指令cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。\n其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。\ncmp指令格式：cmp 操作对象1，操作对象2\n例如：指令cmp ax, ax，做（ax）-（ax）的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。指令执行后：zf&#x3D;1，pf&#x3D;1，sf&#x3D;0，cf&#x3D;0，of&#x3D;0。\nCPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。\n\n\n\ncmp ax, bx\n无符号比较时\n\n\n\n(ax) &#x3D; (bx)\nzf &#x3D; 1\n\n\n(ax) ≠ (bx)\nzf &#x3D; 0\n\n\n(ax) &lt; (bx)\ncf &#x3D; 1\n\n\n(ax) ≥ (bx)\ncf &#x3D; 0\n\n\n(ax) &gt; (bx)\ncf &#x3D; 0 且 zf &#x3D; 0\n\n\n(ax) ≤ (bx)\ncf &#x3D; 1 且 zf &#x3D; 1\n\n\n上面的表格可以正推也可以逆推\n如果用cmp来进行有符号数比较时：SF只能记录实际结果的正负，发生溢出的时候，实际结果的正负不能说明逻辑上真正结果的正负。但是逻辑上的结果的正负，才是cmp指令所求的真正结果，所以我们在考察SF的同时考察OF，就可以得知逻辑上真正结果的正负，同时就知道比较的结果。\nmov ah, 08AH  ; -Not(8A-1) = -118  即当成有符号数时为-118mov bh, 070H  ; 有符号数时最高位为0为正数， 70H = 112cmp ah, bh    ;（ah）-（bh）实际得到的结果是1AH \t\t      ; 在逻辑上，运算所应该得到的结果是：（-118）- 112 = -230\t\t      ; sf记录实际结果的正负，所以sf=0\n\n4.检测比较结果的条件转移指令可以根据某种条件，决定是否修改IP的指令\njcxz它可以检测cx中的数值，如果（cx）&#x3D;0，就修改IP，否则什么也不做。\n所有条件转移指令的转移位移都是[-128，127]。\n多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP\n这些条件转移指令通常都和cmp相配合使用,它们所检测的标志位，都是cmp指令进行无符号数比较的时记录比较结果的标志位\n根据无符号数的比较结果进行转移的条件转移指令（它们检测zf、cf的值）\n这个挺重要的：\n\n\n\n指令\n含义\n检测的相关标志位\n\n\n\nje\n等于则转移\nzf &#x3D; 1\n\n\njne\n不等于则转移\nzf &#x3D; 0\n\n\njb\n低于则转移\ncf &#x3D; 1\n\n\njnb\n不低于则转移\ncf &#x3D; 0\n\n\nja\n高于则转移\ncf &#x3D; 0 且 zf &#x3D; 0\n\n\njna\n不高于则转移\ncf &#x3D; 1 且 zf &#x3D; 1\n\n\n贴张图，需要魔法上网才可以看：\n\n5.DF标志和串传送指令方向标志位。在串处理指令中，控制每次操作后si、di的增减。\ndf &#x3D; 0每次操作后si、di递增；df &#x3D; 1每次操作后si、di递减。\n格式：movsb功能：将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减\n格式：movsw功能：将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2。\n格式：rep movsbmovsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，功能：rep的作用是根据cx的值，重复执行后面的串传送指令\n8086CPU提供下面两条指令对df位进行设置。\ncld指令：将标志寄存器的df位置0std指令：将标志寄存器的df位置1\n;将data段中的第一个字符串复制到它后面的空间中。data segment \tdb &#x27;Welcome to masm!&#x27;\tdb 16 dup (0)data endsmov ax, data mov ds, ax mov si, 0   ;ds:si 指向data:0mov es, ax mov di, 16  ;es:di指向data:0010mov cx, 16  ;（cx）=16，rep循环16次cld  ;设置df=0，正向传送rep movsb\n\n6.pushf和popfpushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中\npushf和popf，为直接访问标志寄存器提供了一种方法。\n\n接下来还有一些内容，但是目前来说是用不到的，就先不学了，什么时候用到了再说\n","categories":["网安"],"tags":["逆向"]},{"title":"逆向工程核心原理","url":"/2023/03/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/","content":"第一章打补丁对于修改书中的那个程度有两种办法\n1.直接修改字符串缓冲区\n2.其他位置生成新字符串并将该地址传递给消息函数\n栈帧使用EBP寄存器访问栈内局部变量、参数、函数返回地址等的手段。ESP寄存器承担着栈顶指针的作用，而EBP寄存器则负责行使栈帧指针的作用。程序运行时ESP的值随时改变，因此在调用函数时，先把基准点（函数起始位置）的ESP值保存到EBP，并维持在函数内部。这样无论ESP值如何变化，以EBP值为基准能够安全访问到相关函数的局部变量、参数、返回值等。其中EBP寄存器作为栈帧指针的作用。在栈中保存函数返回地址是系统安全隐患之一，攻击者使用缓冲区溢出技术能把保存在栈内存的返回地址更改为其它地址。\n\n举个简单的例子吧：\n程序源码：\n第一步：先让程序运行到main函数暂停，观察栈的初始状态：\n\n当前ESP值为12FF44 ，EBP的值为12FF88  \n生成main函数的栈帧：\n\n此时栈的状态变为：\n\n这个时候main函数的栈帧就创建好了\n接下来执行 long a&#x3D;1  long b&#x3D;2：\n\n此时栈的状态变为：\n\n再调用add（）函数，对应汇编为：\n\n因为add（）函数有两个参数，所以调用前先把参数压住栈，注意入栈的顺序和参数顺序相反（函数参数的逆序存储）\n此时栈内状态变为：\n\n接下来进入add（）函数内部，分析整个函数的调用过程\n返回地址：执行call命令进入函数前，CPU会把函数的返回地址压住栈，用作函数执行完后的返回地址，当执行完call命令后，栈的状态为：\n\n接下来开始执行add（）函数，并形成add（）函数的栈帧：\n\n栈的状态变为：\n\nadd（）函数内部有两个局部变量，并用两个形参为其赋初值，汇编如下：\n\n此时栈的状态变为：\n\n再就是执行add的运算了\n先将x的值传给EAX，再将y的值与EAX相加并保存在EAX里。\n函数执行完毕，开始删除add（）的栈帧\n\n\n再执行retn指令，存储在栈中的返回地址也出栈，此时栈完全恢复到调用add函数前的状态。所以，不管有多少函数嵌套调用，利用栈帧都可以很好的维护\n现在，程序执行流重新返回到main（）函数里\n\n之后就没什么了，清除main函数的栈帧，程序结束\n函数调用约定cdecl源代码：\n#include &lt;stdio.h&gt;int add(int a,int b)&#123;    return a+b;&#125;int main(int argc,char* argv[])&#123;\treturn add(1,2);&#125;\n\n动调发现：add函数1，2以逆序方式压入栈，之后使用add esp，8清理栈，这样的方式就是cdecl\n\n好处：可以像c语言的printf函数一样，向被调用函数中传入多个参数，这种长度可变的参数在其他两种调用方式中很难实现\nstdcall栈的清理工作由add（）函数的最后 RENT 8实现，含义为RENT+POP 8字节，及返回后使ESP增加到指定大小\n\n像这样在被调用者add（）函数内部清理栈的方式即为stdall方式。\n好处：\nfastcall使用寄存器而非栈内存来传递参数\n\n第二章","categories":["网安"],"tags":["逆向"]},{"title":"逆向扫雷游戏","url":"/2022/03/13/%E9%80%86%E5%90%91%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/","content":"一.注入代码1.ollydbg打开扫雷，多按几次f9，然后打开window视窗（可以在view–windows打开，也可以直接点那个w）\n2.之后右键-&gt;Follow ClassProc。这个就是窗口的处理函数，这样就定位到了窗口的处理函数，此时就是断在了该函数的起始位置：01001BC9，如图：\n\n插个基础知识：windows的窗口处理函数：WindowProc（）：LRESULT CALLBACK WindowProc ( HWND hWnd, \t\t\t\t\t\tUINT uMsg,\t\t\t\t\t\tWPARAM wParam, \t\t\t\t\t\tLParam);参数的意义如下：HWND hWnd : 事件引起消息发生的那个窗口。（窗口的句柄）UINT message: 消息的ID,它是32位值，指明了消息类型。（消息id）WPARAM wParam : 32位值，包含附加信息，决定于消息的种类。例如键盘的哪个键代码。LPARAM lParam: 32位值，同上。例如，前16位＝重复数                                      接着8位：扫描码（决定于厂家）                                      第24位：为1时表示扩展键。                                      第25到28位：保留区                                      第29位为1时＝alt按下，否则为0。                                      第30位为1时＝消息前按下，否则为0。                                      第31位为1时＝正在被释放，否则为0。    当点击菜单的时候，WindowProc会被系统调用,uMsg     赋值为：WM_COMMANDwParam   赋值为：对应菜单的id（我们要分析的数据）再插一句：这个WM_COMMAND就是当用户从菜单中选择命令项、控件将通知消息发送到其父窗口或翻译快捷键击时发送的参数。\n\n3.接下来看点菜单栏里：“初级”“中级”“高级”时菜单的id是什么，（即要找第三个参数，第二个入栈）\n在WindowProc函数处下条件断点：uMsg&#x3D;&#x3D;WM_COMMAND时\n在[arg.4]参数处右键-&gt;breakpoint-&gt;conditional（条件断点），条件填写：edx&#x3D;&#x3D;WM_COMMAND。因为第二个参数就是把参数传给了edx，所以左边是edx。\n这个就是对运行到这里是不一定会断，只有满足条件也可以断下来，进行了筛选\n试验：在切换初级，中级，高级时候成功在断点处断下（只有在点击菜单时才是WM_COMMAND消息），而运行其他消息指令是不会断的\n此时可以分析出点击菜单时，传入函数的四个参数的值：\n在栈窗口观察，利用ebp偏移看，右键地址-&gt;address-&gt;relative to ebp\n初级菜单id：0x209\n可以看到第二个参数值是0x111，连着的这四个就是传入的四个参数\n\n同理观察到：中级菜单id：0x20A   ，  高级菜单id：0x20B\n4.注入代码：\n模拟函数调用，传递四个参数：\npush 0push 0x20bpush 0x111push 230526call 01001bc9\n\n如图：\n这个效果就是可以不断变换第二个参数的值来操作扫雷的菜单\n将这个过程利用mfc实现：\n先添加给button，代码也简单，如下：\nvoid C扫雷Dlg::OnBnClickedButton1()&#123;\t// TODO: 在此添加控件通知处理程序代码\tHWND hWnd = ::FindWindow(NULL, _T(&quot;扫雷&quot;));//按照窗口名称找句柄\tif (hWnd == NULL)\t&#123;\t\t::MessageBox(NULL, _T(&quot;扫雷游戏未打开&quot;), _T(&quot;错误&quot;), MB_OK);\t\treturn;\t&#125;\t::SendMessage(hWnd, WM_COMMAND, 0x209, 0);&#125;\n\n二.分析游戏基地址1.基地址的概念\n全局变量，字符常量的地址一般都是基地址，查找和验证基地址\n\n使用CE内存查找工具查找数据地址\n\n1.首次先让要查找的数据稳定在一个范围或者精确的值（使用CE的首次搜索）\n2.改变要查找的数据，根据变化再筛选出数据的地址\n\n使用OD验证是否是基地址，通过内存断点的方式来验证\n\n内存断点：如果检测到对该内存有读或写的操作就会断下来\nadd  dowrd ptr[1005194]  eax  这种立即数寻址一般就是基地址\n三.使用CE扫描具体实现现在目标是查找雷区的内存\n猜想:雷区在内存中以一个二维数组形式存放\n先选”未知的初始值”,首次扫描,接着不断变换雷区的首元素,（注意，这里不可以搜索“确定的值”，因为即使显示“1”，在内存中的存储可不一定，卡了我10分钟）按照”未变动”或者是”变动”不断缩小范围,最后可以锁定雷区的首元素地址(01005361),右键(browse this memory region)查看该地址对应内存\n各数据意义随便再点点,发现41对应1,42对应2……8f对应雷,雷区每行以01结尾\n此时就可以达到作弊效果了,但是没有实现自动化\n四.实现自动扫雷（利用mfc实现）准备工作因为有初级，中级等不同模式，所以为了做出一个通用的…，要找雷区的宽和高所在地址，继续使用CE查找，步骤同上。\n雷区数据基地址  0x1005361宽的基地址   0x1005334高的基地址   0x1005338\n\n在实现自动化之前，先来一个小目标练练手：\n读取当前的雷数：\nvoid C扫雷Dlg::OnBnClickedButton5()&#123;\t// TODO: 在此添加控件通知处理程序代码\tDWORD pid;\tHWND hWnd = ::FindWindow(NULL, _T(&quot;扫雷&quot;));//按照窗口名称找窗口句柄\tif (hWnd == NULL)\t&#123;\t\t::MessageBox(NULL, _T(&quot;扫雷游戏未打开&quot;), _T(&quot;错误&quot;), MB_OK);\t\treturn;\t&#125;\tGetWindowThreadProcessId(hWnd, &amp;pid);//通过窗口句柄拿到进程id\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);//通过进程id拿到进程句柄\tReadProcessMemory(hProcess, (LPCVOID)0x1005194, &amp;m_editbase, sizeof(m_editbase), &amp;pid);//写入\tUpdateData(FALSE);&#125;\n\n解释：核心函数是ReadProcessMemory（），传入的参数：进程句柄，要读取数据的起始地址，存放数据的缓存区地址，要读取的字节数，实际读取数存放地址。\n\n为了找到进程句柄，需要OpenProcess（）这个函数，它通过进程id来找\n为了找到进程id，需要GetWindowThreadProcessId（），它通过窗口句柄找\n为了找到窗口句柄，需要FindWindow（）函数，它通过窗口名称来找\n窗口名称每次运行都不会变，就是“扫雷”嘛\n\n效果如图：\n正式实现接下来，试着把雷区打印出来：\nvoid C扫雷Dlg::OnBnClickedButton6()&#123;\t// TODO: 在此添加控件通知处理程序代码\tDWORD pid;\tHWND hWnd = ::FindWindow(NULL, _T(&quot;扫雷&quot;));//按照窗口名称找窗口句柄\tif (hWnd == NULL)\t&#123;\t\t::MessageBox(NULL, _T(&quot;扫雷游戏未打开&quot;), _T(&quot;错误&quot;), MB_OK);\t\treturn;\t&#125;\tGetWindowThreadProcessId(hWnd, &amp;pid);//通过窗口句柄拿到进程id\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);//通过进程id拿到进程句柄\t//雷区数据基地址  0x1005361\t//宽的基地址   0x1005334\t//高的基地址   0x1005338\t//0x8f是雷\t\tunsigned char gamedata[24][32] = &#123; 0 &#125;;\tif (!ReadProcessMemory(hProcess, (LPCVOID)0x01005361, &amp;gamedata, 32 * 24, &amp;pid))\t&#123;\t\t::MessageBox(NULL, _T(&quot;读取扫雷游戏进程失败&quot;), _T(&quot;错误&quot;), MB_OK);\t\treturn;\t&#125;        //以上这些和准备工作里的是一样的        \tDWORD dwHight = 0;//根据模式的不同，选择对应的高\tm_strshowdata.Empty();//再次输出清空原来的\tif (!ReadProcessMemory(hProcess, (LPCVOID)0x01005338, &amp;dwHight, sizeof(dwHight), &amp;pid))//读取高\t&#123;\t\t::MessageBox(NULL, _T(&quot;读取扫雷游戏进程失败&quot;), _T(&quot;错误&quot;), MB_OK);\t\treturn;\t&#125;\tCString strTemp = _T(&quot;&quot;);//中间变量\tshort gamex = 0x13;//这里的坐标是利用vs自带的spy++一点点对应出来的，有点难受\tshort gamey = 0x59;\t\tfor (int i = 0; i &lt; dwHight; ++i)\t&#123;\t\tfor (int j = 0; j &lt; 32; ++j)//这里不用选择是因为遇到0x10就break\t\t&#123;\t\t\tif (0x10 == gamedata[i][j])\t\t\t&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\tstrTemp.Format(_T(&quot;%02X &quot;), gamedata[i][j]);\t\t\tm_strshowdata += strTemp;\t\t&#125;\t\tm_strshowdata += _T(&quot;\\r\\n&quot;);//换行\t&#125;\tUpdateData(FALSE);&#125;\n\n效果如图：\n其中8F对应的就是雷\n在此基础上就可以实现自动化了，原理就是模拟鼠标点击消息发送给扫雷程序\n增加的代码：\nunsigned short xypos[2] = &#123; 0 &#125;;//偏移量xypos[0] = gamex + j * 0x18;xypos[1] = gamey + i * 0x18;if (0x8F != gamedata[i][j])&#123;              //发送消息（根据spy++钩取的消息，模拟真实的点击消息，利用坐标来控制点击位置）\t::PostMessage(hWnd, WM_LBUTTONDOWN,MK_LBUTTON,*(int*)xypos);\t::PostMessage(hWnd, WM_LBUTTONUP,0, *(int*)xypos);\t\t\t\t&#125;\n\n附上最后的完整代码：\nvoid C扫雷Dlg::OnBnClickedButton6()&#123;\t// TODO: 在此添加控件通知处理程序代码\tDWORD pid;\tHWND hWnd = ::FindWindow(NULL, _T(&quot;扫雷&quot;));//按照窗口名称找窗口句柄\tif (hWnd == NULL)\t&#123;\t\t::MessageBox(NULL, _T(&quot;扫雷游戏未打开&quot;), _T(&quot;错误&quot;), MB_OK);\t\treturn;\t&#125;\tGetWindowThreadProcessId(hWnd, &amp;pid);//通过窗口句柄拿到进程id\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);//通过进程id拿到进程句柄\t//雷区数据基地址  0x1005361\t//宽的基地址   0x1005334\t//高的基地址   0x1005338\t//0x8f是雷\t//距离为16（大概）\tunsigned char gamedata[24][32] = &#123; 0 &#125;;\tif (!ReadProcessMemory(hProcess, (LPCVOID)0x01005361, &amp;gamedata, 32 * 24, &amp;pid))\t&#123;\t\t::MessageBox(NULL, _T(&quot;读取扫雷游戏进程失败&quot;), _T(&quot;错误&quot;), MB_OK);\t\treturn;\t&#125;\tDWORD dwHight = 0;\tm_strshowdata.Empty();\tif (!ReadProcessMemory(hProcess, (LPCVOID)0x01005338, &amp;dwHight, sizeof(dwHight), &amp;pid))//读取高\t&#123;\t\t::MessageBox(NULL, _T(&quot;读取扫雷游戏进程失败&quot;), _T(&quot;错误&quot;), MB_OK);\t\treturn;\t&#125;\tCString strTemp = _T(&quot;&quot;);\tshort gamex = 0x13;\tshort gamey = 0x59;\tunsigned short xypos[2] = &#123; 0 &#125;;\tfor (int i = 0; i &lt; dwHight; ++i)\t&#123;\t\tfor (int j = 0; j &lt; 32; ++j)\t\t&#123;\t\t\tif (0x10 == gamedata[i][j])\t\t\t&#123;\t\t\t\tbreak;\t\t\t&#125;\t\t\txypos[0] = gamex + j * 0x18;\t\t\txypos[1] = gamey + i * 0x18;\t\t\tif (0x8F != gamedata[i][j])\t\t\t&#123;\t\t\t\t//::PostMessage(hWnd, WM_LBUTTONDOWN,MK_LBUTTON,*(int*)xypos);\t\t\t\t//::PostMessage(hWnd, WM_LBUTTONUP,0, *(int*)xypos);\t\t\t\t\t\t\t&#125;\t\t\tstrTemp.Format(_T(&quot;%02X &quot;), gamedata[i][j]);\t\t\tm_strshowdata += strTemp;\t\t&#125;\t\tm_strshowdata += _T(&quot;\\r\\n&quot;);\t&#125;\tUpdateData(FALSE);&#125;\n\n效果展示：\n完毕！\n","categories":["网安"],"tags":["逆向"]},{"title":"windows/win32编程","url":"/2023/03/20/win32%E7%BC%96%E7%A8%8B/","content":"本文参考：https://www.bilibili.com/video/BV1pB4y187VB/?spm_id_from=333.337.search-card.all.click\n(43条消息) 【Win32】初识Win32编程_半生瓜のblog的博客-CSDN博客\nWindows编程应用程序分类控制台程序ConsoleDOS程序，本身没有窗口，通过Windows DOS窗口执行。(DOS是操作系统预留的)\n窗口程序拥有自己的窗口，可以与用户交互。\n库程序存放代码、数据的程序、执行文件可以从中取出代码执行和获取数据静态库程序:扩展名LIB,在编译链接程序时，将代码放入到执行文件中。动态库程序：扩展名DLL，在执行文件时从中获取代码 。静态库中的代码是直接嵌入到你的项目中，而动态库中的内容是通过地址来找到。\n静态库程序无法执行，也就是说它最终生成的文件无法进入内存。动态库程序有入口函数，可以执行。但是它不能独立运行。谁调动态库里面的东西，它就依附于谁。\n应用程序对比入口函数\n控制台程序-main\n窗口程序-WinMain\n动态库程序-DllMain\n静态库程序-无入口函数\n\n文件存在方式\n控制台程序、窗口程序-EXE文件\n动态库程序-DLL文件\n静态库程序-LIB文件\n\n相关函数int WINAPI wWinMain(    HINSTANCE hInstance,//当前程序的实例句柄，找到你当前进程所占据的那块内存    HINSTANCE hPrevInstance,//当前程序前一个示例句柄，废弃了    PWSTR pCmdLine, //命令行参数字符串    int nCmdShow//窗口的显示方式);\n\n\n\n暂时可以将句柄理解成，句柄是用来找到内存的东西，但绝对不是指针。\nint MessageBox(  [in, optional] HWND    hWnd,//父窗口句柄  [in, optional] LPCTSTR lpText,//显示在消息框中的文字  [in, optional] LPCTSTR lpCaption,//显示在标题栏中的文字  [in]           UINT    uType//消息框中的按钮、图标显示了类型);//返回点击的按钮ID//能够将程序暂停在这里，说明它是个阻塞函数。它执行，可能不会立即返回。\n\n\n\n窗口创建过程\n定义WinMain函数\n定义窗口的处理函数(自定义，消息处理)\n注册窗口类(向操作系统中写入一些数据)\n创建窗口(内存中创建窗口)\n显示窗口(绘制窗口的图像)\n消息循环(获取&#x2F;翻译&#x2F;派发消息)\n消息处理\n\n第一个windows窗口#include&lt;windows.h&gt;//窗口处理函数（自定义、处理消息）LRESULT CALLBACK WndProc(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)&#123;\treturn DefWindowProc(hWnd, msgID, wParam, lParam);&#125;//入口函数int CALLBACK WinMain(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, int nCmdShow)&#123;\t//注册窗口类\tWNDCLASS wc = &#123; 0 &#125;;\t//申请两种不用的缓冲区\twc.cbClsExtra = 0;\twc.cbWndExtra = 0;\twc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);\twc.hCursor = NULL;\twc.hIcon = NULL;\twc.hInstance = hIns;\twc.lpfnWndProc = WndProc;\twc.lpszClassName = &quot;myWindow&quot;;\twc.lpszMenuName = NULL;\twc.style = CS_HREDRAW | CS_VREDRAW;\t//将上面赋的这些值全部写入操作系统\tRegisterClass(&amp;wc);\t\t//在内存中创建窗口\tHWND hWnd = CreateWindow(&quot;myWindow&quot;, &quot;menu&quot;, WS_OVERLAPPEDWINDOW, 100, 100, 500, 500, NULL, NULL, hIns, NULL);\t//显示窗口\tShowWindow(hWnd, SW_SHOW);\t//再画一遍(刷新窗口)\tUpdateWindow(hWnd);\t//消息循环\tMSG nMsg = &#123; 0 &#125;;\twhile (GetMessage(&amp;nMsg,NULL,0,0))\t&#123;\t\tTranslateMessage(&amp;nMsg);\t\tDispatchMessage(&amp;nMsg);//将消息交给窗口处理函数来处理\t\t&#125;\t\treturn 0;&#125;\n\n窗口有无与进程退不退没有关系。\n注册窗口类窗口类的概念\n窗口类是包含了窗口的各种参数信息的数据结构。\n\n每个窗口都具有窗口类，基于窗口类创建窗口。\n\n每个窗口类都具有一个名称，使用前必须注册到系统。\n\n在操作系统内核里存着就叫窗口类，在程序里存着就叫窗口类。\n\n\n窗口类的分类：系统窗口类系统已经定义好的窗口类，所有应用程序都可以直接使用。不需要注册，直接使用窗口类即可。系统已经注册好了。例如:按钮-BUTTON,编辑框-EDIT\n应用程序全局窗口类由用户自己定义，当前应用程序所有模块都可以使用。应用程序局部窗口类由用户自己定义，当前应用程序中本模块可以直接使用。\n全局及局部窗口类 ：注册窗口类的函数\n(ATOM——unsigned short)ATOM RegisterClass( CONST WNDCLASS *lpWndClass//窗口类的数据);//注册成功后 ，返回一个数字标识。(0失败，非0成功。)\n\n\n\nstyle窗口类风格应用程序全局窗口类的注册，需要在窗口类的风格中添加CS_GLOBALCLASS。\n应用程序局部类窗口类注册，无需添加如上风格。\n不建议使用全局窗口类——因为局部窗口类能完成全局窗口类的功能，并且全局窗口类可能会产生冗余。\nCS_HREDRAW ——当窗口水平变化时，窗口重新绘制CS_VREDRAW ——当窗口垂直变化时，窗口重新绘制CS_DBLCLKS ——允许窗口接收鼠标双击CS_NOCLOSE ——窗口没有关闭按钮\n\n\n\n窗口创建窗口创建CreateWindow &#x2F; CreateWindowEx\nCreateWindow内部是如何实现的\n系统(CreateWindows函数内部)根据传入的窗口类名称，在应用程序局部窗口类中查找，如果找到执行2 ，没找到执行3。比较局部窗口与创建窗口时传入的HINSTANCE变量。如果有发现相等。创建和注册类在同一模块，创建窗口返回。如果不相等，继续执行3。在应用程序全局窗口类，如果找到，执行4， 没找到执行5。使用找到的窗口类信息，创建窗口返回。在系统窗口类中查找，如果找到创建窗口返回，否则创建窗口失败。\n#include&lt;windows.h&gt;//窗口处理函数（自定义、处理消息）LRESULT CALLBACK WndProc(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)&#123;\tswitch (msgID)\t&#123;\tcase WM_DESTROY:\t\tPostQuitMessage(0);\t\tbreak;\tdefault:\t\tbreak;\t&#125;\treturn DefWindowProc(hWnd, msgID, wParam, lParam);&#125;//入口函数int CALLBACK WinMain(HINSTANCE hIns, HINSTANCE hPerIns, LPSTR lpCmdLine, int nCmdShow)&#123;\t//注册窗口类\tWNDCLASS wc = &#123; 0 &#125;;\t//申请两种不用的缓冲区\twc.cbClsExtra = 0;\twc.cbWndExtra = 0;\t\twc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);\twc.hCursor = NULL;\twc.hIcon = NULL;\twc.hInstance = hIns;\twc.lpfnWndProc = WndProc;\twc.lpszClassName = &quot;myWindow&quot;;\twc.lpszMenuName = NULL;\twc.style = CS_HREDRAW | CS_VREDRAW;\t//将上面赋的这些值全部写入操作系统\tRegisterClass(&amp;wc);\t\t//在内存中创建窗口\tHWND hWnd = CreateWindow(&quot;myWindow&quot;, &quot;menu&quot;, WS_OVERLAPPEDWINDOW, 100, 100, 500, 500, NULL, NULL, hIns, NULL);\t//显示窗口\tShowWindow(hWnd, SW_SHOW);\t//再画一遍(刷新窗口)\tUpdateWindow(hWnd);\t//消息循环\tMSG nMsg = &#123; 0 &#125;;\twhile (GetMessage(&amp;nMsg, NULL, 0, 0))\t&#123;\t\tTranslateMessage(&amp;nMsg);\t\tDispatchMessage(&amp;nMsg);//将消息交给窗口处理函数来处理\t\t&#125;\t\treturn 0;&#125;\n\n\n\n子窗口创建过程创建时要设置父窗口句柄创建风格要增加WS_CHILD | WS_VISBLE(根据注册的窗口类，来创建多个窗口。)\nHWND hChild1 = CreateWindowEx(0, &quot;Child&quot;, &quot;C1&quot;, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, 0, 0, 200, 200, hWnd, NULL, hIns, NULL);HWND hChild2 = CreateWindowEx(0, &quot;Child&quot;, &quot;C2&quot;, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW, 200, 0, 200, 200, hWnd, NULL, hIns, NULL);\n\n\n\n消息基础消息的概念和作用消息组成(windows平台下)\n​\t窗口句柄\n​\t消息ID\n​\t消息的两个参数(两个附带信息)\n​\t消息产生的时间\n​\t消息产生时的鼠标位置\n\n消息的作用当系统通知窗口工作时，就采用消息的方式(DispatchMessage)派发给(调用)窗口的窗口处理函数(将MSG的前四个信息传递给消息处理函数)。每一个窗口都有窗口处理函数\nMSG结构体接收消息结构体定义如下:\n//对应解释同上消息组成typedef struct tagMSG &#123;    HWND        hwnd;    UINT        message;    WPARAM      wParam;    LPARAM      lParam;    DWORD       time;    POINT       pt;#ifdef _MAC    DWORD       lPrivate;#endif&#125; MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;\n\n\n\nDispatchMessage如何找到窗口处理函数nMsg.hwnd-&gt;保存窗口数据的内存-&gt;找到对应的窗口处理函数-&gt;WndProc回到你自己定义的消息处理函数-&gt;传递参数-&gt;处理消息LRESULT CALLBACK WndProc(HWND hWnd, UINT msgID, WPARAM wParam, LPARAM lParam)传递这四个参数，不用关系后两个\n\n\n\n\n\n窗口处理函数每个窗口都必需有窗口处理函数，只要基于窗口类创建窗口，就肯定要有个窗口处理函数。\n窗口处理依照如下结构定义：\nLRESULT CALLBACK WindowProc(\tHWND hWnd;//窗口句柄\tUINT uMsg;//消息ID\tWPARAM wParam;//消息参数\tLPARAM lParam;//消息参数   \t);\n\n\n当系统通知窗口时，(DispatchMessage)会调用窗口处理函数，同时将消息ID和消息参数传递给窗口处理函数。\n在窗口处理函数中，不处理的消息，使用缺省窗口处理函数。\n例如:DefWindowProc(可以给各种消息做默认处理)。\n消息循环中的相关函数(浅谈)GetMessage-到系统的某个地方抓本进程的消息\n函数原型如下:\nBOOL GetMessage(\tLPMSG lpMsg,//存放获取到消息的BUFF，    HWND hWndp;//窗口句柄，要是定为NULL，将会抓取本进程中所有窗口中的消息    UNIT wMsgFilterMin,//获取的最小ID    UNIT wMsgFilterMax//获取消息的最大ID    //最后两个参数都为0，就是不管ID有多大，只要是本进程的消息都抓过来);\n\n\n其中后三个参数可以限制抓取消息的范围，如果设置为NULL,0,0那其实就是没有进行限制，只要是本进程的消息我都把它抓过来。\nGetMessage的返回值\n消息WM_QUIT会使GetMessage返回0，从而中终止消息接收。\nPostQuitMessage(0);会在进程中扔出WM_QUIT这个消息，get后从而使得消息循环终止。\nTranslateMessage-翻译消息——它可不是什么消息都翻译。\n将按键(可见字符按键，a~z)消息翻译成字符消息。\n所以进入到它的内部， 它所做的第一件事就是检查这个消息是否合法，是否是它要翻译的消息类型。\n如果不是按键类型消息，不做任何处理，继续执行。\n函数原型如下:\nBOOL TranslateMessage&#123;    CONST  MSG* lpMsg;//要翻译的消息地址\t&#125;\n\n\nDispatchMessage-派发消息(调用对应窗口的消息处理函数)\n函数原型如下\nLRESULT DispatchMessage(\tCONST MSG* lpmsg//要派发的消息);\n\n常见消息WM_DESTORY产生时间:窗口被销毁时产生附带信息:wParam:为0，lParam:为0一般用法:常用于在窗口被销毁前，做相应的善后处理，例如资源、内存等(该回收回收，该释放释放。)。\nWM_SYSCOMMAND产生时间：当点击窗口最大化，最小化，关闭等。附带信息:wParam:具体点击的位置，例如关闭SC_CLOSE等，lParam:鼠标光标的位置(这个不重要，我们只需要知道点没点就行，具体在哪个位置其实无所谓(具体情况具体使用))，LOWORD(lParam);水平位置，HIWORD(lParam)；垂直位置。(高两字节传纵坐标，低两字节传横坐标。)一般用法:常用在窗口关闭时，提示用户处理。\nWM_CREATE产生时间:在窗口创建成功但还没显示时。附带信息:wParam:为0lParam:为CREATESTRUCT类型的指针(强转成这个类型再用)，通过这个指针可以获取CreatWindowEx中全部12个参数的信息。一般用法：常用于初始化窗口函数、资源等等，包括创建子窗口等。\nWM_SIZE产生时间:在窗口的大小发生变化后。附带信息:wParam:窗口大小变化的原因。lParam:窗口变化后的大小LOWORD(lParam)变化后的宽度HIWORD(lParam)变化后的高度一般用法:常用于窗口大小发生变化后，调整窗口内各个部分的布局。\nWM_QUIT产生时间:程序员发送。附带信息:wPram:PostQuitmessage函数传递的参数。lParam：0。一般用法:用于结束消息循环，当GetMessage收到这个消息后，会返回FALSE,结束while处理，退出消息循环。这个消息不用我们去处理,进不去我们定义的窗口处理函数,GetMessage()返回了0，无法进入循环获取消息。\n消息循环的原理消息循环的阻塞GetMessage-从系统获取消息，将消息从系统中移除，阻塞函数。当系统无消息时，会等候下一条消息。对人来说消息是一直存在的，但是对于CPU来说(速度接近光速)，消息不是经常有的，所以会经常发生阻塞。这样程序的效率就不高，从而引出下面这个函数。\nPeekMessage-以查看的方式从系统中获取消息，可以不将消息从系统出移除，非阻塞函数。当系统无消息时，返回FALSE,继续执行后续代码。函数原型如下:\n(前四个参数同GetMessage)\n最后一个参数是，是否赋予它抓取消息的能力，一般是不给它的，也就是填写\nBOOL PeekMessageA(  [out]          LPMSG lpMsg,  [in, optional] HWND  hWnd,  [in]           UINT  wMsgFilterMin,  [in]           UINT  wMsgFilterMax,  [in]           UINT  wRemoveMsg);\n\n\n也就是说，更好的流程是，先派PeekMessage去侦查是否有消息，有就告诉GetMessage让它来处 理。没有就不要派Get去了，因为它会一直在那里等着消息的出现。\n例如：\nwhile (1)\t&#123;\t\tif (PeekMessage(&amp;nMsg, NULL, 0, 0, PM_NOREMOVE))\t\t&#123;\t\t\t//有消息-判断是否是WM_QUIT\t\t\tif (GetMessage(&amp;nMsg, NULL, 0, 0))\t\t\t&#123;\t\t\t\tTranslateMessage(&amp;nMsg);\t\t\t\tDispatchMessage(&amp;nMsg);\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\treturn 0;\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123;\t\t\t//没有消息——空闲处理\t\t\tWriteConsole(g_HOUTPUT, &quot;空闲ing\\n&quot;, strlen(&quot;空闲ing&quot;), NULL, NULL);\t\t&#125;\t&#125;\n\n发送消息Windows平台上的消息，都是它们两个造出来的。\nSendMessage-发送消息，会等候消息处理的结果。PostMessage-投递消息，消息发出后立刻返回，不等候消息执行结果。函数原型如下：\nLRESULT SendMessage(  [in] HWND   hWnd,//消息发送的目的创建  [in] UINT   Msg,//消息ID  [in] WPARAM wParam,//消息参数  [in] LPARAM lParam//消息参数);\n\n\n这四个参数就是一个消息的前四个参数，剩下的两个参数函数内部以某种手段自加来获取。\n消息分类系统消息-ID范围0~0x03FF由系统定义好的消息，可以在程序中直接使用。程序员只负责一头，要么发送不用处理，要么处理不用发送。用户自定义的消息-ID范围0x0400(WM_USER) - 0x7FFF(31743)由用户自己定义，满足用户自己的需求。由用户自己发出消息，并响应处理。由程序员，自己定制，自己发送，自己处理。自定义消息宏：WM_USER(叫什么都行)例如:\n定义消息名称\n#define WM_MYMESSAGE WM_USER+1001\n\n\n发送,在哪发都可以,附加消息，你自己的，附加什么都行。\nPostMessage&#x2F;SendMessage(hWnd, WM_MYMESSAGE, 1, 2);\n消息队列消息队列的概念\n消息队列是用于存放消息的队列。\n消息在队列中先进先出。\n所有窗口都具有消息队列。\n程序(GetMessage())可以从队列中获取消息。\n\n静态库Windows上静态库和Linux上的静态库在原理上没有任何区别，都是封装一堆东西等着别人去掉。\n静态库的特点运行不存在。没有如何，不能执行，生成的文件无法形成静态影像，无法进内存。静态库源码被链接到调用程序中。目标程序的归档。\nC语言静态库C静态库的创建创建一个静态库程序。添加库程序，源文件使用C文件。\nC静态库的使用库路径设置:可以使用#pragma关键字设置#pragma comment(lib,“…&#x2F;lib&#x2F;clib.lib”)\nC++静态库C++静态库的创建创建一个静态库项目添加库程序，源文件使用CPP文件。\nC++静态库的使用库路径设置:可以使用pragma关键字设置#pragma comment(lib,“…&#x2F;xx&#x2F;xxx.lib”)示例：\n#include&lt;iostream&gt;using namespace std;//给编译器看int CLIB_add(int add1, int add2);int CLIB_sub(int add1, int add2);//给链接器看#pragma comment(lib,&quot;../Debug/CPPLIB.lib&quot;)int main(void)&#123;\tcout &lt;&lt; CLIB_add(5, 2) &lt;&lt; endl;\tcout &lt;&lt; CLIB_sub(5, 2) &lt;&lt; endl;\treturn 0;&#125;\n\n\n\n动态库","categories":["开发"],"tags":["windows"]},{"title":"nkctf  逆向wp","url":"/2022/03/27/nkctf/","content":"PMKF可以看到一开始在c盘下创建一个nk.ctf文件（我当时做的时候并没有看到，只是静调做的）\n\n主代码：\nint sub_9B1090()&#123;  int v1; // [esp+20h] [ebp-140h]  int v2; // [esp+24h] [ebp-13Ch]  int k; // [esp+2Ch] [ebp-134h]  int i; // [esp+30h] [ebp-130h]  int v5; // [esp+30h] [ebp-130h]  int j; // [esp+30h] [ebp-130h]  int v7; // [esp+30h] [ebp-130h]  char v8; // [esp+34h] [ebp-12Ch]  DWORD NumberOfBytesRead; // [esp+3Ch] [ebp-124h] BYREF  unsigned __int8 Buffer; // [esp+43h] [ebp-11Dh] BYREF  char v11[16]; // [esp+44h] [ebp-11Ch] BYREF  char v12[256]; // [esp+54h] [ebp-10Ch] BYREF  memset(v12, 0, sizeof(v12));  ReadFile(hObject, &amp;Buffer, 1u, &amp;NumberOfBytesRead, 0);  if ( Buffer != 5 )  &#123;    sub_9B1690(&quot;Wrong!\\n&quot;);    CloseHandle(hObject);    exit(0);  &#125;  ReadFile(hObject, v12, Buffer, &amp;NumberOfBytesRead, 0);  for ( i = 0; i &lt; Buffer; ++i )  &#123;    if ( v12[i] != byte_9B5100[i] )    &#123;      sub_9B1690(&quot;Wrong!\\n&quot;);      CloseHandle(hObject);      exit(0);    &#125;  &#125;  v5 = 0;  v8 = 0;  while ( v5 &lt; Buffer )    v8 += v12[v5++];  ReadFile(hObject, v11, 0x10u, &amp;NumberOfBytesRead, 0);  v2 = 18;  for ( j = 0; j &lt; 16; ++j )    v11[j] ^= v8;  v7 = 0;  v1 = 1;  while ( v7 &lt; 16 )  &#123;    for ( k = 6; k &gt;= 0; k -= 2 )    &#123;      switch ( ((unsigned __int8)v11[v7] &gt;&gt; k) &amp; 3 )      &#123;        case 0:          v2 -= 18;          break;        case 1:          ++v2;          break;        case 2:          v2 += 18;          break;        case 3:          --v2;          break;        default:          break;      &#125;      if ( aN[v2] == 42 || aN[v2] == 32 )      &#123;        v1 = 0;        break;      &#125;      if ( aN[v2] == 75 )      &#123;        sub_9B1690(&quot;Congratulations! you found it!\\n&quot;);        break;      &#125;    &#125;    ++v7;  &#125;  CloseHandle(hObject);  return v1;&#125;\n\n总体就是个迷宫题，先手动走走迷宫（复杂的话就上dfs，这个还好），得到路径：\n1,1,2,2,3,3,2,2,1,2,2,3,2,2,1,1,0,1,1,1,1,1,0,1,0,0,0,0,0,1,0,1,1,2,1,1,0,1,1,1,2,2,2,3,2,3,3,0,3,3,2,3,2,2,1,1,1,1,1,2,2,3,3,3 \n\n​\t官方题解是说这个就是输入值的四进制表示了，哼….看不出来\n一个字符控制四步，直接暴力跑：\n\n（好抽象的代码）\n跑出来的结果就是10进制下的步数。（杜师傅说有个地方是有两个解，我这个脚本出了结果就break了，导致没跑出第二个解，幸好flag用的是第一个解）\n最后交flag需要转16进制……（肯定是出题人没说明白），这个是要每个字符转成对应的16进制，我直接把这一串数字当成一个大数转了，导致一直提交失败\nnot_a_like010打开，发现是python打包的exe\n使用  PyInstaller Extractor   解包\n使用方法：\n\n安装\n\n下载v2.0版本的PyInstaller Extractor\ngithub: https://github.com/extremecoders-re/pyinstxtractor\n\n\n使用\n\n\n将需解包的exe与下载的pyinstxtractor.py存入同级文件夹\n\n\n\n使用命令行输入如下指令, 得到exe的解包文件夹.\n\npython pyinstxtractor.py &#123;exe路径&#125;示例: python pyinstxtractor.py CreatFoder.exe\n\n然后网上找个在线的pyc转py网站\n结果：\n# uncompyle6 version 3.9.0# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.6.12 (default, Feb  9 2021, 09:19:15) # [GCC 8.3.0]# Embedded file name: not_a_like.pyimport libnum, base64, hashlibfrom ctypes import *def encrypt(text):    data_xor_iv = bytearray()    sbox = []    j = 0    x = y = k = 0    key = &#x27;911dcd09ad021d68780e3efed1aa8549&#x27;    for i in range(256):        sbox.append(i)    else:        for i in range(256):            j = j + sbox[i] + ord(key[i % len(key)]) &amp; 255            sbox[i], sbox[j] = sbox[j], sbox[i]        else:            for idx in text:                x = x + 1 &amp; 255                y = y + sbox[x] &amp; 255                sbox[x], sbox[y] = sbox[y], sbox[x]                k = sbox[sbox[x] + sbox[y] &amp; 255]                data_xor_iv.append(idx ^ k)            else:                return data_xor_ivif __name__ == &#x27;__main__&#x27;:    flag = input(&#x27;请输入flag&gt; &#x27;)    pub_key = [19252067118061066631831653736874168743759225404757996498452383337816071866700225650384181012362739758314516273574942119597579042209488383895276825193118297972030907899188520426741919737573230050112614350868516818112742663713344658825493377512886311960823584992531185444207705213109184076273376878524090762327, 76230002233243117494160925838103007078059987783012242668154928419914737829063294895922280964326704163760912076151634681903538211391318232043295054505369037037489356790665952040424073700340441976087746298068796807069622346676856605244662923296325332812844754859450419515772460413762564695491785275009170060931]    m = libnum.s2n(flag)    c = str(pow(m, pub_key[0], pub_key[1]))#这个e挺大的    q = b&#x27;EeJWrgtF+5ue9MRiq7drUAFPtrLATlBZMBW2CdWHRN73Hek7DPVIYDHtMIAfTcYiEV87W7poChqpyUXYI3+/zf5yyDOyE9ARLfa5qilXggu60lmQzFqvFv+1uOaeI2hs2wx+QZtxqGZzC0VCVWvbTQ52nA2UdUtnk8VezRMPMfmf7rOqPxDTv/aacLnI3RdLG2TbT52qtN4+naejI7Xe8HLOL765OZKdDBERKwd5ARQ3UL6YPbuOKOQahIFddnIX6rZ7dTNqCUDOjfJbMdrzJVDNjmNlkLNtYFo7M65Wfwj6PV5vvtT33FsmH50/YLEasnlCiJujYOgi2KCdf5msz1dPEvrXDDL6Csnjo+6m/44RzlluzcqMS5ZJFdrHEh68LIqtu+HCO+69Dyq4e22APq8wgN9kU6R8kikXSn/Ej0N/jOvomFCbkHskRl8xP1KgWFW0SMVDlaDCM4EKG812VgDWgSYOUnVhVpz65uOtg4Z8PrPI+BW4398dQYhD24D9EIPgvtmhNrHiEHouB46ElTGQgZBhtn6y9tL1sw==&#x27;    v = encrypt(base64.b64encode(c.encode(&#x27;utf-8&#x27;)))    v = base64.b64encode(v)    if v == q:        print(&#x27;You are right!&#x27;)        input(&#x27;&#x27;)    else:        print(&#x27;winer winer winnie dinner&#x27;)        print(&#x27;Do you think the encryption and decryption are the same?&#x27;)\n\n大概加密流程就是先rsa加密，再转为base64进行rc4加密，与已知的q进行比较\nrsa解密：（已知e，n，c，求明文m）\n","categories":["网安"],"tags":["逆向"]},{"title":"angr","url":"/2022/04/07/angr/","content":"主要是记录一下这些脚本，真正理解暂时有点困难\n附上大佬的教程：https://github.com/ZERO-A-ONE/AngrCTF_FITM\n一.good：程序源码：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  signed int i; // [esp+1Ch] [ebp-1Ch]  char s1[9]; // [esp+23h] [ebp-15h]  unsigned int v6; // [esp+2Ch] [ebp-Ch]  v6 = __readgsdword(0x14u);  printf(&quot;Enter the password: &quot;);  __isoc99_scanf(&quot;%8s&quot;, s1);  for ( i = 0; i &lt;= 7; ++i )    s1[i] = complex_function(s1[i], i);  if ( !strcmp(s1, &quot;JACEJGCS&quot;) )    puts(&quot;Good Job.&quot;);  else    puts(&quot;Try again.&quot;);  return 0;&#125;\n\n使用Angr的步骤可以分为：\n\n创建 project\n设置 state\n新建符号量 : BVS (bitvector symbolic ) 或 BVV (bitvector value)\n把符号量设置到内存或者其他地方\n设置 Simulation Managers ， 进行路径探索的对象\n运行，探索满足路径需要的值\n约束求解，获取执行结果\n\nangr脚本：\nimport angrimport sysdef Go():    path_to_binary = &quot;./00_angr_find&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    initial_state = project.factory.entry_state()    simulation = project.factory.simgr(initial_state)    print_good_address = 0x8048678      simulation.explore(find=print_good_address)      if simulation.found:        solution_state = simulation.found[0]        solution = solution_state.posix.dumps(sys.stdin.fileno())        print(&quot;[+] Success! Solution is: &#123;&#125;&quot;.format(solution.decode(&quot;utf-8&quot;)))    else:        raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;:    Go()\n\n二.good_avoidangr脚本：\nimport angrimport sysdef Go():    path_to_binary = &quot;./01_angr_avoid&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    initial_state = project.factory.entry_state()    simulation = project.factory.simgr(initial_state)    avoid_me_address =   0x080485A8    maybe_good_address = 0x080485E0    simulation.explore(find=maybe_good_address, avoid=avoid_me_address)      if simulation.found:        solution_state = simulation.found[0]        solution = solution_state.posix.dumps(sys.stdin.fileno())        print(&quot;[+] Success! Solution is: &#123;&#125;&quot;.format(solution.decode(&quot;utf-8&quot;)))    else:        raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;:    Go()\n\n这个我试着跑了一下，挺成功的\n\n三.多个good或avoid程序源码：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  signed int i; // [esp+18h] [ebp-40h]  signed int j; // [esp+1Ch] [ebp-3Ch]  char s1[20]; // [esp+24h] [ebp-34h]  char s2[4]; // [esp+38h] [ebp-20h]  int v8; // [esp+3Ch] [ebp-1Ch]  unsigned int v9; // [esp+4Ch] [ebp-Ch]  v9 = __readgsdword(0x14u);  for ( i = 0; i &lt;= 19; ++i )    s2[i] = 0;  *(_DWORD *)s2 = 1381128278;  v8 = 1381320010;  printf(&quot;Enter the password: &quot;);  __isoc99_scanf(&quot;%8s&quot;, s1);  for ( j = 0; j &lt;= 7; ++j )    s1[j] = complex_function(s1[j], j + 8);  if ( !strcmp(s1, s2) )    puts(&quot;Good Job.&quot;);  else    puts(&quot;Try again.&quot;);  return 0;&#125;\n\nint __cdecl complex_function(signed int a1, int a2)&#123;  if ( a1 &lt;= 64 || a1 &gt; 90 )  &#123;    puts(&quot;Try again.&quot;);    exit(1);  &#125;  return (31 * a2 + a1 - 65) % 26 + 65;&#125;\n\nangr的exp\nimport angrimport sysdef Go():    path_to_binary = &quot;./02_angr_find_condition&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    initial_state = project.factory.entry_state()    simulation = project.factory.simgr(initial_state)    def is_successful(state):        stdout_output = state.posix.dumps(sys.stdout.fileno())        if b&#x27;Good Job.&#x27; in stdout_output:            return True        else:             return False    def should_abort(state):        stdout_output = state.posix.dumps(sys.stdout.fileno())        if b&#x27;Try again.&#x27; in  stdout_output:            return True        else:             return False    simulation.explore(find=is_successful, avoid=should_abort)      if simulation.found:        solution_state = simulation.found[0]        solution = solution_state.posix.dumps(sys.stdin.fileno())        print(&quot;[+] Success! Solution is: &#123;&#125;&quot;.format(solution.decode(&quot;utf-8&quot;)))    else:        raise Exception(&#x27;Could not find the solution&#x27;)    if __name__ == &quot;__main__&quot;:    Go()\n\n引用了两个函数可以动态的获取地址，而不是之前“写死”\n四.符号化寄存器程序源码：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // ebx  int v4; // eax  int v5; // edx  int v6; // ST1C_4  unsigned int v7; // ST14_4  unsigned int v9; // [esp+8h] [ebp-10h]  unsigned int v10; // [esp+Ch] [ebp-Ch]  printf(&quot;Enter the password: &quot;);  v4 = get_user_input();  v6 = v5;  v7 = complex_function_1(v4);  v9 = complex_function_2(v3);  v10 = complex_function_3(v6);  if ( v7 || v9 || v10 )    puts(&quot;Try again.&quot;);  else    puts(&quot;Good Job.&quot;);  return 0;&#125;int get_user_input()&#123;  int v1; // [esp+0h] [ebp-18h]  int v2; // [esp+4h] [ebp-14h]  int v3; // [esp+8h] [ebp-10h]  unsigned int v4; // [esp+Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  __isoc99_scanf(&quot;%x %x %x&quot;, &amp;v1, &amp;v2, &amp;v3);  return v1;&#125;\n\n\n\nangr的exp：\nimport angrimport sysimport claripydef Go():    path_to_binary = &quot;./03_angr_symbolic_registers&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    start_address = 0x08048980  #跳过get_user_input(),直接修改三个寄存器数据    initial_state = project.factory.blank_state(addr=start_address)    passwd_size_in_bits = 32    passwd0 = claripy.BVS(&#x27;passwd0&#x27;, passwd_size_in_bits)    passwd1 = claripy.BVS(&#x27;passwd1&#x27;, passwd_size_in_bits)    passwd2 = claripy.BVS(&#x27;passwd2&#x27;, passwd_size_in_bits)    initial_state.regs.eax = passwd0    initial_state.regs.ebx = passwd1    initial_state.regs.edx = passwd2        simulation = project.factory.simgr(initial_state)     def is_successful(state):        stdout_output = state.posix.dumps(sys.stdout.fileno())        if b&#x27;Good Job.\\n&#x27; in stdout_output:            return True        else:             return False    def should_abort(state):        stdout_output = state.posix.dumps(sys.stdout.fileno())        if b&#x27;Try again.\\n&#x27; in  stdout_output:            return True        else:             return False    simulation.explore(find=is_successful, avoid=should_abort)      if simulation.found:        for i in simulation.found:            solution_state = i            solution0 = format(solution_state.solver.eval(passwd0), &#x27;x&#x27;)            solution1 = format(solution_state.solver.eval(passwd1), &#x27;x&#x27;)            solution2 = format(solution_state.solver.eval(passwd2), &#x27;x&#x27;)            solution = solution0 + &quot; &quot; + solution1 + &quot; &quot; + solution2            print(&quot;[+] Success! Solution is: &#123;&#125;&quot;.format(solution))            # print(simgr.found[0].posix.dumps(0))    else:        raise Exception(&#x27;Could not find the solution&#x27;)    if __name__ == &quot;__main__&quot;:    Go()\n\n五.符号化栈应用情况就是函数在输入传参的时候是在栈上进行的\n如图：\n程序源码：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  printf(&quot;Enter the password: &quot;);  handle_user();  return 0;&#125;int handle_user()&#123;  int result; // eax  int v1; // [esp+8h] [ebp-10h]  int v2; // [esp+Ch] [ebp-Ch]  __isoc99_scanf(&quot;%u %u&quot;, &amp;v2, &amp;v1);  v2 = complex_function0(v2);  v1 = complex_function1(v1);  if ( v2 == 1999643857 &amp;&amp; v1 == -1136455217 )    result = puts(&quot;Good Job.&quot;);  else    result = puts(&quot;Try again.&quot;);  return result;&#125;\n\nangr的exp：\nimport angrimport sysimport claripydef Go():    path_to_binary = &quot;./04_angr_symbolic_stack&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    start_address = 0x8048697#还是跳过输入，直接从栈上符号化输入的参数    initial_state = project.factory.blank_state(addr=start_address)    initial_state.regs.ebp = initial_state.regs.esp#初始化，是esp和ebp相同     passwd_size_in_bits = 32    passwd0 = claripy.BVS(&#x27;passwd0&#x27;, passwd_size_in_bits)    passwd1 = claripy.BVS(&#x27;passwd1&#x27;, passwd_size_in_bits)    padding_length_in_bytes = 0x8#先抬高栈，以便在将符号值压入堆栈之前提供填充，但是栈是从高地址到低地址增长的，所以我们真正需要的是ESP - 0x8    initial_state.regs.esp -= padding_length_in_bytes        initial_state.stack_push(passwd0)      initial_state.stack_push(passwd1)     simulation = project.factory.simgr(initial_state)        def is_successful(state):        stdout_output = state.posix.dumps(1)        if b&#x27;Good Job.\\n&#x27; in stdout_output:            return True        else:             return False    def should_abort(state):        stdout_output = state.posix.dumps(1)        if b&#x27;Try again.\\n&#x27; in  stdout_output:            return True        else:             return False    simulation.explore(find=is_successful, avoid=should_abort)      if simulation.found:        for i in simulation.found:            solution_state = i            solution0 = (solution_state.solver.eval(passwd0))            solution1 = (solution_state.solver.eval(passwd1))            print(&quot;[+] Success! Solution is: &#123;0&#125; &#123;1&#125;&quot;.format(solution0, solution1))            #print(solution0, solution1)    else:        raise Exception(&#x27;Could not find the solution&#x27;)    if __name__ == &quot;__main__&quot;:    Go()\n\n六.符号化内存程序源码：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int i; // [esp+Ch] [ebp-Ch]  memset(user_input, 0, 0x21u);  printf(&quot;Enter the password: &quot;);  __isoc99_scanf(&quot;%8s %8s %8s %8s&quot;, user_input, &amp;unk_A1BA1C8, &amp;unk_A1BA1D0, &amp;unk_A1BA1D8);  for ( i = 0; i &lt;= 31; ++i )    *(_BYTE *)(i + 0xA1BA1C0) = complex_function(*(char *)(i + 0xA1BA1C0), i);// user_input = 0xA1BA1C0  if ( !strncmp(user_input, &quot;NJPURZPCDYEAXCSJZJMPSOMBFDDLHBVN&quot;, 0x20u) )// 用来比较s1和s2字符串的前n个字符    puts(&quot;Good Job.&quot;);  else    puts(&quot;Try again.&quot;);  return 0;&#125;\n\nuser_input()所处的地址：\n\n字符串分别位于以下地址[0xA1BA1C0, 0xA1BA1C8, 0xA1BA1D0, 0xA1BA1D8]\nangr的exp：\nimport angrimport sysimport claripydef Go():    path_to_binary = &quot;./05_angr_symbolic_memory&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    start_address = 0x8048601#跳过输入，直接去内存里符号化四个字符串    initial_state = project.factory.blank_state(addr=start_address)     passwd_size_in_bits = 64    passwd0 = claripy.BVS(&#x27;passwd0&#x27;, passwd_size_in_bits)    passwd1 = claripy.BVS(&#x27;passwd1&#x27;, passwd_size_in_bits)    passwd2 = claripy.BVS(&#x27;passwd2&#x27;, passwd_size_in_bits)    passwd3 = claripy.BVS(&#x27;passwd3&#x27;, passwd_size_in_bits)    passwd0_address = 0xA1BA1C0    #passwd1_address = 0xA1BA1C8    #passwd2_address = 0xA1BA1D0    #passwd3_address = 0xA1BA1D8    initial_state.memory.store(passwd0_address, passwd0)    initial_state.memory.store(passwd0_address + 0x8,  passwd1)    initial_state.memory.store(passwd0_address + 0x10, passwd2)    initial_state.memory.store(passwd0_address + 0x18, passwd3)    simulation = project.factory.simgr(initial_state)        def is_successful(state):        stdout_output = state.posix.dumps(1)        if b&#x27;Good Job.\\n&#x27; in stdout_output:            return True        else:             return False    def should_abort(state):        stdout_output = state.posix.dumps(1)        if b&#x27;Try again.\\n&#x27; in  stdout_output:            return True        else:             return False    simulation.explore(find=is_successful, avoid=should_abort)      if simulation.found:        for i in simulation.found:            solution_state = i            solution0 = solution_state.solver.eval(passwd0,cast_to=bytes)            solution1 = solution_state.solver.eval(passwd1,cast_to=bytes)            solution2 = solution_state.solver.eval(passwd2,cast_to=bytes)            solution3 = solution_state.solver.eval(passwd3,cast_to=bytes)            solution = solution0 + b&quot; &quot; + solution1 + b&quot; &quot; + solution2 + b&quot; &quot; + solution3            print(&quot;[+] Success! Solution is: &#123;&#125;&quot;.format(solution.decode(&quot;utf-8&quot;)))            #print(solution0, solution1, solution2, solution3)    else:        raise Exception(&#x27;Could not find the solution&#x27;)    if __name__ == &quot;__main__&quot;:    Go()\n\n七.符号化动态内存程序源码：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v3; // ebx  char *v4; // ebx  int v6; // [esp-10h] [ebp-1Ch]  signed int i; // [esp+0h] [ebp-Ch]  buffer0 = (char *)malloc(9u);  buffer1 = (char *)malloc(9u);  memset(buffer0, 0, 9u);  memset(buffer1, 0, 9u);  printf(&quot;Enter the password: &quot;);  __isoc99_scanf(&quot;%8s %8s&quot;, buffer0, buffer1, v6);  for ( i = 0; i &lt;= 7; ++i )  &#123;    v3 = &amp;buffer0[i];    *v3 = complex_function(buffer0[i], i);    v4 = &amp;buffer1[i];    *v4 = complex_function(buffer1[i], i + 32);  &#125;  if ( !strncmp(buffer0, &quot;UODXLZBI&quot;, 8u) &amp;&amp; !strncmp(buffer1, &quot;UAORRAYF&quot;, 8u) )    puts(&quot;Good Job.&quot;);  else    puts(&quot;Try again.&quot;);  free(buffer0);  free(buffer1);  return 0;&#125;\n\nangr的exp：\nimport angrimport sysimport claripydef Go():    path_to_binary = &quot;./06_angr_symbolic_dynamic_memory&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    start_address = 0x8048699 #跳过malloc和scanf    initial_state = project.factory.blank_state(addr=start_address)    passwd_size_in_bits = 64    passwd0 = claripy.BVS(&#x27;passwd0&#x27;, passwd_size_in_bits)    passwd1 = claripy.BVS(&#x27;passwd1&#x27;, passwd_size_in_bits)    fake_heap_address0 = 0xffffc93c#假地址    pointer_to_malloc_memory_address0 = 0xabcc8a4#malloc的buffer0地址    fake_heap_address1 = 0xffffc94c#假地址    pointer_to_malloc_memory_address1 = 0xabcc8ac#malloc的buffer1地址    initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness)    initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness)        #这里总的逻辑是这样的，之前是buffer指向的是malloc分配好的内存地址，string存在这里。现在是buffer指向的是我们伪造的地址，符号位向量存在这里    initial_state.memory.store(fake_heap_address0, passwd0)      initial_state.memory.store(fake_heap_address1, passwd1)    simulation = project.factory.simgr(initial_state)        def is_successful(state):        stdout_output = state.posix.dumps(1)        if b&#x27;Good Job.\\n&#x27; in stdout_output:            return True        else:             return False    def should_abort(state):        stdout_output = state.posix.dumps(1)        if b&#x27;Try again.\\n&#x27; in  stdout_output:            return True        else:             return False    simulation.explore(find=is_successful, avoid=should_abort)      if simulation.found:        for i in simulation.found:            solution_state = i            solution0 = solution_state.solver.eval(passwd0, cast_to=bytes)            solution1 = solution_state.solver.eval(passwd1, cast_to=bytes)            print(&quot;[+] Success! Solution is: &#123;0&#125; &#123;1&#125;&quot;.format(solution0.decode(&#x27;utf-8&#x27;), solution1.decode(&#x27;utf-8&#x27;)))            #print(solution0, solution1)    else:        raise Exception(&#x27;Could not find the solution&#x27;)    if __name__ == &quot;__main__&quot;:    Go()\n\n八.符号化文件内容程序源码：\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int i; // [esp+Ch] [ebp-Ch]  memset(buffer, 0, 0x40u);  printf(&quot;Enter the password: &quot;);  __isoc99_scanf(&quot;%64s&quot;, buffer);  ignore_me((int)buffer, 0x40u);  memset(buffer, 0, 0x40u);  fp = fopen(&quot;OJKSQYDP.txt&quot;, &quot;rb&quot;);  fread(buffer, 1u, 0x40u, fp);  fclose(fp);  unlink(&quot;OJKSQYDP.txt&quot;);  for ( i = 0; i &lt;= 7; ++i )    *(_BYTE *)(i + 0x804A0A0) = complex_function(*(char *)(i + 0x804A0A0), i);  if ( strncmp(buffer, &quot;AQWLCTXB&quot;, 9u) )  &#123;    puts(&quot;Try again.&quot;);    exit(1);  &#125;  puts(&quot;Good Job.&quot;);  exit(0);&#125;unsigned int __cdecl ignore_me(int a1, size_t n)&#123;  void *v2; // esp  int v4; // [esp+0h] [ebp-28h]  void *ptr; // [esp+Ch] [ebp-1Ch]  size_t v6; // [esp+10h] [ebp-18h]  void *s; // [esp+14h] [ebp-14h]  FILE *stream; // [esp+18h] [ebp-10h]  unsigned int v9; // [esp+1Ch] [ebp-Ch]  ptr = (void *)a1;  v9 = __readgsdword(0x14u);  v6 = n - 1;  v2 = alloca(16 * ((n + 15) / 0x10));  s = &amp;v4;  memset(&amp;v4, 0, n);  unlink(&quot;OJKSQYDP.txt&quot;);  stream = fopen(&quot;OJKSQYDP.txt&quot;, &quot;a+b&quot;);  fwrite(ptr, 1u, n, stream);  fseek(stream, 0, 0);  __isoc99_fscanf(stream, &quot;%64s&quot;, s);  fseek(stream, 0, 0);  fwrite(s, 1u, n, stream);  fclose(stream);  return __readgsdword(0x14u) ^ v9;&#125;\n\nangr的exp：\nimport angrimport sysimport claripydef Go():    path_to_binary = &quot;./07_angr_symbolic_file&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    start_address =  0x80488EA    initial_state = project.factory.blank_state(addr=start_address)    filename = &#x27;OJKSQYDP.txt&#x27;    symbolic_file_size_bytes = 64    passwd0 = claripy.BVS(&#x27;password&#x27;, symbolic_file_size_bytes * 8)    passwd_file = angr.storage.SimFile(filename, content=passwd0, size=symbolic_file_size_bytes)    initial_state.fs.insert(filename, passwd_file)    simulation = project.factory.simgr(initial_state)        def is_successful(state):        stdout_output = state.posix.dumps(1)        if b&#x27;Good Job.\\n&#x27; in stdout_output:            return True        else:             return False    def should_abort(state):        stdout_output = state.posix.dumps(1)        if b&#x27;Try again.\\n&#x27; in  stdout_output:            return True        else:             return False    simulation.explore(find=is_successful, avoid=should_abort)      if simulation.found:        for i in simulation.found:            solution_state = i            solution0 = solution_state.solver.eval(passwd0, cast_to=bytes)            print(&quot;[+] Success! Solution is: &#123;0&#125;&quot;.format(solution0.decode(&#x27;utf-8&#x27;)))            #print(solution0)    else:        raise Exception(&#x27;Could not find the solution&#x27;)    if __name__ == &quot;__main__&quot;:    Go()\n\n九.路径爆炸程序源码：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  signed int i; // [esp+Ch] [ebp-Ch]  password = 1146115393;  dword_804A044 = 1380994638;  dword_804A048 = 1381647695;  dword_804A04C = 1112233802;  memset(&amp;buffer, 0, 0x11u);  printf(&quot;Enter the password: &quot;);  __isoc99_scanf(&quot;%16s&quot;, &amp;buffer);  for ( i = 0; i &lt;= 15; ++i )    *(_BYTE *)(i + 0x804A050) = complex_function(*(char *)(i + 0x804A050), 15 - i);  if ( check_equals_AUPDNNPROEZRJWKB(&amp;buffer, 16) )    puts(&quot;Good Job.&quot;);  else    puts(&quot;Try again.&quot;);  return 0;&#125;_BOOL4 __cdecl check_equals_AUPDNNPROEZRJWKB(int a1, unsigned int a2)&#123;  int v3; // [esp+8h] [ebp-8h]  unsigned int i; // [esp+Ch] [ebp-4h]  v3 = 0;  for ( i = 0; i &lt; a2; ++i )  &#123;    if ( *(_BYTE *)(i + a1) == *(_BYTE *)(i + 0x804A040) )      ++v3;  &#125;  return v3 == a2;&#125;\n\n所谓符号执行就是把程序中的变量符号化去模拟程序运行，搜集路径约束条件并使用约束求解器对其进行求解后得到结果。当一个程序存在循环结构时，即使逻辑十分简单也可能会产生规模十分巨大的执行路径。在符号执行的过程中，每个分支点都会产生两个实例，当程序中存在循环结构展开时，可能会导致程序分支路径数呈指数级增长，即路径爆炸问题。故我们需要提供更多的约束条件控制路径爆照问题\nangr的exp：\nimport angrimport sysimport claripydef Go():    path_to_binary = &quot;./08_angr_constraints&quot;     project = angr.Project(path_to_binary, auto_load_libs=False)    start_address = 0x8048625    buff_addr = 0x0804A050    address_to_check_constraint = 0x08048565    initial_state = project.factory.blank_state(addr=start_address)       char_size_in_bits = 8    passwd_len = 16    passwd0 = claripy.BVS(&#x27;passwd0&#x27;, char_size_in_bits*passwd_len)    initial_state.memory.store(buff_addr, passwd0)    simulation = project.factory.simgr(initial_state)    simulation.explore(find=address_to_check_constraint)    if simulation.found:        solution_state = simulation.found[0]        constrained_parameter_address = buff_addr        constrained_parameter_size_bytes = 16        constrained_parameter_bitvector = solution_state.memory.load(        constrained_parameter_address,        constrained_parameter_size_bytes    )        constrained_parameter_desired_value = &#x27;AUPDNNPROEZRJWKB&#x27;        solution_state.solver.add(constrained_parameter_bitvector == constrained_parameter_desired_value)        solution0 = solution_state.solver.eval(passwd0,cast_to=bytes)               print(&quot;[+] Success! Solution is: &#123;0&#125;&quot;.format(solution0))    else:        raise Exception(&#x27;Could not find the solution&#x27;)    if __name__ == &quot;__main__&quot;:    Go()\n\n\n用户输入的字符串存储在buffer，buffer的地址为：0x804A050\n比较函数check_equals_AUPDNNPROEZRJWKB的地址为：0x08048565\n其实只要当程序运行到地址0x08048565时，处于buffer地址内的字符串等于AUPDNNPROEZRJWKB即可\n添加上述约束条件即可一步得出结果，而不用进入比较函数逐一字符比较而产生路径爆炸问题\n\n十.angr hook主要就是学习使用angr的hook技术解决路径爆炸问题，与我们之前利用的约束条件不同，hook技术则更为强大\n","categories":["网安"],"tags":["逆向"]},{"title":"goductf  逆向wp","url":"/2023/04/17/goductf/","content":"Check_Your_Luckz3解方程\ndoublegame这题最坑的地方就是静态的迷宫和动调出来的迷宫不一样！！！\n程序打开就是一个贪吃蛇游戏，（挺好玩，先玩一会）\n拖入ida，主函数没啥用，查找字符串很明显有个迷宫，（但不是贪吃蛇游戏吗），先交叉引用进去，分析代码很明显就是很简单的走迷宫求路径，但是静态的迷宫是错误的，查找迷宫的交叉引用我也没看到对他的修改，感觉应该不是出题人故意的，是ida分析错了？真正的迷宫得动调进去看，那么怎么到达这里呢，刚刚的贪吃蛇呢。那就再对这个函数一直x找交叉引用，可以一直追踪到贪吃蛇函数，可以看到跳转到迷宫的条件就是贪吃蛇的分数达到13371337.\n嗯，没了，一开始没动调按照错误的迷宫卡了我三个小时\nflag{md5（path）+13371337}\n迷宫的代码：这里的迷宫有一个地方少了个0\n  strcpy(Buffer, &quot;000000000000000000000&quot;);  strcpy(v4, &quot;0 0 0 0     0     0 0&quot;);  strcpy(&amp;v4[22], &quot;0 0 0 00000 00000 0 0&quot;);  strcpy(v5, &quot;0 0               0 0&quot;);  strcpy(&amp;v5[22], &quot;0 000 000 0 000 0 0 0&quot;);  strcpy(v6, &quot;0 0     0 0 0   0 0 0&quot;);  strcpy(&amp;v6[22], &quot;0 0 0 00000 000 000 0&quot;);  strcpy(v7, &quot;0 0 0     0   0 0    &quot;);  strcpy(&amp;v7[22], &quot;0 000 0 0 000 0 0 0 0&quot;);  strcpy(v8, &quot;0     0 0 0 0 0 0 0 0&quot;);  strcpy(&amp;v8[22], &quot;0 00000 000 000 0 0 0&quot;);  strcpy(v9, &quot;0     0       0   0 0&quot;);  strcpy(&amp;v9[22], &quot;000 0 0 0 000 0 0 0 0&quot;);  strcpy(v10, &quot;0 0 0 0 0 0 * 0 0 0 0&quot;);  strcpy(&amp;v10[22], &quot;0 0000000 0 000 00000&quot;);  strcpy(v11, &quot;@       0 0         0&quot;);//这里动调看应该是@    0   0 0         0  strcpy(&amp;v11[22], &quot;0 0 0 0 0 00000000000&quot;);  strcpy(v12, &quot;0 0 0 0             0&quot;);  strcpy(&amp;v12[22], &quot;000 0 00000 0 000 000&quot;);  strcpy(v13, &quot;0         0 0   0   0&quot;);  strcpy(&amp;v13[22], &quot;000000000000000000000&quot;);  v11[4] = 48;//破案了，这里出题人故意的  strcpy((char *)v19, &quot;Please to save the cat!&quot;);  memset(&amp;v19[6], 0, 0x4Cui64);  strcpy(v20, &quot;the score is saving cat&#x27;s key!\\n&quot;);  memset(&amp;v20[32], 0, 0x44ui64);  qmemcpy(v21, &amp;unk_14001D340, 0x47ui64);  memset(&amp;v21[71], 0, 729);  sub_1400111F9(&quot;path\\n&quot;);  v23 = 0;  v24 = 0;  v15 = 15;  v16 = 0;  v17 = 7;  v18 = 20;  for ( j = 0; j &lt;= 20; ++j )    puts(&amp;Buffer[22 * j]);  sub_1400111F9(&quot;Please to save the cat!\\n&quot;);  while ( v15 != v17 || v16 != v18 )  &#123;    v22 = getchar();    switch ( v22 )    &#123;      case &#x27;s&#x27;:        if ( Buffer[22 * v15 + 22 + v16] != 48 )        &#123;          Buffer[22 * v15++ + v16] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      case &#x27;w&#x27;:        if ( Buffer[22 * v15 - 22 + v16] != 48 )        &#123;          Buffer[22 * v15-- + v16] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      case &#x27;a&#x27;:        if ( Buffer[22 * v15 - 1 + v16] != 48 )        &#123;          if ( Buffer[22 * v15 - 1 + v16] == 42 )            v7[20] = 48;          Buffer[22 * v15 + v16--] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      default:        if ( v22 == 100 &amp;&amp; Buffer[22 * v15 + 1 + v16] != 48 )        &#123;          Buffer[22 * v15 + v16++] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;    &#125;    system(&quot;cls&quot;);    for ( j = 0; j &lt;= 20; ++j )      puts(&amp;Buffer[22 * j]);    puts((const char *)&amp;v19[25 * v23]);    if ( v7[20] == 48 )    &#123;      v24 = sub_140011433(0i64);      if ( v24 == 13376013 )      &#123;        v23 = 1;        v7[20] = 32;        Buffer[22 * v15 + v16] = 32;        v15 = 15;        v16 = 0;        v11[0] = 64;        ++v23;      &#125;      else      &#123;        sub_1400111F9(&quot;error&quot;);      &#125;    &#125;  &#125;  system(&quot;cls&quot;);  Sleep(0x1F4u);  Sleep(0xBB8u);  sub_140011492();  exit(0);&#125;\n\n\n\nTEA这道题加深了我对tea系列加密算法的理解\n魔改的xtea加密：\nfor ( i = 0; i &lt;= 8; ++i )&#123;  v5 = 0;  v6 = 256256256 * i;  v3 = i + 1;  do  &#123;    ++v5;    *(a1 + 4i64 * i) += v6 ^ (*(a1 + 4i64 * v3) + ((*(a1 + 4i64 * v3) &gt;&gt; 5) ^ (16 * *(a1 + 4i64 * v3)))) ^ (v6 + *(a2 + 4i64 * (v6 &amp; 3)));    *(a1 + 4i64 * v3) += (v6 + *(a2 + 4i64 * ((v6 &gt;&gt; 11) &amp; 3))) ^ (*(a1 + 4i64 * i)                                                                 + ((*(a1 + 4i64 * i) &gt;&gt; 5) ^ (16 * *(a1 + 4i64 * i))));    v6 += 256256256;  &#125;  while ( v5 &lt;= 0x20 );  result = (i + 1);&#125;\n\n其中do{}内的是tea加密的算法，外层套了个for（）循环，因为原文有10个整数\n解密脚本：\nint main()&#123;    for (int i = 8; i &gt;= 0; --i)//从后往前遍历    &#123;        int v5 = 0;        unsigned int v6 = 256256256 * (i+33);//detal  因为v6也就是detal在加密过程中一直加256256256，加了32次，所以逆的时候先求出最后的结果，并且要注意使用unsigned int                do//这个部分就完全逆过来，一共三步嘛，去原文那里对照着看一下，+=变-=，后面的内容不需要变，直接抄        &#123;            ++v5;            v6 -= 256256256;            a1[i + 1] -= (v6 + a2[(v6 &gt;&gt; 11) &amp; 3]) ^ (a1[i] + ((a1[i] &gt;&gt; 5) ^ (16 * a1[i])));            a1[i] -= v6 ^ (a1[i + 1] + ((a1[i + 1] &gt;&gt; 5) ^ (16 * a1[i + 1]))) ^ (v6 + a2[v6 &amp; 3]);                    &#125; while (v5 &lt;= 32);    &#125;    for (int i = 0; i &lt; 10; i++)    &#123;        for (int j = 3; j &gt;= 0; j--)        &#123;            printf(&quot;%c&quot;, (a1[i] &gt;&gt; (j * 8)) &amp; 0xFF);        &#125;    &#125;    return 0;&#125;\n\nL！S！考察了bindiff插件的使用\n比较两个文件的不同之处，一般用来比较原文件和dump之后的文件\n先用ida随便打开一个文件，再关闭，生成集成的那个文件（i64），再用ida打开另一个文件，打开插件bindiff，选择Diff Database 打开刚刚的i64文件，就可以查看这两个文件的不同之处了\n\n可以看到所有函数中只有一个函数不同\nif ( v9 &amp;&amp; !v9[1] )        &#123;          *&amp;lmao[8] = 0x3F7D132A2A252822LL;          *lmao = 0x7D2E370A180F1604LL;          *&amp;lmao[24] = 0x31207C7C381320LL;          *&amp;lmao[16] = 0x392A7F3F39132D13LL;          v18 = lmao;          do            *v18++ ^= **v7;          while ( &amp;lmao[31] != v18 );\n\n\n\n密文提取出来：\nint aa[] = &#123; 0x04,0x16,0x0f,0x18,0x0a,0x37,0x2e,0x7d,0x22,0x28,0x25,0x2a,0x13,0x7d,0x3f,0x13,0x2d,0x13,0x39,0x3f,0x7f,0x2a,0x39,0x20,0x13,0x38,0x7c,0x7c,0x20,0x31&#125;;\n\n加密就仅仅只有一个异或v7，从0-256爆破遍，去结果里找flag\n\n还算好找\n","categories":["网安"],"tags":["逆向"]},{"title":"HDCTF  逆向wp","url":"/2023/05/04/HDCTF/","content":"这个比赛因为天梯赛耽误了，就补补题算了\nez_re签到，upx脱壳后base64解密即可\neasy_asm签到2，这个ida打开全是“$”都有点看懵了，其实不用管就行，直接找关键点\n稍微扫一眼，可以看到xor al cl这个操作，cl在之前被赋值为0x10。再往后看还有个数据段，很明显就是简单异或一下就行。那个“$”有结束符的意思，所以数据段里除去相等不相等那些。\ndouble_codeshellcode loader\n找到其中的shellcode\n根据提示也很容易找到，这里ida已经自动将shellcode分析为代码\n输出给出，逻辑也给出，逆着回去就是flag\nfake_game也简单，但是反编译会出一点问题，magic nember得手动修复，听说最新版pyinstall会自动修复。\n看到这，很简单了：\nfor i in range(len(flag)):                                ans[i] = flag[i] ^ xorr[i % 4]\n\n这个xorr[]的四个数是前面有四个方程，z3解一下就ok\n或者，前四个字符肯定是HDCT 直接逆推\nenc先需要输入一个key来启动程序，这个key是经过tea加密的，结果已知，加密过程已知，写出解密脚本即可：\ntea加密函数：\nv4 = 0;for ( i = 0; i &lt; 0x20; ++i )&#123;  v4 -= 0x61C88647;  v6 += (a2[1] + (v5 &gt;&gt; 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5);  v5 += (a2[3] + (v6 &gt;&gt; 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6);&#125;\n\n\n\n#include &lt;iostream&gt;using namespace std;int main()&#123;  //求解sum：  //  unsigned int aaa = 0;  //  for (int i = 0; i &lt; 32; i++)  //  &#123;  //       //      aaa -= 1640531527;//sum  //        //&#125;  //  cout &lt;&lt; aaa;       unsigned int  v4= 0xC6EF3720;//sum    uint32_t v5 = 0x236DBEC;//加密结果1    uint32_t v6 = 0x60FCDEF7;//加密结果2    uint32_t a2[4] = &#123; 0x12,0x34,0x56,0x78 &#125;;//key    for (int i = 0; i &lt; 0x20; ++i)//还是三个步骤逆序，+=变-=，-=变+=    &#123;        v5 -= (a2[3] + (v6 &gt;&gt; 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6);        v6 -= (a2[1] + (v5 &gt;&gt; 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5);        v4 += 0x61C88647;    &#125;    cout &lt;&lt; v5 &lt;&lt;&#x27; &#x27; &lt;&lt; v6&lt;&lt;endl;  \treturn 0;&#125;\n\n结果：3 和 4 \n3就是key\n继续看接下来的函数：将这个key（3）传入了接下来的函数，一直点进去，可以看到smc的部分：\nfor ( i = 0; ; ++i )&#123;  result = i;  if ( i &gt;= a2 )    break;  *(i + a1) ^= a3;&#125;\n\n这个异或的a3就是传入的那个3\n那么smc加密了哪段代码呢：看前面的函数：\nif ( !j_strcmp(Str1, &quot;.hdctf&quot;) )      return sub_411221(*(Str1 + 3) + a1, *(Str1 + 4), a2);\n\n可以发现是加密了.hdctf段的代码，如下：\n.hdctf:0041D000                               ; ---------------------------------------------------------------------------.hdctf:0041D000                               ; Section 3. (virtual address 0001D000).hdctf:0041D000                               ; Virtual size                  : 000015B4 (   5556.).hdctf:0041D000                               ; Section size in file          : 00001600 (   5632.).hdctf:0041D000                               ; Offset to raw data for section: 0000BE00.hdctf:0041D000                               ; Flags E0000020: Text Executable Readable Writable.hdctf:0041D000                               ; Alignment     : default.hdctf:0041D000                               ; ===========================================================================.hdctf:0041D000.hdctf:0041D000                               ; Segment type: Pure code.hdctf:0041D000                               ; Segment permissions: Read/Write/Execute.hdctf:0041D000                               _hdctf segment para public &#x27;CODE&#x27; use32.hdctf:0041D000                               assume cs:_hdctf.hdctf:0041D000                               ;org 41D000h.hdctf:0041D000                               assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing.hdctf:0041D000.hdctf:0041D000                               loc_41D000:                             ; CODE XREF: sub_411302↑j.hdctf:0041D000 56                            push    esi.hdctf:0041D001 88 EF                         mov     bh, ch.hdctf:0041D003 82 EF 4F                      sub     bh, 4Fh ; &#x27;O&#x27;.hdctf:0041D006 06                            push    es.hdctf:0041D007 03 03                         add     eax, [ebx].hdctf:0041D009 50                            push    eax.hdctf:0041D00A 55                            push    ebp.hdctf:0041D00B 54                            push    esp.hdctf:0041D00B.hdctf:0041D00B                               ; ---------------------------------------------------------------------------.hdctf:0041D00C 8E BE 37 FF FC FC BA F0 03 03+dd 0FF37BE8Eh, 0F0BAFCFCh, 0BB030303h, 0CFCFCFCFh, 7A2A8F0h, 30034123h, 0FF468AC6h, 415335BAh, 478BEB03h.hdctf:0041D00C 03 BB CF CF CF CF F0 A8 A2 07+dd 46C5FCFCh, 46C50CD7h, 46C597D6h, 46C5ADD5h, 46C5F1D4h, 46C5C3DBh, 46C554DAh, 46C5C1D9h, 46C5E3D8h.hdctf:0041D00C 23 41 03 30 C6 8A 46 FF BA 35+dd 46C599DFh, 46C546DEh, 46C534DDh, 46C553DCh, 46C5F6E3h, 46C5A3E2h, 46C55DE1h, 46C5C8E0h, 46C52FE7h.hdctf:0041D00C 53 41 03 EB 8B 47 FC FC C5 46+dd 46C515E6h, 46C52BE5h, 46C52AE4h, 46C5FDEBh, 46C5FCEAh, 46C530E9h, 46C545E8h, 46C50DEFh, 46C554EEh.hdctf:0041D00C D7 0C C5 46 D6 97 C5 46 D5 AD+dd 46C581EDh, 46C521ECh, 46C551F3h, 46C525F2h, 46C528F1h, 46C56DF0h, 46C5E7F7h, 46C581F6h, 36B27F5h.hdctf:0041D00C C5 46 D4 F1 C5 46 DB C3 C5 46+dd 69030302h, 0CF868E03h, 53FCFCFDh, 0FC4259EBh, 0FC780FCh, 530B4688h, 0FC4748EBh, 7C780FCh, 0FDC3868Ah.hdctf:0041D00C DA 54 C5 46 D9 C1 C5 46 D8 E3+dd 77A2FCFCh, 8A0342FFh, 0FCFDAB86h, 7B0E88FCh, 8A0342FFh, 0FCFDAF8Eh, 7F1688FCh, 8A0342FFh, 0FCFDB396h.hdctf:0041D00C C5 46 DF 99 C5 46 DE 46 C5 46+dd 83A265FCh, 650342FFh, 0FDB7868Ah, 0E89FCFCh, 342FF81h, 0FDB58E8Bh, 86C5FCFCh, 0FCFCFD9Ch, 5F86C403h.hdctf:0041D00C DD 34 C5 46 DC 53 C5 46 E3 F6+dd 3FCFCFFh, 0C4030303h, 0FCFF7786h, 30303FCh, 880CE803h, 0FCFF7786h, 2C380FCh, 0FF77868Ah, 0BE82FCFCh.hdctf:0041D00C C5 46 E2 A3 C5 46 E1 5D C5 46+dd 0FCFCFF77h, 3030203h, 8688477Eh, 0FCFCFF77h, 0FF778E89h, 8F8BFCFCh, 0FCFE9706h, 0AB868EFCh, 53FCFCFDh.hdctf:0041D00C E0 C8 C5 46 E7 2F C5 46 E6 15+dd 0FC40ACEBh, 7C780FCh, 8688CB88h, 0FCFCFF77h, 0F2F4D130h, 0FF778688h, 8F89FCFCh, 0FCFDAB16h, 68F8BFCh.hdctf:0041D00C C5 46 E5 2B C5 46 E4 2A C5 46+dd 0FCFCFF8Fh, 86C4A2E8h, 0FCFCFF77h, 3030303h, 86880CE8h, 0FCFCFF77h, 8A02C380h, 0FCFF7786h, 77BE82FCh.hdctf:0041D00C EB FD C5 46 EA FC C5 46 E9 30+dd 3FCFCFFh, 7E030302h, 7786887Ch, 0CFCFCFFh, 97068FB5h, 0FCFCFEh, 0FCFF5F8Eh, 779688FCh, 0CFCFCFFh.hdctf:0041D00C C5 46 E8 45 C5 46 EF 0D C5 46+dd 8F1687B5h, 0FCFCFFh, 0FCE282CBh, 7A830303h, 0CA824A0Bh, 0FCFCFC03h, 5F8E8A42h, 88FCFCFFh, 0FCFF7786h.hdctf:0041D00C EE 54 C5 46 ED 81 C5 46 EC 21+dd 68F89FCh, 0FCFCFE97h, 0FF808E8Bh, 8688FCFCh, 0FCFCFF77h, 0FF5F8E88h, 9789FCFCh, 0FCFE970Eh, 6978BFCh.hdctf:0041D00C C5 46 F3 51 C5 46 F2 25 C5 46+dd 0FCFCFE97h, 0FF5F8688h, 8E89FCFCh, 0FCFCFF80h, 97068F8Bh, 0EAFCFCFEh, 0FCFCFC65h, 0FF6B86C4h, 303FCFCh.hdctf:0041D00C F1 28 C5 46 F0 6D C5 46 F7 E7+dd 86880303h, 0FCFCFF6Bh, 0FF77868Ah, 86C4FCFCh, 0FCFCFF53h, 3030303h, 86880CE8h, 0FCFCFF53h, 8A02C380h.hdctf:0041D00C C5 46 F6 81 C5 46 F5 27 6B 03+dd 0FCFF5386h, 538688FCh, 38FCFCFFh, 0FCFDC386h, 0D88E0CFCh, 88030303h, 0FCFF7786h, 2C380FCh, 303FC26h.hdctf:0041D00C 02 03 03 69 03 8E 86 CF FD FC+dd 4B047A83h, 0FCFC030Eh, 868A43FCh, 0FCFCFF77h, 0FF778688h, 0B50CFCFCh, 0FE97068Fh, 8E00FCFCh, 0FCFCFF6Bh.hdctf:0041D00C FC 53 EB 59 42 FC FC 80 C7 0F+dd 3FCE282h, 0B7A8303h, 3CA824Ah, 42FCFCFCh, 0FF6B8E8Ah, 8688FCFCh, 0FCFCFF77h, 97068F89h, 8BFCFCFEh.hdctf:0041D00C 88 46 0B 53 EB 48 47 FC FC 80+dd 0FCFF808Eh, 778688FCh, 88FCFCFFh, 0FCFF6B8Eh, 0E9789FCh, 0FCFCFE97h, 9706978Bh, 88FCFCFEh, 0FCFF6B86h.hdctf:0041D00C C7 07 8A 86 C3 FD FC FC A2 77+dd 808E89FCh, 8BFCFCFFh, 0FE97068Fh, 4688FCFCh, 5386000Bh, 0CFCFCFFh, 96880BBDh, 0FCFCFF77h, 1687B50Ch.hdctf:0041D00C FF 42 03 8A 86 AB FD FC FC 88+dd 0FCFCFE97h, 0FF6B9688h, 0B50CFCFCh, 0FE971697h, 0C100FCFCh, 303FC26h, 4B047A83h, 0FCFC030Eh, 0B50C43FCh.hdctf:0041D00C 0E 7B FF 42 03 8A 8E AF FD FC+dd 0FE970687h, 0CB30FCFCh, 0FF539688h, 8F8BFCFCh, 0FCFDCF16h, 0FC07EAFCh, 86C4FCFCh, 0FCFCFF47h, 3030302h.hdctf:0041D00C FC 88 16 7F FF 42 03 8A 96 B3+dd 530B4688h, 0FC42B0EBh, 7C780FCh, 7720FB80h, 4786C409h, 3FCFCFFh, 0C4030303h, 0FCFF3B86h, 30303FCh.hdctf:0041D00C FD FC FC 65 A2 83 FF 42 03 65+dd 880CE803h, 0FCFF3B86h, 2C380FCh, 0FF3B868Ah, 468EFCFCh, 7EEB53D7h, 80FCFC42h, 863A07C7h, 0FCFCFF3Bh.hdctf:0041D00C 8A 86 B7 FD FC FC 89 0E 81 FF+dd 86882870h, 0FCFCFF3Bh, 64FB50Ch, 3B9688D7h, 0CFCFCFFh, 0CF1687B5h, 38FCFCFDh, 0C40F77CBh, 0FCFF4786h.hdctf:0041D00C 42 03 8B 8E B5 FD FC FC C5 86+dd 30303FCh, 0E801E803h, 47BE80B1h, 3FCFCFFh, 8B6B0C77h, 0EB0342FFh, 0FCFC3E58h, 0E807C780h, 0FF976B0Eh.hdctf:0041D00C 9C FD FC FC 03 C4 86 5F FF FC+dd 4FEB0342h, 80FCFC3Eh, 885107C7h, 168E53CEh, 342D73Bh, 0FC3DEBEBh, 5C595BFCh, 4E88585Dh, 0EBCE30FFh.hdctf:0041D00C FC 03 03 03 03 C4 86 77 FF FC+dd 0FCFC3D01h, 64FC782h, 0EF380303h, 0FC3C3CEBh, 5EE688FCh, 31C0CC0h, 3030306h, 342D743h, 0FCFCFCD7h.hdctf:0041D00C FC 03 03 03 03 E8 0C 88 86 77+dd 3030320h, 342D788h, 0FCFCFDCFh, 3030203h, 342D787h, 0FCFCFDABh, 303030Ch, 342D783h, 0FCFCFE97h, 3030203h.hdctf:0041D00C FF FC FC 80 C3 02 8A 86 77 FF+dd 342D77Dh, 0FCFCFF8Fh, 3030203h, 342D77Fh, 3700368h, 37A6668h, 7377766Ch, 65037776h, 364626Fh, 449h dup(0CFCFCFCFh).hdctf:0041D00C FC FC 82 BE 77 FF FC FC 03 02+dd 13h dup(3030303h).hdctf:0041E600 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+dd 280h dup(?).hdctf:0041E600 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+_hdctf ends.hdctf:0041E600 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+\n\nidc脚本解密之后就是个rc4，很简单了，不说了\n买了些什么呢随便看看，给出的文字提示已经很明确了，背包容量50 物品40个，要总价值最大，01背包问题，写个板子求解一下就行了\n注意点就是商品的价值和重量看似是随机生成的，但是程序设置随机数种子是1，所以每次生成的就都一样了。\n抄的exp：\n#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e4+5;int f[N],p[N][N],w[N],v[N];//void printpath(int x)//&#123;// if(!x) return;// printpath(x-w[p[x]]);// cout&lt;&lt;p[x]&lt;&lt;&quot; &quot;;//&#125;int main()&#123; int n,m; // 先输入物品数量，再输入背包容量 cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) cin&gt;&gt;w[i]&gt;&gt;v[i]; for(int i=n; i&gt;=1; i--) &#123;;  for(int j=m; j&gt;=w[i]; j--)  &#123;   if(f[j]&lt;f[j-w[i]]+v[i])   &#123;    f[j]=f[j-w[i]]+v[i];    p[i][j]=1;   &#125;  &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;&#x27;\\n&#x27;;// printpath(m); for(int i=1,j=m;i&lt;=n&amp;&amp;j&gt;=0;i++) &#123;  if(p[i][j])  &#123;   cout&lt;&lt;i-14&lt;&lt;&quot; &quot;;   j-=w[i];  &#125; &#125; return 0;&#125;\n\n","categories":["网安"],"tags":["逆向"]},{"title":"W4ntY0u每日训练","url":"/2023/05/03/W4ntY0u%E6%AF%8F%E6%97%A5%E8%AE%AD%E7%BB%83/","content":"5.3xctf：流浪者一道mfc的逆向，ida打开，利用字符串定位关键函数\n\n定位到sub_4017F0函数：\nint __cdecl sub_4017F0(int a1)&#123;  char Str1[28]; // [esp+D8h] [ebp-24h] BYREF  int v3; // [esp+F4h] [ebp-8h]  int v4; // [esp+F8h] [ebp-4h]  v4 = 0;  v3 = 0;  while ( *(a1 + 4 * v4) &lt;= 0x3Du )  &#123;    Str1[v4] = aAbcdefghiabcde[*(a1 + 4 * v4)];    ++v4;  &#125;  Str1[v4] = 0;  if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) )    return sub_401770();  else    return sub_4017B0();&#125;\n\n主要逻辑就是一个置换加密，再交叉引用查看谁调用了他\nint __thiscall sub_401890(CWnd *this)&#123;  CWnd *DlgItem; // eax  int v2; // eax  struct CString *v4; // [esp-4h] [ebp-C4h]  int v5[26]; // [esp+4Ch] [ebp-74h] BYREF  int i; // [esp+B4h] [ebp-Ch]  char *Str; // [esp+B8h] [ebp-8h]  CWnd *v8; // [esp+BCh] [ebp-4h]  v8 = this;  v4 = (this + 100);  DlgItem = CWnd::GetDlgItem(this, 1002);  CWnd::GetWindowTextA(DlgItem, v4);  v2 = sub_401A30(v8 + 100);  Str = CString::GetBuffer((v8 + 100), v2);  if ( !strlen(Str) )    return CWnd::MessageBoxA(v8, &amp;byte_4035DC, 0, 0);  for ( i = 0; Str[i]; ++i )  &#123;    if ( Str[i] &gt; &#x27;9&#x27; || Str[i] &lt; &#x27;0&#x27; )    &#123;      if ( Str[i] &gt; &#x27;z&#x27; || Str[i] &lt; &#x27;a&#x27; )      &#123;        if ( Str[i] &gt; &#x27;Z&#x27; || Str[i] &lt; &#x27;A&#x27; )          sub_4017B0();        else          v5[i] = Str[i] - &#x27;\\x1D&#x27;;      &#125;      else      &#123;        v5[i] = Str[i] - &#x27;W&#x27;;      &#125;    &#125;    else    &#123;      v5[i] = Str[i] - &#x27;0&#x27;;    &#125;  &#125;  return sub_4017F0(v5);&#125;\n\n可以看到对输入的字符进行了三次判断，如果不在该判断范围内，直接错误\n那么逆向脚本如下：\nKanXue = &quot;KanXueCTF2019JustForhappy&quot;abcdef = &quot;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&quot;SomeDwordArray = []Key = &quot;&quot;for i in range(len(KanXue)):    SomeDwordArray.append(abcdef.find(KanXue[i]))print(&quot;SomeDwordArray =&quot;, SomeDwordArray)for dw in SomeDwordArray:    if dw &lt;= 9 and dw &gt;= 0:        Key += chr(dw + ord(&#x27;0&#x27;))    elif dw + ord(&#x27;W&#x27;) &gt;= ord(&#x27;a&#x27;) and dw + ord(&#x27;W&#x27;) &lt;= ord(&#x27;z&#x27;):        Key += chr(dw + ord(&#x27;W&#x27;))    else:        Key += chr(dw + 0x1D)print(Key)#j0rXI4bTeustBiIGHeCF70DDM\n\nre2-cpp-is-awesomemain函数：\n__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  char *v3; // rbx  __int64 v4; // rax  __int64 v5; // rdx  __int64 v6; // rax  __int64 v7; // rdx  _BYTE *v8; // rax  __int64 v10[2]; // [rsp+10h] [rbp-60h] BYREF  char v11[47]; // [rsp+20h] [rbp-50h] BYREF  char v12; // [rsp+4Fh] [rbp-21h] BYREF  __int64 v13; // [rsp+50h] [rbp-20h] BYREF  int v14; // [rsp+5Ch] [rbp-14h]  if ( a1 != 2 )  &#123;    v3 = *a2;    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Usage: &quot;, a3);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v4, v3, v5);    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; flag\\n&quot;, v7);    exit(0);  &#125;  std::allocator&lt;char&gt;::allocator(&amp;v12, a2, a3);  std::string::basic_string(v11, a2[1], &amp;v12);  std::allocator&lt;char&gt;::~allocator(&amp;v12);  v14 = 0;  v10[0] = std::string::begin(v11);  while ( 1 )  &#123;    v13 = std::string::end(v11);    if ( !sub_400D3D(v10, &amp;v13) )      break;    v8 = sub_400D9A(v10);    if ( *v8 != off_6020A0[dword_6020C0[v14]] )      sub_400B56();    ++v14;    sub_400D7A(v10);  &#125;  sub_400B73();  std::string::~string(v11);  return 0LL;&#125;\n\n前面的逻辑还算不少，但是关键是最后的比较，直接用了明文，所以前面就都不用管了，直接逆向最后的比较\n先idc爬数据：\nauto addr = 0x00006020C0;auto i = 0;for(i; addr+i &lt; 0x060213C; i = i+4)&#123;\tMessage(&quot;%d,&quot;,Byte(addr+i));\t//PatchByte(addr+i,Byte());&#125;\n\n脚本：\n#include &lt;iostream&gt;using namespace std;int main()&#123;\tchar a[] = &quot;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_&#123;FL4G&#125;_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&quot;;\tint b[] = &#123; 36,0,5,54,101,7,39,38,45,1,3,0,13,86,1,3,101,3,45,22,2,21,3,101,0,41,68,68,1,68,43, &#125;;\tfor (int i = 0; i &lt; 31; ++i)\t&#123;\t\tprintf(&quot;%c&quot;, a[b[i]]);\t&#125;\treturn  0;&#125;\n\n5.4whats-the-hell-500题目直接给了源码了，vs打开：（真抽象）\n#include &quot;somelib.hxx&quot;#include &lt;iostream&gt;#include &lt;cstdlib&gt;void error()&#123;    std::cout &lt;&lt; &quot;Wrong password&quot; &lt;&lt; std::endl;    std::exit(-1);&#125;int pow(int x, int n)&#123;    int ret(1);    for (int i = 1; i &lt;= n; ++i)        ret *= x;    return ret;&#125;void check_password(std::string&amp; p)&#123;    if (p.size() != 13)    &#123;        std::cout &lt;&lt; &quot;Password must be 13 characters&quot; &lt;&lt; std::endl;        std::exit(-1);    &#125;    if (p[0]+p[1] != pow(I-----I,2) * pow(I-----------I,2) + (I---I)) error();    if (p[1]+p[2] != pow(I-------I,2) * pow(I-----I,4) - (I---I)) error();    if (p[0]*p[2] != (pow(pow(I-------I,2) * pow(I-----I,3) - (I---I),2) - (I-----I)*(I-------I))) error();    if (p[3]+p[5] != pow((o-------o                          |       !                          !       !                          !       !                          o-------o).A,2) * (I-----I)+(I---I)) error();    if (p[3]+p[4] != pow((o-----------o                          |           !                          !           !                          !           !                          o-----------o).A,2)+(I---I)) error();    if (p[4]*p[5] != (pow((o-------------o                           |             !                           !             !                           !             !                           o-------------o).A,2)-(I---I))*(I-----I)*pow(I-------I,2)) error();    if (p[7]+p[8] != (o-----------o                      |L           \\                      | L           \\                      |  L           \\                      |   o-----------o|!                      o   |           !                       L  |           !                        L |           !                         L|           !                          o-----------o).V*pow(I-----I,2) - pow((o-------o                                                                      |       !                                                                      !       !                                                                      o-------o).A,2) + (I---I)) error();    if (p[6]+p[8] != (o-----------o                      |L           \\                      | L           \\                      |  L           \\                      |   L           \\                      |    L           \\                      |     o-----------o                      |     !           !                      o     |           !                       L    |           !                        L   |           !                         L  |           !                          L |           !                           L|           !                            o-----------o).V - (I-----I)) error();    if (p[6]*p[7] != (o---------------------o                      |L                     \\                      | L                     \\                      |  L                     \\                      |   L                     \\                      |    L                     \\                      |     L                     \\                      |      L                     \\                      |       L                     \\                      |        o---------------------o                      |        !                     !                      !        !                     !                      o        |                     !                       L       |                     !                        L      |                     !                         L     |                     !                          L    |                     !                           L   |                     !                            L  |                     !                             L |                     !                              L|                     !                               o---------------------o).V*(pow(I-------I,2) + (I-----I)) + pow(I-----I,6)) error();    if (p[9]+p[10]*p[11] != (o---------o                             |L         \\                             | L         \\                             |  L         \\                             |   L         \\                             |    o---------o                             |    !         !                             !    !         !                             o    |         !                              L   |         !                               L  |         !                                L |         !                                 L|         !                                  o---------o).V*(I-------I)*pow(I-----I,4)-(I---I)) error();    if (p[10]+p[9]*p[11] != (o-----------o                             |L           \\                             | L           \\                             |  L           \\                             |   L           \\                             |    L           \\                             |     o-----------o                             |     !           !                             o     |           !                              L    |           !                               L   |           !                                L  |           !                                 L |           !                                  L|           !                                   o-----------o).V*pow(I-------I,3) - (I-----------I)*((I-----I)*(I-----------I)+(I---I))) error();    if (p[9]+p[10] != (o-------------o                       |L             \\                       | L             \\                       |  L             \\                       |   L             \\                       |    L             \\                       |     o-------------o                       |     !             !                       o     |             !                        L    |             !                         L   |             !                          L  |             !                           L |             !                            L|             !                             o-------------o).V-(I-----------I)) error();    if (p[12] != &#x27;w&#x27;) error();&#125;int main()&#123;    std::cout &lt;&lt; &quot;Guess passwd&quot; &lt;&lt; std::endl;    std::string password;    std::cin &gt;&gt; password;    check_password(password);    std::cout &lt;&lt; &quot;Correct password! It&#x27;s your flag, bruh&quot; &lt;&lt; std::endl;&#125;\n\n这个是调用了一个cxx的库，稍微google一下，可以大概了解到那一坨抽象的东西是等于一个数的，要么继续学怎么计算，这个时候gpt-4就挺好用的了（3.5是傻子），得到12个的结果，然后直接爆破：\n#0-2flag = &#x27;&#x27;for i in range(0x20, 0x7f):    for j in range(0x20, 0x7f):        for k in range(0x20, 0x7f):                if i+j == 101 and j+k==143 and i*k==5035:                        flag += chr(i)+chr(j)+chr(k)                        print(&#x27;[&#x27;+chr(i)+chr(j)+chr(k) + &#x27;]&#x27;)#50_     #3-5for i in range(0x20, 0x7f):    for j in range(0x20, 0x7f):        for k in range(0x20, 0x7f):                if i+j == 226 and i+k==163 and j*k==5814:                        flag += chr(i)+chr(j)+chr(k)                        print(&#x27;[&#x27;+chr(i)+chr(j)+chr(k) + &#x27;]&#x27;)#pr3for i in range(0x20, 0x7f):    for j in range(0x20, 0x7f):        for k in range(0x20, 0x7f):                if j+k == 205 and i+k==173 and i*j==9744:                        flag += chr(i)+chr(j)+chr(k)                        print(&#x27;[&#x27;+chr(i)+chr(j)+chr(k) + &#x27;]&#x27;)#Ttyfor i in range(0x20, 0x7f):    for j in range(0x20, 0x7f):        for k in range(0x20, 0x7f):                if i+j*k == 5375 and j+i*k==4670 and i+j==205:                        flag += chr(i)+chr(j)+chr(k)                        print(&#x27;[&#x27;+chr(i)+chr(j)+chr(k) + &#x27;]&#x27;)#_n0flag +=&#x27;w&#x27;print(flag)\n\neasyREmain函数：\n__int64 sub_4009C6()&#123;  __int64 result; // rax  int i; // [rsp+Ch] [rbp-114h]  __int64 v2; // [rsp+10h] [rbp-110h]  __int64 v3; // [rsp+18h] [rbp-108h]  __int64 v4; // [rsp+20h] [rbp-100h]  __int64 v5; // [rsp+28h] [rbp-F8h]  __int64 v6; // [rsp+30h] [rbp-F0h]  __int64 v7; // [rsp+38h] [rbp-E8h]  __int64 v8; // [rsp+40h] [rbp-E0h]  __int64 v9; // [rsp+48h] [rbp-D8h]  __int64 v10; // [rsp+50h] [rbp-D0h]  __int64 v11; // [rsp+58h] [rbp-C8h]  char v12[13]; // [rsp+60h] [rbp-C0h] BYREF  char v13[4]; // [rsp+6Dh] [rbp-B3h] BYREF  char v14[19]; // [rsp+71h] [rbp-AFh] BYREF  char v15[32]; // [rsp+90h] [rbp-90h] BYREF  int v16; // [rsp+B0h] [rbp-70h]  char v17; // [rsp+B4h] [rbp-6Ch]  char v18[72]; // [rsp+C0h] [rbp-60h] BYREF  unsigned __int64 v19; // [rsp+108h] [rbp-18h]  v19 = __readfsqword(0x28u);  qmemcpy(v12, &quot;Iodl&gt;Qnb(ocy&quot;, 12);  v12[12] = 127;  qmemcpy(v13, &quot;y.i&quot;, 3);  v13[3] = 127;  qmemcpy(v14, &quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;, sizeof(v14));  memset(v15, 0, sizeof(v15));  v16 = 0;  v17 = 0;  sub_4406E0(0, v15, 37LL);  v17 = 0;  if ( (sub_424BA0)(v15) == 36 )  &#123;    for ( i = 0; i &lt; (sub_424BA0)(v15); ++i )    &#123;      if ( (v15[i] ^ i) != v12[i] )      &#123;        result = 4294967294LL;        goto LABEL_13;      &#125;    &#125;    sub_410CC0(&quot;continue!&quot;);    memset(v18, 0, 65);    sub_4406E0(0, v18, 64LL);    v18[39] = 0;    if ( (sub_424BA0)(v18) == 39 )    &#123;      v2 = sub_400E44(v18);      v3 = sub_400E44(v2);      v4 = sub_400E44(v3);      v5 = sub_400E44(v4);      v6 = sub_400E44(v5);      v7 = sub_400E44(v6);      v8 = sub_400E44(v7);      v9 = sub_400E44(v8);      v10 = sub_400E44(v9);      v11 = sub_400E44(v10);      if ( !sub_400360(v11, off_6CC090) )      &#123;        sub_410CC0(&quot;You found me!!!&quot;);        sub_410CC0(&quot;bye bye~&quot;);      &#125;      result = 0LL;    &#125;    else    &#123;      result = 4294967293LL;    &#125;  &#125;  else  &#123;    result = 0xFFFFFFFFLL;  &#125;LABEL_13:  if ( __readfsqword(0x28u) != v19 )    sub_444020();  return result;&#125;\n\nv15存输入的内容，第一段就是将输入异或下标后与已知的v12数组比较（ida分析错了，v12，v13，v14应该是一个数组，地址连在一起的）\n脚本解密：\narr = [73,111,100,108,62,81,110,98,40,111,99,121,127,121,46,105,127,100,96,51,119,125,       119,101,107,57,123,105,121,61,126,121,76,64,69,67]dec = &#x27;&#x27;for i in range(36):    dec += chr(arr[i]^i)print(dec)#Info:The first four chars are flag``\n\n第二次输入，进行了10次base64加密，解密即可：\nenc = &quot;Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ==&quot;for i in range(10):    enc = enc.decode(&#x27;base64&#x27;)print (enc)\n\n接下来又是两段异或，第一段可以通过已知的flag反向解出v5，第二段异或根据已知数组和v5异或解出flag\nkey = &#x27;&#x27;enc1 = &#x27;flag&#x27;dec = &#x27;&#x27;enc = [0x40,0x35,0x20,0x56,0x5D,0x18,0x22,0x45,0x17,0x2F,0x24,0x6E,0x62,0x3C,0x27,0x54,0x48,0x6C,0x24,0x6E,0x72,0x3C,0x32,0x45,0x5B]for i in range(4):    key += chr(enc[i] ^ ord(enc1[i]))print (key)for i in range(len(enc)):    dec += chr(enc[i] ^ ord(key[i%4]))print(dec)#flag&#123;Act1ve_Defen5e_Test&#125;\n\n5.5[CISCN 2022 东北]easycpp今年的全国大学生信息安全竞赛快开了，做做往年的题\n这个应该是一个签到\n主程序逻辑非常简单，直接上脚本：\n#include &lt;iostream&gt;using namespace std;unsigned char miwen[] =&#123;  0x0A, 0x0B, 0x7D, 0x2F, 0x7F, 0x67, 0x65, 0x30, 0x63, 0x60,  0x37, 0x3F, 0x3C, 0x3F, 0x33, 0x3A, 0x3C, 0x3B, 0x35, 0x3C,  0x3E, 0x6C, 0x64, 0x31, 0x64, 0x6C, 0x3B, 0x68, 0x61, 0x62,  0x65, 0x36, 0x33, 0x60, 0x62, 0x36, 0x1C, 0x7D&#125;;int main()&#123;\tfor (int i = 37; i &gt;=3; i--)\t&#123;\t\tmiwen[i-1] ^= miwen[i];\t\tmiwen[i-2] ^= miwen[i-1];\t\tmiwen[i-3] ^= miwen[i-2];\t&#125;\tfor (int i = 0; i &lt; 38; i++)\t&#123;\t\tprintf(&quot;%c&quot;, miwen[i]);\t&#125;\treturn  0;&#125;\n\nAnCTFxD^3CTF：d3sky还是没看汇编的习惯，人家悄悄把密钥变了都没发现\n首先是一个tls反调试，修改标志位跳过，接着就不能看f5的伪代码了，看汇编：\n\n可以看到有try，except的代码，说明程序通过异常来控制执行流程，其中就有一个除零异常，但是按理来说动调时候应该是会触发的，但是没有（这里我还没有完全看明白，大概猜测还是与在调试的状态有关），那么先假设他触发了除零异常了，接下来就会跳转到loc_6310EF那里继续执行，在密钥后面又加上了一个字符串（这才是真正的密钥）。利用这个密钥初始化了s盒，解密opcode最后一部分，长度为74\n接下来是一个虚拟机：\n​\t进入虚拟机，每次解密3个opcode，然后执行opcode，最后再加密回去\nenc = [36, 11, 109, 15, 3, 50, 66, 29, 43, 67, 120, 67, 115, 48, 43, 78, 99, 72, 119, 46, 50, 57, 26, 18, 113, 122, 66, 23, 69, 114, 86, 12, 92, 74, 98, 83, 51]dec = [0] * 37dec[-1] = 126for i in range(32, -1, -4):  dec[i] = enc[i] ^ enc[i+1] ^ dec[i+4]dec[33] = enc[33] ^ enc[34] ^ dec[0]for i in range(29, 0, -4):  dec[i] = enc[i] ^ enc[i+1] ^ dec[i+4]dec[2] = enc[-1] ^ dec[0] ^ dec[1] ^ dec[-1]for i in range(3, 37):  dec[i] = enc[i-3] ^ dec[i-1] ^ dec[i-2] ^ dec[i-3]print(bytes(dec))\n\n5.6Reverse主要逻辑：\n sub_401AD0();  strcpy(v5, &quot;1A2F943C4D8C5B6EA3C9BCAD7E&quot;);  v0 = 0;  v5[27] = 0;  v6 = 0;  do  &#123;    *(_DWORD *)&amp;v7[v0] = 0;    v0 += 4;  &#125;  while ( v0 &lt; 0x20 );  puts(&quot;input your key:&quot;);  scanf(&quot;%s&quot;, v7);  v1 = strlen(v7);  if ( v1 &lt;= 19 )  &#123;    printf(&quot;too short!&quot;);    return -1;  &#125;  else if ( v1 &gt; 30 )  &#123;    printf(&quot;too long!&quot;);    return -1;  &#125;  else  &#123;    if ( sub_4014A0(v7, v5, v1) )      printf(&quot;congratulations, your input is the flag ^_^&quot;);    else      printf(&quot;try agian&quot;);    cnt = iob[0]._cnt - 1;    iob[0]._cnt = cnt;    if ( cnt &lt; 0 )    &#123;      filbuf((FILE *)iob[0]._ptr);      cnt = iob[0]._cnt;    &#125;    else    &#123;      ++iob[0]._ptr;    &#125;    v3 = cnt - 1;    iob[0]._cnt = v3;    if ( v3 &lt; 0 )      filbuf((FILE *)iob[0]._ptr);    else      ++iob[0]._ptr;    return 0;  &#125;&#125;\n\n关键函数sub_4014A0(v7, v5, v1)，跟进：\n v3 = 0;  v11 = 0;  do  &#123;    *(_DWORD *)&amp;v10[v3] = 0;    v3 += 4;  &#125;  while ( v3 &lt; ((v9 - v10 + 30) &amp; 0xFFFFFFFC) );  v9[0] = 15;  v9[1] = -121;  v10[0] = 98;  v10[1] = 20;  v10[2] = 1;  v10[3] = -58;  v10[4] = -16;  v10[5] = 33;  v10[6] = 48;  v10[7] = 17;  v10[8] = 80;  v10[9] = -48;  v10[10] = -126;  v10[11] = 35;  v10[12] = -82;  v10[13] = 35;  v10[14] = -18;  v10[15] = -87;  v10[16] = -76;  v10[17] = 82;  v10[18] = 120;  v10[19] = 87;  v10[20] = 12;  v10[21] = -122;  v10[22] = -117;  if ( a3 == 25 )  &#123;    for ( i = 0; i != 25; ++i )      v12[i] = __ROL1__(*(_BYTE *)(a1 + i), 2);    for ( j = 0; j != 25; ++j )      v12[j] ^= sub_401460(a2, j);    v7 = 15;    for ( k = 0; v12[k] == v7; v7 = v9[k] )    &#123;      if ( ++k == 25 )        return 1;    &#125;  &#125;  return 0;&#125;\n\n其中sub_401460没有flag参与，直接仿写就行\n抄的exp：\nkey = &#x27;1A2F943C4D8C5B6EA3C9BCAD7E&#x27;c = [0x0F, 0x87, 0x62, 0x14, 0x01, 0xC6, 0xF0, 0x21, 0x30, 0x11, 0x50, 0xD0, 0x82, 0x23, 0xAE, 0x23, 0xEE, 0xA9, 0xB4, 0x52, 0x78, 0x57, 0x0C, 0x86, 0x8B]flag = &#x27;&#x27;for i in range(25):    x = c[i] ^ int(key[i : i + 2], 16)    x = ((x &lt;&lt; 6) &amp; 0xff) | ((x &gt;&gt; 2) &amp; 0xff)    flag += chr(x)    print(flag)\n\nbad_python是一个被修改的的pyc文件， 根据文件名得到编译环境为python3.6，所以先百度正确的文件头是 33 0d 0d 0a 0c 63 4a 63 61 02 00 e3 00 00 00 。修改好后就可以正常反编译了\n# uncompyle6 version 3.8.0# Python bytecode 3.6 (3379)# Decompiled from: Python 3.6.0 (v3.6.0:41df79263a11, Dec 23 2016, 08:06:12) [MSC v.1900 64 bit (AMD64)]# Embedded file name: pyre.py# Compiled at: 2022-10-15 15:36:44# Size of source mod 2**32: 609 bytesfrom ctypes import *from Crypto.Util.number import bytes_to_longfrom Crypto.Util.number import long_to_bytes def encrypt(v, k):    v0 = c_uint32(v[0])    v1 = c_uint32(v[1])    sum1 = c_uint32(0)    delta = 195935983    for i in range(32):        v0.value += (v1.value &lt;&lt; 4 ^ v1.value &gt;&gt; 7) + v1.value ^ sum1.value + k[(sum1.value &amp; 3)]        sum1.value += delta        v1.value += (v0.value &lt;&lt; 4 ^ v0.value &gt;&gt; 7) + v0.value ^ sum1.value + k[(sum1.value &gt;&gt; 9 &amp; 3)]     return (     v0.value, v1.value)  if __name__ == &#x27;__main__&#x27;:    flag = input(&#x27;please input your flag:&#x27;)    k = [255, 187, 51, 68]    if len(flag) != 32:        print(&#x27;wrong!&#x27;)        exit(-1)    a = []    for i in range(0, 32, 8):        v1 = bytes_to_long(bytes(flag[i:i + 4], &#x27;ascii&#x27;))        v2 = bytes_to_long(bytes(flag[i + 4:i + 8], &#x27;ascii&#x27;))        a += encrypt([v1, v2], k)     enc = [     4006073346, 2582197823, 2235293281, 558171287, 2425328816, 1715140098, 986348143, 1948615354]    for i in range(8):        if enc[i] != a[i]:            print(&#x27;wrong!&#x27;)            exit(-1)     print(&#x27;flag is flag&#123;%s&#125;&#x27; % flag)# okay decompiling d:\\pyre.cpython-36.pyc\n\n简单的tea，逆写：\n#include&lt;stdio.h&gt;#define  u_int unsigned intint main()&#123;\tu_int enc[] = &#123; 4006073346, 2582197823, 2235293281, 558171287,\t\t\t\t2425328816, 1715140098, 986348143, 1948615354 &#125;;\tu_int k[] = &#123; 255, 187, 51, 68 &#125;;\tfor (int i = 0; i &lt; 8; i += 2)\t&#123;\t\tu_int delta = 195935983;\t\tu_int s1 = delta * 32;\t\tfor (int j = 0; j &lt; 32; j++)\t\t&#123;\t\t\tenc[i + 1] -= (enc[i] &lt;&lt; 4 ^ enc[i] &gt;&gt; 7) + enc[i] ^ s1 + k[s1 &gt;&gt; 9 &amp; 3];\t\t\ts1 -= delta;\t\t\tenc[i] -= (enc[i + 1] &lt;&lt; 4 ^ enc[i + 1] &gt;&gt; 7) + enc[i + 1] ^ s1 + k[s1 &amp; 3];\t\t&#125;\t&#125;\tchar flag[32] = &#123; 0 &#125;;\tfor (int i = 0; i &lt; 8; i++)\t&#123;\t\tflag[4 * i] = enc[i] &gt;&gt; 24;\t\tflag[4 * i + 1] = (enc[i] &gt;&gt; 16) ^ 0xFF000000;\t\tflag[4 * i + 2] = (enc[i] &gt;&gt; 8) ^ 0xFF000000;\t\tflag[4 * i + 3] = enc[i] ^ 0xFF000000;\t&#125;\tfor (int i = 0; i &lt; 32; i++)\t&#123;\t\tprintf(&quot;%c&quot;, flag[i]);\t&#125;&#125;\n\n5.7TEA魔改的xtea加密：\nfor ( i = 0; i &lt;= 8; ++i ) &#123;   v5 = 0;   v6 = 256256256 * i;   v3 = i + 1;   do   &#123;     ++v5;     *(a1 + 4i64 * i) += v6 ^ (*(a1 + 4i64 * v3) + ((*(a1 + 4i64 * v3) &gt;&gt; 5) ^ (16 * *(a1 + 4i64 * v3)))) ^ (v6 + *(a2 + 4i64 * (v6 &amp; 3)));     *(a1 + 4i64 * v3) += (v6 + *(a2 + 4i64 * ((v6 &gt;&gt; 11) &amp; 3))) ^ (*(a1 + 4i64 * i)                                                                  + ((*(a1 + 4i64 * i) &gt;&gt; 5) ^ (16 * *(a1 + 4i64 * i))));     v6 += 256256256;   &#125;   while ( v5 &lt;= 0x20 );   result = (i + 1); &#125;\n\n其中do{}内的是tea加密的算法，外层套了个for（）循环，因为原文有10个整数\n解密脚本：\nint main()&#123;    for (int i = 8; i &gt;= 0; --i)//从后往前遍历    &#123;        int v5 = 0;        unsigned int v6 = 256256256 * (i+33);//detal  因为v6也就是detal在加密过程中一直加256256256，加了32次，所以逆的时候先求出最后的结果，并且要注意使用unsigned int                do//这个部分就完全逆过来，一共三步嘛，去原文那里对照着看一下，+=变-=，后面的内容不需要变，直接抄        &#123;            ++v5;            v6 -= 256256256;            a1[i + 1] -= (v6 + a2[(v6 &gt;&gt; 11) &amp; 3]) ^ (a1[i] + ((a1[i] &gt;&gt; 5) ^ (16 * a1[i])));            a1[i] -= v6 ^ (a1[i + 1] + ((a1[i + 1] &gt;&gt; 5) ^ (16 * a1[i + 1]))) ^ (v6 + a2[v6 &amp; 3]);                    &#125; while (v5 &lt;= 32);    &#125;    for (int i = 0; i &lt; 10; i++)//这里是原程序这样写的    &#123;        for (int j = 3; j &gt;= 0; j--)        &#123;            printf(&quot;%c&quot;, (a1[i] &gt;&gt; (j * 8)) &amp; 0xFF);        &#125;    &#125;    return 0;&#125;\n\nxxxorrrmain函数：\n__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  int i; // [rsp+Ch] [rbp-34h]  char s[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v6; // [rsp+38h] [rbp-8h]   v6 = __readfsqword(0x28u);  sub_A90(sub_916);  fgets(s, 35, stdin);  for ( i = 0; i &lt;= 33; ++i )    s1[i] ^= s[i];  return 0LL\n\n输入的s1与s1的元素进行异或，点击sub_916函数找s1\nunsigned __int64 sub_916()&#123;  unsigned __int64 v1; // [rsp+8h] [rbp-8h]   v1 = __readfsqword(0x28u);  if ( !strcmp(s1, s2) )    puts(&quot;Congratulations!&quot;);  else    puts(&quot;Wrong!&quot;);  return __readfsqword(0x28u) ^ v1;&#125;#.data:0000000000201060 s2              db &#x27;VNWXQQ&#x27;,9,&#x27;F&#x27;       ; DATA XREF: sub_916+17↑o.data:0000000000201068                 db  17h.data:0000000000201069                 db  46h ; F.data:000000000020106A                 db  54h ; T.data:000000000020106B                 db  5Ah ; Z.data:000000000020106C                 db  59h ; Y.data:000000000020106D                 db  59h ; Y.data:000000000020106E                 db  1Fh.data:000000000020106F                 db  48h ; H.data:0000000000201070                 db  32h ; 2.data:0000000000201071                 db  5Bh ; [.data:0000000000201072                 db  6Bh ; k.data:0000000000201073                 db  7Ch ; |.data:0000000000201074                 db  75h ; u.data:0000000000201075                 db  6Eh ; n.data:0000000000201076                 db  7Eh ; ~.data:0000000000201077                 db  6Eh ; n.data:0000000000201078                 db  2Fh ; /.data:0000000000201079                 db  77h ; w.data:000000000020107A                 db  4Fh ; O.data:000000000020107B                 db  7Ah ; z.data:000000000020107C                 db  71h ; q.data:000000000020107D                 db  43h ; C.data:000000000020107E                 db  2Bh ; +.data:000000000020107F                 db  26h ; &amp;.data:0000000000201080                 db  89h\n\nexp：\ns2=[ 0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46,   0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C,   0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43,   0x2B, 0x26, 0x89, 0xFE, 0x00]s1 = &#x27;qasxcytgsasxcvrefghnrfghnjedfgbhn&#x27;flag=&#x27;&#x27;for i in range(33): \tflag+=chr(ord(s1[i])^ (2 * i + 65)^s2[i])print(flag)# flag&#123;c0n5truct0r5_functi0n_in_41f&#125;\n\n5.8ISCC  Convert今天做了两道ISCC的题目，这个比赛还没结束，不可以写wp捏。贴张截图\n\ntestre主要逻辑：\n__int64 __fastcall sub_400700(void *a1, _QWORD *a2, __int64 a3, size_t a4)&#123;  unsigned __int8 *v4; // rcx  __int64 v6; // [rsp+0h] [rbp-C0h]  int c; // [rsp+8h] [rbp-B8h]  char v8; // [rsp+Fh] [rbp-B1h]  int v9; // [rsp+10h] [rbp-B0h]  bool v10; // [rsp+17h] [rbp-A9h]  unsigned __int8 *v11; // [rsp+18h] [rbp-A8h]  char v12; // [rsp+27h] [rbp-99h]  int v13; // [rsp+28h] [rbp-98h]  int v14; // [rsp+2Ch] [rbp-94h]  unsigned __int64 i; // [rsp+30h] [rbp-90h]  size_t n; // [rsp+38h] [rbp-88h]  size_t v17; // [rsp+40h] [rbp-80h]  size_t v18; // [rsp+48h] [rbp-78h]  size_t j; // [rsp+50h] [rbp-70h]  size_t v20; // [rsp+58h] [rbp-68h]  int v21; // [rsp+64h] [rbp-5Ch]  unsigned __int64 v22; // [rsp+68h] [rbp-58h]  int v23; // [rsp+74h] [rbp-4Ch]  __int64 *v24; // [rsp+78h] [rbp-48h]  __int64 v25; // [rsp+80h] [rbp-40h]  void *v26; // [rsp+88h] [rbp-38h]  int v27; // [rsp+94h] [rbp-2Ch]  size_t v28; // [rsp+98h] [rbp-28h]  __int64 v29; // [rsp+A0h] [rbp-20h]  _QWORD *v30; // [rsp+A8h] [rbp-18h]  void *s; // [rsp+B0h] [rbp-10h]  char v32; // [rsp+BFh] [rbp-1h]  s = a1;  v30 = a2;  v29 = a3;  v28 = a4;  v27 = -559038737;  v26 = malloc(0x100uLL);  v25 = v29;  v24 = &amp;v6;  v22 = 0LL;  v17 = 0LL;  for ( i = 0LL; i &lt; v28; ++i )  &#123;    v13 = *(unsigned __int8 *)(v25 + i);    *((_BYTE *)v26 + i) = byte_400E90[i % 0x1D] ^ v13;    *((_BYTE *)v26 + i) += *(_BYTE *)(v25 + i);  &#125;  while ( 1 )  &#123;    v12 = 0;    if ( v17 &lt; v28 )      v12 = ~(*(_BYTE *)(v25 + v17) != 0);    if ( !(v12 &amp; 1) )      break;    ++v17;  &#125;  n = ((unsigned __int64)(0x28F5C28F5C28F5C3LL * (unsigned __int128)(138 * (v28 - v17) &gt;&gt; 2) &gt;&gt; 64) &gt;&gt; 2) + 1;  v23 = ((unsigned __int64)(0xAAAAAAAAAAAAAAABLL * (unsigned __int128)((v17 + v28) &lt;&lt; 6) &gt;&gt; 64) &gt;&gt; 5) - 1;  v11 = (unsigned __int8 *)&amp;v6      - ((((unsigned __int64)(0x28F5C28F5C28F5C3LL * (unsigned __int128)(138 * (v28 - v17) &gt;&gt; 2) &gt;&gt; 64) &gt;&gt; 2) + 16) &amp; 0xFFFFFFFFFFFFFFF0LL);  memset(v11, 0, n);  v20 = v17;  v18 = n - 1;  while ( v20 &lt; v28 )  &#123;    v21 = *(unsigned __int8 *)(v25 + v20);    for ( j = n - 1; ; --j )    &#123;      v10 = 1;      if ( j &lt;= v18 )        v10 = v21 != 0;      if ( !v10 )        break;      v22 = v11[j] &lt;&lt; 6;      v21 += v11[j] &lt;&lt; 8;      v9 = 64;      v11[j] = v21 % 58;      *((_BYTE *)v26 + j) = v22 &amp; 0x3F;      v22 &gt;&gt;= 6;      v21 /= 58;      v27 /= v9;      if ( !j )        break;    &#125;    ++v20;    v18 = j;  &#125;  for ( j = 0LL; ; ++j )  &#123;    v8 = 0;    if ( j &lt; n )      v8 = ~(v11[j] != 0);    if ( !(v8 &amp; 1) )      break;  &#125;  if ( *v30 &gt; n + v17 - j )  &#123;    if ( v17 )    &#123;      c = 61;      memset(s, 49, v17);      memset(v26, c, v17);    &#125;    v20 = v17;    while ( j &lt; n )    &#123;      v4 = v11;      *((_BYTE *)s + v20) = byte_400EB0[v11[j]];      *((_BYTE *)v26 + v20++) = byte_400EF0[v4[j++]];    &#125;    *((_BYTE *)s + v20) = 0;    *v30 = v20 + 1;    if ( !strncmp((const char *)s, &quot;D9&quot;, 2uLL)      &amp;&amp; !strncmp((const char *)s + 20, &quot;Mp&quot;, 2uLL)      &amp;&amp; !strncmp((const char *)s + 18, &quot;MR&quot;, 2uLL)      &amp;&amp; !strncmp((const char *)s + 2, &quot;cS9N&quot;, 4uLL)      &amp;&amp; !strncmp((const char *)s + 6, &quot;9iHjM&quot;, 5uLL)      &amp;&amp; !strncmp((const char *)s + 11, &quot;LTdA8YS&quot;, 7uLL) )    &#123;      HIDWORD(v6) = puts(&quot;correct!&quot;);    &#125;    v32 = 1;    v14 = 1;  &#125;  else  &#123;    *v30 = n + v17 - j + 1;    v32 = 0;    v14 = 1;  &#125;  return v32 &amp; 1;&#125;\n\n可以看到最后是s跟D9cS9N9iHjMLTdA8YSMRMp作比较而s来自于v11\n分析一下可能得到是base58编码，解码即可：base58_is_boring\n5.9ISCC  Pull the Wool Over People’s Eyes比赛还是没结束捏，不能写wp\n[CISCN 2022 东北]hanaupx壳，使用工具脱掉，幸好我有两个脱壳工具，只有一个能用，动调断在输入处，可以看到加密只有一个异或，比较处也可以找到密文，key反查一下，抄的exp：\ncip = [0x56,0xEC,0xA0,0xDC,0x57,0x06,0xFE,0xA3,0xEB,0x72,0xEA,0x97,0xE2,0x87,0x03,0xAA,0x18,0x6A,0xF3,0xBE,0xBD,0xDA,0x79,0x0A,0x98,0x36,0x12,0x5C,0xE0,0x94,0x61,0x5A, 0x42,0xBC,0x4B,0x01,0x49,0x7B,0x5F]flag = &#x27;flag&#123;12345678876543211234567887654321&#125;&#x27;cip2 = [0x56,0xEC,0xA0,0xDC,0x57,0x07,0xF4,0xA3,0xE9,0x77,0xBF,0x93,0xBC,0x86,0x52,0xA5,0x14,0x6A,0xA5,0xBD,0xB5,0xD2,0x7F,0x0B,0x9B,0x67,0x1D,0x08,0xEF,0xC9,0x32,0x5D,0x43,0xED,0x1E,0x01,0x4B,0x7B,0x01]flag2 = &#x27;&#x27;key = []for i in range(len(flag)):    key.append(ord(flag[i])^cip[i])print keyfor i in range(len(key)):    flag2 += chr(key[i]^cip2[i])print flag2\n\n5.10[HNCTF 2022 WEEK2]e@sy_flower简单的花指令，找到冒红的地方，先u重定义，再将第一个字节改为nop，回到上面main函数那按p重建函数，f5即可反编译\n直接逆写即可：\nenc = list(&#x27;c~scvdzKCEoDEZ[^roDICUMC&#x27;)flag = []# 与 0x30异或for i in range(len(enc)):    flag.append(chr(ord(enc[i]) ^ 0x30))#for i in range(int(len(flag) / 2)):    tmp = flag[2 * i]    flag[2 * i] = flag[2 * i + 1]    flag[2 * i + 1] = tmpfor i in flag:    print(i, end=&#x27;&#x27;)        #NSSCTF&#123;Just_junk_Bytess&#125;\n\nluck_guyb = a.to_bytes(8, byteorder=&#x27;little&#x27;)print(b)c = list(b)print(c)flag = &#x27;&#x27;flag0 = &#x27;GXY&#123;do_not_&#x27;for i in range(8):    if i % 2 == 1:        flag += chr((c[i]) - 2)    else:        flag += chr((c[i]) - 1)print(flag0 + flag)\n\n5.11hackme__int64 __fastcall sub_400F8E(__int64 a1, __int64 a2)&#123;  char v3[136]; // [rsp+10h] [rbp-B0h]  int v4; // [rsp+98h] [rbp-28h]  char v5; // [rsp+9Fh] [rbp-21h]  int v6; // [rsp+A0h] [rbp-20h]  unsigned __int8 v7; // [rsp+A6h] [rbp-1Ah]  char v8; // [rsp+A7h] [rbp-19h]  int v9; // [rsp+A8h] [rbp-18h]  int v10; // [rsp+ACh] [rbp-14h]  int v11; // [rsp+B0h] [rbp-10h]  int v12; // [rsp+B4h] [rbp-Ch]  _BOOL4 v13; // [rsp+B8h] [rbp-8h]  int i; // [rsp+BCh] [rbp-4h]  sub_407470((__int64)&quot;Give me the password: &quot;, a2);  sub_4075A0((__int64)&quot;%s&quot;, v3);  for ( i = 0; v3[i]; ++i )    ;  v13 = i == 22;  v12 = 10;  do  &#123;    v9 = (signed int)sub_406D90(&quot;%s&quot;, v3) % 22;    v11 = 0;    v8 = byte_6B4270[v9];    v7 = v3[v9];    v6 = v9 + 1;    v10 = 0;    while ( v10 &lt; v6 )    &#123;      ++v10;      v11 = 1828812941 * v11 + 12345;    &#125;    v5 = v11 ^ v7;    if ( v8 != ((unsigned __int8)v11 ^ v7) )      v13 = 0;    --v12;  &#125;  while ( v12 );  if ( v13 )    v4 = sub_407470((__int64)&quot;Congras\\n&quot;);  else    v4 = sub_407470((__int64)&quot;Oh no!\\n&quot;);  return 0LL;&#125;\n\n解密：\nindex = [0x5F,0xF2,0x5E,0x8B,0x4E,0x0E,0xA3,0xAA,0xC7,0x93,0x81,0x3D,0x5F,0x74,0xA3,0x09,0x91,0x2B,0x49,0x28,0x93,0x67]flag = &#x27;&#x27;for i in range(22):    v6 = i + 1    v10 = 0    v11 = 0    while v10 &lt; v6:        v10 = v10 + 1        v11 = 1828812941 * v11 + 12345    flag += chr((index[i]^v11)&amp;0xff)print (flag)\n\n\n\nSignInimport libnumfrom Crypto.Util.number import long_to_bytesq = 282164587459512124844245113950593348271p = 366669102002966856876605669837014229419e = 65537c = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35n = 103461035900816914121390101299049044413950405173712170434161686539878160984549 d = libnum.invmod(e, (p - 1) * (q - 1))\t\t#invmod(a, n) - 求a对于n的模逆,这里逆向加密过程中计算ψ(n)=(p-1)(q-1)，对ψ(n)保密,也就是对应根据e*d=1modψ(n),求出dm = pow(c, d, n)   # 这里的m是十进制形式,pow(x, y[, z])--函数是计算 x 的 y 次方，如果 z 在存在，则再对结果进行取模，其结果等效于 pow(x,y) %z，对应前面解密算法中M=D(C)=（C^d）mod nstring = long_to_bytes(m)  # 获取m明文print(string)\n\n5.12[强网杯 2022]GameMasterc#逆向 dnspy打开，可以看到main函数一开始就打开了gamemessage文件，这个文件也是题目给出的\nFileStream fileStream = File.OpenRead(&quot;gamemessage&quot;);int num = (int)fileStream.Length;Program.memory = new byte[num];fileStream.Position = 0L;fileStream.Read(Program.memory, 0, num);\n\n将该文件传给了memory，在goldfunc函数里异或了34\nfor (int i = 0; i &lt; Program.memory.Length; i++)&#123;\tbyte[] array = Program.memory;\tint num = i;\tarray[num] ^= 34;&#125;\n\n将memory 用AES，ECB 解密生成ExploitClass.dll\nbyte[] key = new byte[]&#123;\t66,\t114,\t97,\t105,\t110,\t115,\t116,\t111,\t114,\t109,\t105,\t110,\t103,\t33,\t33,\t33&#125;;ICryptoTransform cryptoTransform = new RijndaelManaged&#123;\tKey = key,\tMode = CipherMode.ECB,\tPadding = PaddingMode.Zeros&#125;.CreateDecryptor();Program.m = cryptoTransform.TransformFinalBlock(Program.memory, 0, Program.memory.Length);\n\n所以，解密：\ndata = open(&#x27;gamemessage&#x27;, &#x27;rb&#x27;).read()data = bytes([v^0x22 for v in data]) from Crypto.Cipher import AES key = bytes([0x42, 0x72, 0x61, 0x69, 110, 0x73, 0x74, 0x6f, 0x72, 0x6d, 0x69, 110, 0x67, 0x21, 0x21, 0x21])aes = AES.new(key,AES.MODE_ECB)m = aes.decrypt(data) pos = 0x13ebm = m[pos:]+m[:pos]open(&#x27;temp.dll&#x27;, &#x27;wb&#x27;).write(m)\n\n查看PE，发现了MZ文件头，把前面的删掉，还是一个c#程序，继续拖入dnspy\n先看看key是啥，仿写即可：\nprivate static void ParseKey(ulong[] L, byte[] Key)&#123;\tfor (int i = 0; i &lt; 3; i++)\t&#123;\t\tfor (int j = 0; j &lt; 4; j++)\t\t&#123;\t\t\tKey[i * 4 + j] = (byte)((L[i] &gt;&gt; j * 8) &amp; 255UL);\t\t&#125;\t&#125;&#125;\n\ncheck函数：\nprivate static void Check1(ulong x, ulong y, ulong z, byte[] KeyStream)&#123;\tint num = -1;\tfor (int i = 0; i &lt; 320; i++)\t&#123;\t\tx = (((x &gt;&gt; 29) ^ (x &gt;&gt; 28) ^ (x &gt;&gt; 25) ^ (x &gt;&gt; 23)) &amp; 1UL) | (x &lt;&lt; 1);\t\ty = (((y &gt;&gt; 30) ^ (y &gt;&gt; 27)) &amp; 1UL) | (y &lt;&lt; 1);\t\tz = (((z &gt;&gt; 31) ^ (z &gt;&gt; 30) ^ (z &gt;&gt; 29) ^ (z &gt;&gt; 28) ^ (z &gt;&gt; 26) ^ (z &gt;&gt; 24)) &amp; 1UL) | (z &lt;&lt; 1);\t\tbool flag = i % 8 == 0;\t\tif (flag)\t\t&#123;\t\t\tnum++;\t\t&#125;\t\tKeyStream[num] = (byte)((long)((long)KeyStream[num] &lt;&lt; 1) | (long)((ulong)((uint)(((z &gt;&gt; 32) &amp; 1UL &amp; ((x &gt;&gt; 30) &amp; 1UL)) ^ ((((z &gt;&gt; 32) &amp; 1UL) ^ 1UL) &amp; ((y &gt;&gt; 31) &amp; 1UL))))));\t&#125;&#125;\n\n\n\nz3解方程：\nimport z3first=[101,5,80,213,163,26,59,38,19,6,173,189,198,166,140,183,42,247,223,24,106,20,145,37,24,7,22,191print(len(first))tmp=len(first)*[0]num = -1x = z3.BitVec(&quot;v1&quot;, 64) #64位的v1y = z3.BitVec(&quot;v2&quot;, 64)z = z3.BitVec(&quot;v3&quot;, 64)for i in range(0,320):x = (((x &gt;&gt; 29 ^ x &gt;&gt; 28 ^ x &gt;&gt; 25 ^ x &gt;&gt; 23) &amp; 1) | x &lt;&lt; 1)y = (((y &gt;&gt; 30 ^ y &gt;&gt; 27) &amp; 1) | y &lt;&lt; 1)z = (((z &gt;&gt; 31 ^ z &gt;&gt; 30 ^ z &gt;&gt; 29 ^ z &gt;&gt; 28 ^ z &gt;&gt; 26 ^ z &gt;&gt; 24) &amp; 1) | z &lt;&lt; 1)if i%8==0:num+=1tmp[num] = tmp[num] &lt;&lt; 1 | (z &gt;&gt; 32 &amp; 1 &amp; (x &gt;&gt; 30 &amp; 1)) ^ (((z &gt;&gt; 32 &amp; 1) ^ 1) &amp; (y &gt;&gt; 31 &amp; 1)solver = z3.Solver()for i in range(len(first)):solver.add(first[i] == tmp[i])solver.check()print(solver.model())# [v3 = 3131229747, v1 = 156324965, v2 = 868387187\n\nexp：\nl=[156324965, 868387187, 3131229747]arr=[0]*12for i in range(3):    for j in range(4):        arr[i*4+j]=(l[i]&gt;&gt;j*8)&amp;0xffenc=[60, 100, 36, 86, 51, 251, 167, 108, 116, 245,\t\t\t\t207, 223, 40, 103, 34, 62, 22, 251, 227]for i in range(len(enc)):    print(chr(enc[i]^arr[i%len(arr)]),end=&#x27;&#x27;)\n\nxctf babymipsmain函数：\nint __fastcall main(int a1, char **a2, char **a3)&#123;  int result; // $v0  int i; // [sp+18h] [+18h] BYREF  char v5[36]; // [sp+1Ch] [+1Ch] BYREF  setbuf((FILE *)stdout, 0);  setbuf((FILE *)stdin, 0);  printf(&quot;Give me your flag:&quot;);  scanf(&quot;%32s&quot;, v5);  for ( i = 0; i &lt; 32; ++i )    *((_BYTE *)&amp;i + i + 4) ^= 32 - (_BYTE)i;  if ( !strncmp(v5, fdata, 5u) )    result = sub_4007F0(v5);  else    result = puts(&quot;Wrong&quot;);  return result;&#125;\n\nint __fastcall sub_4007F0(const char *a1)&#123;  char v1; // $v1  int result; // $v0  size_t i; // [sp+18h] [+18h]  for ( i = 5; i &lt; strlen(a1); ++i )  &#123;    if ( (i &amp; 1) != 0 )      v1 = (a1[i] &gt;&gt; 2) | (a1[i] &lt;&lt; 6);  //把低二位和高六位进行交换    else      v1 = (4 * a1[i]) | (a1[i] &gt;&gt; 6);    a1[i] = v1;  &#125;  if ( !strncmp(a1 + 5, (const char *)off_410D04, 0x1Bu) )    result = puts(&quot;Right!&quot;);  else    result = puts(&quot;Wrong!&quot;);  return result;&#125;\n\nexp：\npart1=b&#x27;Q|j&#123;g&#x27;part2=&#x27;52 fd 16 a4 89 bd 92 80 13 41 54 a0 8d 45 18 81 de fc 95 f0 16 79 1a 15 5b 75 1f&#x27;part2=list(bytes.fromhex(part2))for i in range(5,len(part2)+5):    t = part2[i-5]    if i&amp;1==0:   #偶数时&amp;1 为0        part2[i-5]=(t&amp;0x3)&lt;&lt;6|(t&amp;0xfc)&gt;&gt;2   #低2位左移6位，高6位右移2位  相当于循环右移2位    else:        part2[i-5]=(t&amp;0x3f)&lt;&lt;2|(t&amp;0xc0)&gt;&gt;6  #低6位左移2位，高2位右移6位  相当于循环左移2位temp=list(part1)+part2flag=&#x27;&#x27;for i in range(len(temp)):    flag+=chr(temp[i]^0x20 -i)print(flag)\n\n5.13litctf 逆向wp | shimmer’s blog (shimmer123456.github.io)5.14春秋杯 Poisoned_tea_CHELL（壳是真难脱啊，还好我脱掉了）春秋杯 sum比赛还没结束捏，不能写wp，（目前为止逆向ak，嘿嘿）贴个图算了：\n\n5.15[SWPUCTF 2021 新生赛]fakebaseflag = &#x27;xxxxxxxxxxxxxxxxxxx&#x27;s_box = &#x27;qwertyuiopasdfghjkzxcvb123456#$&#x27;tmp = &#x27;&#x27;for i in flag:    tmp += str(bin(ord(i)))[2:].zfill(8)b1 = int(tmp,2)s = &#x27;&#x27;while b1//31 != 0:    s += s_box[b1%31]    b1 = b1//31print(s)# s = u#k4ggia61egegzjuqz12jhfspfkay\n\n其中s的值都是s_box中取的，因此[b1%31]是可以得知的。也就是\ns_box = &#x27;qwertyuiopasdfghjkzxcvb123456#$&#x27;s = &#x27;u#k4ggia61egegzjuqz12jhfspfkay&#x27;for i in s:\tb1 = k*31+s_box.index(i)\n\n我们是从0开始爆破，因为b1是从大每次整除31，依次减小的，因此我们s选好 是需要逆序。因此：\ns_box = &#x27;qwertyuiopasdfghjkzxcvb123456#$&#x27;s = &#x27;u#k4ggia61egegzjuqz12jhfspfkay&#x27;for k in range(5):\tb1=k\tfor i in s[::-1]:\t\tb1 = b1*31+s_box.index(i)\n\n最后直接将整数转换为字符串即可：\nimport libnums_box = &#x27;qwertyuiopasdfghjkzxcvb123456#$&#x27;s = &#x27;u#k4ggia61egegzjuqz12jhfspfkay&#x27;for k in range(5):\tb1=k\tfor i in s[::-1]:\t\tb1 = b1*31+s_box.index(i)\tprint(libnum.n2s(int(b1)))\n\n\n\n[SWPUCTF 2021 新生赛]fakerandom逆着逻辑好了\nimport randomrandom.seed(1)l = []flag=“”for i in range(4):l.append(random.getrandbits(8))result = [201, 8, 198, 68, 131, 152, 186, 136, 13, 130, 190, 112, 251, 93, 212, 1, 31, 214, 116, 244]for i in range(len(l)):random.seed(l[i])for n in range(5):flag+=chr(result[i*5+n]^random.getrandbits(8))print(flag)#NSSCTF&#123;FakeE_random&#125;\n\n5.16[HGAME 2022 week1]easyasm附件是16位的MS-DOS程序，用IDA分析start函数，代码不多，大意是将flag的每个字符前四位和后四位进行置换，然后与0x17异或，再与密文逐位比较。\n#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main()&#123;\tunsigned char cipher[] =\t&#123;\t  0x91, 0x61, 0x01, 0xC1, 0x41, 0xA0, 0x60, 0x41, 0xD1, 0x21, \t  0x14, 0xC1, 0x41, 0xE2, 0x50, 0xE1, 0xE2, 0x54, 0x20, 0xC1, \t  0xE2, 0x60, 0x14, 0x30, 0xD1, 0x51, 0xC0, 0x17\t&#125;;\t\tfor(int i=0; i&lt;28; i++)\t&#123;\t\tunsigned char tmp = cipher[i]^0x17;\t\tprintf(&quot;%c&quot;, (tmp&lt;&lt;4)+(tmp&gt;&gt;4));\t&#125;&#125; \n\n[WUSTCTF 2020]level3 __int64 O_OLookAtYou()&#123;  __int64 result; // rax  char v1; // [rsp+1h] [rbp-5h]  int i; // [rsp+2h] [rbp-4h]  for ( i = 0; i &lt;= 9; ++i )  &#123;    v1 = base64_table[i];    base64_table[i] = base64_table[19 - i];    result = 19 - i;    base64_table[result] = v1;  &#125;  return result;&#125;//数据交换v1=base64_table[0:9]base64_table[0:9]=base64_table[19:10]base64_table[19:10]=base64_table[0:9]ABCDEFGHIJ KLMNOPQRST UVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/TSRQPONMLK JIHGFEDCBA UVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\n\n\n\nimport base64import stringstring = &quot;d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==&quot;tableBase64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;tableNew =    &quot;TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;maketrans = str.maketrans(tableNew, tableBase64)translate = string.translate(maketrans)flag = base64.b64decode(translate)print (flag)\n\n5.17[BJDCTF 2020]Easy AmtuOrRFIDA pro 动调\n1.先在 0x00401723 断点 方便查看flag\n2.在0x0401773断点 运行到此\n3.然后修改EIP 为 0x0401520\n4.继续运行看cmd窗口得到flag\nHACKIT4FUN\n[HNCTF 2022 Week1]X0rflag = &#x27;&#x27;f2 = [0x3FE, 0x3EB,0x3EB, 0x3FB, 0x3E4, 0x3F6, 0x3D3, 0x3D0, 0x388, 0x3CA, 0x3EF, 0x389, 0x3CB, 0x3EF, 0x3CB, 0x388, 0x3EF, 0x3D5, 0x3D9, 0x3CB, 0x3D1, 0x3CD]for i in range(0,22):    flag+=chr((f2[i]-900)^0x34)print(flag)\n\n5.19[2023春秋杯  sum]main函数：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v3; // rbp  int v4; // r14d  unsigned int v5; // r12d  __int64 i; // rbx  char v7; // al  int v8; // eax  const char *v9; // rax  v3 = (char *)&amp;matrix;  v4 = 1;  v5 = 0;  puts(&quot;Welcome to Solver!&quot;);  do  &#123;    for ( i = 0LL; i != 9; ++i )    &#123;      if ( !v3[i] )      &#123;        v7 = getchar();        if ( (unsigned __int8)(v7 - 49) &gt; 8u )          v4 = 0;        else          v3[i] = v7 - 48;      &#125;      v8 = v3[i];      v5 += v8;    &#125;    v3 += 9;  &#125;  while ( v3 != (char *)&amp;matrix + 81 );  if ( v4 &amp;&amp; (unsigned int)verify(&quot;Welcome to Solver!&quot;, argv) )  &#123;    puts(&quot;You Win!&quot;);    __snprintf_chk(buf, 32LL, 1LL, 32LL, &quot;%d&quot;, v5);    v9 = (const char *)str2md5(buf, strlen(buf));    __printf_chk(1LL, &quot;flag is: flag&#123;%s&#125;\\n\\n&quot;, v9);    exit(0);  &#125;  puts(&quot;Again~&quot;);  return 0;&#125;\n\n首先是一个do while嵌套for的一个81次的循环，循环时当v3[i]的值等于0，会让用户输入一个字符，并且该输入必须在0-9之间\n那么接下来进入verify函数：\n不仔细看的话中等复杂，但他肯定是一段验证程序，因为它在if条件里嘛，满足条件就是win了。分析的话要么动调，要么为了省事直接问gpt（这个题效果还不错，有时候小心他会胡说八道）：\nsolve：\n知道是数独，提取出81个数据，找个在线网站解一下数独，再运行程序填进去flag就输出了\n[GDOUCTF 2023]doublegame直接运行程序是一个贪吃蛇游戏，撞壁游戏就结束了。\n拖入ida，因为没有main函数，所以通过字符串来定位关键逻辑，看到挺多0，跟进去，来到了这么一个函数：\nvoid __noreturn sub_140012CF0()&#123;  char *v0; // rdi  __int64 i; // rcx  char v2; // [rsp+20h] [rbp+0h] BYREF  char Buffer[22]; // [rsp+30h] [rbp+10h] BYREF  char v4[44]; // [rsp+46h] [rbp+26h] BYREF  char v5[44]; // [rsp+72h] [rbp+52h] BYREF  char v6[44]; // [rsp+9Eh] [rbp+7Eh] BYREF  char v7[44]; // [rsp+CAh] [rbp+AAh] BYREF  char v8[44]; // [rsp+F6h] [rbp+D6h] BYREF  char v9[44]; // [rsp+122h] [rbp+102h] BYREF  char v10[44]; // [rsp+14Eh] [rbp+12Eh] BYREF  char v11[44]; // [rsp+17Ah] [rbp+15Ah] BYREF  char v12[44]; // [rsp+1A6h] [rbp+186h] BYREF  char v13[66]; // [rsp+1D2h] [rbp+1B2h] BYREF  int j; // [rsp+214h] [rbp+1F4h]  int v15; // [rsp+234h] [rbp+214h]  int v16; // [rsp+254h] [rbp+234h]  int v17; // [rsp+274h] [rbp+254h]  int v18; // [rsp+294h] [rbp+274h]  _DWORD v19[25]; // [rsp+2C0h] [rbp+2A0h] BYREF  char v20[100]; // [rsp+324h] [rbp+304h] BYREF  char v21[828]; // [rsp+388h] [rbp+368h] BYREF  char v22; // [rsp+6C4h] [rbp+6A4h]  int v23; // [rsp+6E4h] [rbp+6C4h]  int v24; // [rsp+704h] [rbp+6E4h]  v0 = &amp;v2;  for ( i = 448i64; i; --i )  &#123;    *(_DWORD *)v0 = -858993460;    v0 += 4;  &#125;  sub_14001141A(&amp;unk_1400290A6);  strcpy(Buffer, &quot;000000000000000000000&quot;);  strcpy(v4, &quot;0 0 0 0     0     0 0&quot;);  strcpy(&amp;v4[22], &quot;0 0 0 00000 00000 0 0&quot;);  strcpy(v5, &quot;0 0               0 0&quot;);  strcpy(&amp;v5[22], &quot;0 000 000 0 000 0 0 0&quot;);  strcpy(v6, &quot;0 0     0 0 0   0 0 0&quot;);  strcpy(&amp;v6[22], &quot;0 0 0 00000 000 000 0&quot;);  strcpy(v7, &quot;0 0 0     0   0 0    &quot;);  strcpy(&amp;v7[22], &quot;0 000 0 0 000 0 0 0 0&quot;);  strcpy(v8, &quot;0     0 0 0 0 0 0 0 0&quot;);  strcpy(&amp;v8[22], &quot;0 00000 000 000 0 0 0&quot;);  strcpy(v9, &quot;0     0       0   0 0&quot;);  strcpy(&amp;v9[22], &quot;000 0 0 0 000 0 0 0 0&quot;);  strcpy(v10, &quot;0 0 0 0 0 0 * 0 0 0 0&quot;);  strcpy(&amp;v10[22], &quot;0 0000000 0 000 00000&quot;);  strcpy(v11, &quot;@       0 0         0&quot;);  strcpy(&amp;v11[22], &quot;0 0 0 0 0 00000000000&quot;);  strcpy(v12, &quot;0 0 0 0             0&quot;);  strcpy(&amp;v12[22], &quot;000 0 00000 0 000 000&quot;);  strcpy(v13, &quot;0         0 0   0   0&quot;);  strcpy(&amp;v13[22], &quot;000000000000000000000&quot;);  v11[4] = 48;  strcpy((char *)v19, &quot;Please to save the cat!&quot;);  memset(&amp;v19[6], 0, 0x4Cui64);  strcpy(v20, &quot;the score is saving cat&#x27;s key!\\n&quot;);  memset(&amp;v20[32], 0, 0x44ui64);  qmemcpy(v21, &amp;unk_14001D340, 0x47ui64);  memset(&amp;v21[71], 0, 729);  sub_1400111F9(&quot;path\\n&quot;);  v23 = 0;  v24 = 0;  v15 = 15;  v16 = 0;  v17 = 7;  v18 = 20;  for ( j = 0; j &lt;= 20; ++j )    puts(&amp;Buffer[22 * j]);  sub_1400111F9(&quot;Please to save the cat!\\n&quot;);  while ( v15 != v17 || v16 != v18 )  &#123;    v22 = getchar();    switch ( v22 )    &#123;      case &#x27;s&#x27;:        if ( Buffer[22 * v15 + 22 + v16] != 48 )        &#123;          Buffer[22 * v15++ + v16] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      case &#x27;w&#x27;:        if ( Buffer[22 * v15 - 22 + v16] != 48 )        &#123;          Buffer[22 * v15-- + v16] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      case &#x27;a&#x27;:        if ( Buffer[22 * v15 - 1 + v16] != 48 )        &#123;          if ( Buffer[22 * v15 - 1 + v16] == 42 )            v7[20] = 48;          Buffer[22 * v15 + v16--] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      default:        if ( v22 == 100 &amp;&amp; Buffer[22 * v15 + 1 + v16] != 48 )        &#123;          Buffer[22 * v15 + v16++] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;    &#125;    system(&quot;cls&quot;);    for ( j = 0; j &lt;= 20; ++j )      puts(&amp;Buffer[22 * j]);    puts((const char *)&amp;v19[25 * v23]);    if ( v7[20] == 48 )    &#123;      v24 = sub_140011433(0i64);      if ( v24 == 13376013 )      &#123;        v23 = 1;        v7[20] = 32;        Buffer[22 * v15 + v16] = 32;        v15 = 15;        v16 = 0;        v11[0] = 64;        ++v23;      &#125;      else      &#123;        sub_1400111F9(&quot;error&quot;);      &#125;    &#125;  &#125;  system(&quot;cls&quot;);  Sleep(0x1F4u);  Sleep(0xBB8u);  sub_140011492();  exit(0);&#125;\n\n很明显是一个迷宫，但刚才的贪吃蛇哪去了（因为是double game啦），那么就再交叉引用看看谁调用了这个迷宫的函数，一直可以追到贪吃蛇游戏里\n这个dword_140022CD0就是当前得分了，当它＞13371337时就会跳转到迷宫游戏\n逻辑清楚了，那么在判断分数前下个断点，贪吃蛇游戏结束之后断下来，修改两次标志位（sf）跳转到迷宫游戏\n接下来通过wsad控制上下左右走迷宫，先把小猫救出来后，程序会让输入key（其实就是贪吃蛇分数13371337），也可以通过判断key的逻辑再把key逆出来：\n输入key之后，又回到原点了，再走一下迷宫，flag就是{key+md5(最短路径)}\n5.20[LitCTF 2023]enbase64变表base64，下断点dump出变表\n#pythondef basechange(source):destination = list(source)v3 = [16, 34, 56, 7, 46, 2, 10, 44, 20, 41, 59, 31, 51, 60, 61, 26, 5, 40, 21, 38, 4, 54, 52, 47, 3, 11, 58, 48, 32, 15, 49, 14, 37, 0, 55, 53, 24, 35, 18, 25, 33, 43, 50, 39, 12, 19, 13, 42, 9, 17, 28, 30, 23, 36, 1, 22, 57, 63, 8, 27, 6, 62, 45, 29]for i in range(48):for j in range(64):source[j] = destination[v3[j]]destination = source[:]return &#x27;&#x27;.join(destination)if __name__ == &#x27;__main__&#x27;:s =&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;result = basechange(list(s))print(result)\n\n5.21[GXYCTF 2019]luck_guyflag = &#x27;&#x27;f2 = [0x7F, 0x66, 0x6F, 0x60, 0x67, 0x75, 0x63, 0x69][::-1]s = &#x27;&#x27;for i in range(8):    if i % 2 == 1:        flag += chr((f2[i]) - 2)    else:        flag += chr((f2[i]) - 1)    # flag += sprint(flag)\n\n5.22[NISACTF 2022]ezpython使用pyinstxtractor解包exe\n使用010修复src.pyc的文件头\n#line 50:flag = &#x27;IAMrG1EOPkM5NRI1cChQDxEcGDZMURptPzgHJHUiN0ASDgUYUB4LGQMUGAtLCQcJJywcFmddNno/PBtQbiMWNxsGLiFuLwpiFlkyP084Ng0lKj8GUBMXcwEXPTJrRDMdNwMiHVkCBFklHgIAWQwgCz8YQhp6E1xUHgUELxMtSh0xXzxBEisbUyYGOx1DBBZWPg1CXFkvJEcxO0ADeBwzChIOQkdwXQRpQCJHCQsaFE4CIjMDcwswTBw4BS9mLVMLLDs8HVgeQkscGBEBFSpQFQQgPTVRAUpvHyAiV1oPE0kyADpDbF8AbyErBjNkPh9PHiY7O1ZaGBADMB0PEVwdCxI+MCcXARZiPhwfH1IfKitGOF42FV8FTxwqPzBPAVUUOAEKAHEEP2QZGjQVV1oIS0QBJgBDLx1jEAsWKGk5Nw03MVgmWSE4Qy5LEghoHDY+OQ9dXE44Th0=&#x27;key = &#x27;this is key&#x27;try:    result = input(&#x27;please input key: &#x27;)    if result == decrypt2(&#x27;AAAAAAAAAAAfFwwRSAIWWQ==&#x27;, key):        print(decrypt1(base64.b64decode(decrypt2(flag, result))))    else:        if result == key:            print(&#x27;flag&#123;0e26d898-b454-43de-9c87-eb3d122186bc&#125;&#x27;)        else:            print(&#x27;key is error.&#x27;)except Exception as e:    pass\n\n#line 50:flag = &#x27;IAMrG1EOPkM5NRI1cChQDxEcGDZMURptPzgHJHUiN0ASDgUYUB4LGQMUGAtLCQcJJywcFmddNno/PBtQbiMWNxsGLiFuLwpiFlkyP084Ng0lKj8GUBMXcwEXPTJrRDMdNwMiHVkCBFklHgIAWQwgCz8YQhp6E1xUHgUELxMtSh0xXzxBEisbUyYGOx1DBBZWPg1CXFkvJEcxO0ADeBwzChIOQkdwXQRpQCJHCQsaFE4CIjMDcwswTBw4BS9mLVMLLDs8HVgeQkscGBEBFSpQFQQgPTVRAUpvHyAiV1oPE0kyADpDbF8AbyErBjNkPh9PHiY7O1ZaGBADMB0PEVwdCxI+MCcXARZiPhwfH1IfKitGOF42FV8FTxwqPzBPAVUUOAEKAHEEP2QZGjQVV1oIS0QBJgBDLx1jEAsWKGk5Nw03MVgmWSE4Qy5LEghoHDY+OQ9dXE44Th0=&#x27;key = &#x27;this is key&#x27;print(decrypt1(base64.b64decode(decrypt2(flag, decrypt2(&#x27;AAAAAAAAAAAfFwwRSAIWWQ==&#x27;, key)))))\n\n5.23[HNCTF 2022 WEEK2]来解个方程?from z3 import *v2=[Int(&#x27;v2%s&#x27; %i) for i in range(22)]s=Solver()s.add(245 * v2[4] + 395 * v2[3] + 3541 * v2[2] + 2051 * v2[1] + 3201 * v2[0] + 1345 * v2[5] == 855009)s.add(3270 * v2[4] + 3759 * v2[3] + 3900 * v2[2] + 3963 * v2[1] + 1546 * v2[0] + 3082 * v2[5] == 1515490)s.add(526 * v2[4] + 2283 * v2[3] + 3349 * v2[2] + 2458 * v2[1] + 2012 * v2[0] + 268 * v2[5] == 854822)s.add(3208 * v2[4] + 2021 * v2[3] + 3146 * v2[2] + 1571 * v2[1] + 2569 * v2[0] + 1395 * v2[5] == 1094422)s.add(3136 * v2[4] + 3553 * v2[3] + 2997 * v2[2] + 1824 * v2[1] + 1575 * v2[0] + 1599 * v2[5] == 1136398)s.add(2300 * v2[4] + 1349 * v2[3] + 86 * v2[2] + 3672 * v2[1] + 2908 * v2[0] + 1681 * v2[5] == 939991)s.add( 212 * v2[20]       + 153 * v2[19]       + 342 * v2[18]     + 490 * v2[10]      + 325 * v2[9]       + 485 * v2[8]       + 56 * v2[7]       + 202 * v2[6]       + 191 * v2[21] == 245940)    s.add(348 * v2[20]       + 185 * v2[19]       + 134 * v2[18]       + 153 * v2[10]       + 460 * v2[7]       + 207 * v2[6]       + 22 * v2[8]       + 24 * v2[9]       + 22 * v2[21] == 146392)s.add(177 * v2[20]       + 231 * v2[19]       + 489 * v2[18]       + 339 * v2[10]       + 433 * v2[9]       + 311 * v2[8]       + 164 * v2[7]       + 154 * v2[6]       + 100 * v2[21] == 239438)s.add(68 * v2[18]       + 466 * v2[10]       + 470 * v2[9]       + 22 * v2[8]       + 270 * v2[7]       + 360 * v2[6]       + 337 * v2[19]       + 257 * v2[20]       + 82 * v2[21] == 233887)s.add(246 * v2[20]       + 235 * v2[19]       + 468 * v2[18]       + 91 * v2[10]       + 151 * v2[9]       + 197 * v2[6]       + 92 * v2[7]       + 73 * v2[8]       + 54 * v2[21] == 152663)s.add(241 * v2[20]       + 377 * v2[19]       + 131 * v2[18]       + 243 * v2[10]       + 233 * v2[9]       + 55 * v2[8]       + 376 * v2[7]       + 242 * v2[6]       + 343 * v2[21] == 228375)s.add(356 * v2[20]       + 200 * v2[19]       + 136 * v2[9]       + 301 * v2[8]       + 284 * v2[7]       + 364 * v2[6]       + 458 * v2[10]       + 5 * v2[18]       + 61 * v2[21] == 211183)s.add(154 * v2[20]       + 55 * v2[19]       + 406 * v2[18]       + 107 * v2[10]       + 80 * v2[8]       + 66 * v2[6]       + 71 * v2[7]       + 17 * v2[9]       + 71 * v2[21] == 96788)s.add( 335 * v2[20]       + 201 * v2[19]       + 197 * v2[9]       + 280 * v2[8]       + 409 * v2[7]       + 56 * v2[6]       + 494 * v2[10]       + 63 * v2[18]       + 99 * v2[21] == 204625)s.add(428 * v2[16] + 1266 * v2[15] + 1326 * v2[14] + 1967 * v2[13] + 3001 * v2[12] + 81 * v2[11] + 2439 * v2[17] == 1109296)s.add(2585 * v2[16] + 4027 * v2[15] + 141 * v2[14] + 2539 * v2[13] + 3073 * v2[12] + 164 * v2[11] + 1556 * v2[17] == 1368547)s.add(2080 * v2[16] + 358 * v2[15] + 1317 * v2[14] + 1341 * v2[13] + 3681 * v2[12] + 2197 * v2[11] + 1205 * v2[17] == 1320274)s.add(840 * v2[16] + 1494 * v2[15] + 2353 * v2[14] + 235 * v2[13] + 3843 * v2[12] + 1496 * v2[11] + 1302 * v2[17] == 1206735)s.add(101 * v2[16] + 2025 * v2[15] + 2842 * v2[14] + 1559 * v2[13] + 2143 * v2[12] + 3008 * v2[11] + 981 * v2[17] == 1306983)s.add(1290 * v2[16] + 3822 * v2[15] + 1733 * v2[14] + 292 * v2[13] + 816 * v2[12] + 1017 * v2[11] + 3199 * v2[17] == 1160573)s.add(186 * v2[16]                  + 2712 * v2[15]                  + 2136 * v2[14]                  + 98 * v2[11]                  + 138 * v2[12]                  + 3584 * v2[13]                  + 1173 * v2[17]==1005746)print(s.check())m=s.model()res=&#x27;&#x27;for i in range(0,22):    res+=(chr(m[v2[i]].as_long()))   print(res)\n\n5.24[GDOUCTF 2023]L！s！考察了bindiff插件的使用\n比较两个文件的不同之处，一般用来比较原文件和dump之后的文件\n先用ida随便打开一个文件，再关闭，生成集成的那个文件（i64），再用ida打开另一个文件，打开插件bindiff，选择Diff Database 打开刚刚的i64文件，就可以查看这两个文件的不同之处了\n密文提取出来：\nint aa[] = &#123; 0x04,0x16,0x0f,0x18,0x0a,0x37,0x2e,0x7d,0x22,0x28,0x25,0x2a,0x13,0x7d,0x3f,0x13,0x2d,0x13,0x39,0x3f,0x7f,0x2a,0x39,0x20,0x13,0x38,0x7c,0x7c,0x20,0x31&#125;;\n\n加密就仅仅只有一个异或v7，从0-256爆破遍，去结果里找flag\n\n还算好找\n5.26EasyDotnet月赛的一道题。c#逆向，加了confuserex的壳。\n用工具可以脱掉壳，但是会破坏程序，虽然源码能看到但程序不能动调，而这个题的源码里有字符串加密，要看字符串就必须动调看，所以这条路不行\n那么就考虑手动脱壳：\n仔细阅读代码可以发现，程序中 .static constructor() 是没有被加密的。阅读它调用的 第一个函数，可以发现其中调用了 Marshal.GetHINSTANCE() 和 kernel32.VirtualProtect() ，可 以猜测该函数是用于解密代码的。于是，在 .static constructor() 的第二行下断点，待 运行到该点之后，将程序的内存映像 dump 下来，完成脱壳\n注意这里的dump必须要在dnspy下边的那个模块那里保存，不能去左上角文件那里保存模块，这样保存的是整个文件，会报错\ndump之后再用dnspy打开，这个时候就可以看到main函数内有源码了，但是还有一些没回复，使用de4dot继续脱一下，就完整的脱掉了\n再看源码，有两处反调试nop掉，再逆逻辑就行了，是一个base32加密\n如何逆就不说了，主要是手动脱壳\n5.27  5.28这两天国赛，不太想写了\n5.29ciscn 2023 babyRE进入题目开头给的网站，可视化编程，真是baby  re了，导入xml文件，可以看到对输入的处理就是逐位与前一位异或，密文也给出，不过顺序有点不好搞，那么就插入一个for循环，让程序自己打印出密文\n5.30春秋杯 re wp | shimmer’s blog (shimmer123456.github.io)\n5.31春秋杯 re wp | shimmer’s blog (shimmer123456.github.io)\n6.1ciscn 逆向wp | shimmer’s blog (shimmer123456.github.io)\n6.2ciscn 逆向wp | shimmer’s blog (shimmer123456.github.io)\n6.3[MoeCTF 2022]chicken_soupenc = [0xcd,0x4d,0x8c,0x7d,0xad,0x1e,0xbe,0x4a,0x8a,0x7d,0xbc,0x7c,0xfc,0x2e,0x2a,0x79,0x9d,0x6a,0x1a,0xcc,0x3d,0x4a,0xf8,0x3c,0x79,0x69,0x39,0xd9,0xdd,0x9d,0xa9,0x69,0x4c,0x8c,0xdd,0x59,0xe9,0xd7]for i in range(len(enc)):\tenc[i] = ((enc[i]//16 | enc[i]&lt;&lt;4)) &amp; 0xff\tprint((enc[i]))for i in range(len(enc)-1, 0, -1):    enc[i-1] -= enc[i]print(bytes(enc))\n\n\n\n6.4hsctf dasctf\n6.5陕西省赛 逆向wp | shimmer’s blog (shimmer123456.github.io)\n6.6陕西省赛 逆向wp | shimmer’s blog (shimmer123456.github.io)\n6.7陕西省赛 逆向wp | shimmer’s blog (shimmer123456.github.io)\n","categories":["网安"],"tags":["逆向"]},{"title":"litctf  逆向wp","url":"/2023/05/13/litctf/","content":"世界上最棒的程序员ida打开程序就看到了\nez_XOR输入一个字符串，与3*3惊醒异或，之后与已知密文比较\nexp：\nchar aa[] = &quot;E`&#125;J]OrQF[V8zV:hzpV&#125;fVF[t&quot;;\tfor (int i = 0; i &lt; 26; i++)\t&#123;\t\tprintf(&quot;%c&quot;, aa[i] ^ 9);\t&#125;\n\nenbase64ida打开，直接动调输入的地方，判断长度之后有两个函数，第一个函数先把表换了之后进行base加密，第二个函数是与密文比较的，动调到换表处，dump出新的表：gJ1BRjQie&#x2F;FIWhEslq7GxbnL26M4+HXUtcpmVTKaydOP38of5v90ZSwrkYzCAuND，解密即可\nsnake是一个pyc文件，但是文件头被改了，根据文件名提示是python3.7版本的，所以手动修改一下文件头（42 0D 0D 0A）即可正常反编译\n&quot;&quot;&quot;贪吃蛇&quot;&quot;&quot;import random, sys, time, pygamefrom pygame.locals import *from collections import dequeSCREEN_WIDTH = 600SCREEN_HEIGHT = 480SIZE = 20LINE_WIDTH = 1SCOPE_X = ( 0, SCREEN_WIDTH // SIZE - 1)SCOPE_Y = (2, SCREEN_HEIGHT // SIZE - 1)FOOD_STYLE_LIST = [ (10, (255, 100, 100)), (20, (100, 255, 100)), (30, (100, 100, 255))]LIGHT = (100, 100, 100)DARK = (200, 200, 200)BLACK = (0, 0, 0)RED = (200, 30, 30)BGCOLOR = (40, 40, 60)def print_text(screen, font, x, y, text, fcolor=(255, 255, 255)):    imgText = font.render(text, True, fcolor)    screen.blit(imgText, (x, y))def init_snake():    snake = deque()    snake.append((2, SCOPE_Y[0]))    snake.append((1, SCOPE_Y[0]))    snake.append((0, SCOPE_Y[0]))    return snakedef create_food(snake):    food_x = random.randint(SCOPE_X[0], SCOPE_X[1])    food_y = random.randint(SCOPE_Y[0], SCOPE_Y[1])    while (food_x, food_y) in snake:        food_x = random.randint(SCOPE_X[0], SCOPE_X[1])        food_y = random.randint(SCOPE_Y[0], SCOPE_Y[1])    return (     food_x, food_y)def get_food_style():    return FOOD_STYLE_LIST[random.randint(0, 2)]def main():    pygame.init()    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))    pygame.display.set_caption(&#x27;贪吃蛇&#x27;)    font1 = pygame.font.SysFont(&#x27;SimHei&#x27;, 24)    font2 = pygame.font.Font(None, 72)    fwidth, fheight = font2.size(&#x27;GAME OVER&#x27;)    b = True    snake = init_snake()    food = create_food(snake)    food_style = get_food_style()    pos = (1, 0)    game_over = True    start = False    score = 0    orispeed = 0.5    speed = orispeed    last_move_time = None    pause = False    while 1:        for event in pygame.event.get():            if event.type == QUIT:                sys.exit()        screen.fill(BGCOLOR)        for x in range(SIZE, SCREEN_WIDTH, SIZE):            pygame.draw.line(screen, BLACK, (x, SCOPE_Y[0] * SIZE), (x, SCREEN_HEIGHT), LINE_WIDTH)        for y in range(SCOPE_Y[0] * SIZE, SCREEN_HEIGHT, SIZE):            pygame.draw.line(screen, BLACK, (0, y), (SCREEN_WIDTH, y), LINE_WIDTH)        curTime = game_over or time.time()        if curTime - last_move_time &gt; speed and not pause:            b = True            last_move_time = curTime            next_s = (snake[0][0] + pos[0], snake[0][1] + pos[1])            if next_s == food:                snake.appendleft(next_s)                score += food_style[0]                speed = orispeed - 0.03 * (score // 100)                food = create_food(snake)                food_style = get_food_style()            else:                if SCOPE_X[0] &lt;= next_s[0] &lt;= SCOPE_X[1]:                    if SCOPE_Y[0] &lt;= next_s[1] &lt;= SCOPE_Y[1]:                        if next_s not in snake:                            snake.appendleft(next_s)                            snake.pop()                        else:                            game_over = True                    if not game_over:                        pygame.draw.rect(screen, food_style[1], (food[0] * SIZE, food[1] * SIZE, SIZE, SIZE), 0)                    for s in snake:                        pygame.draw.rect(screen, DARK, (s[0] * SIZE + LINE_WIDTH, s[1] * SIZE + LINE_WIDTH,                         SIZE - LINE_WIDTH * 2, SIZE - LINE_WIDTH * 2), 0)                    print_text(screen, font1, 30, 7, f&quot;速度: &#123;score // 100&#125;&quot;)                    print_text(screen, font1, 450, 7, f&quot;得分: &#123;score&#125;&quot;)                    if score &gt; 1000:                        flag = [                         30, 196,                          52, 252, 49, 220, 7, 243,                          3, 241, 24, 224, 40, 230,                          25, 251, 28, 233, 40, 237,                          4, 225, 4, 215, 40, 231,                          22, 237, 14, 251, 10, 169]                        for i in range(0, len(flag), 2):                            flag[i], flag[i + 1] = flag[i + 1] ^ 136, flag[i] ^ 119                        print_text(screen, font2, (SCREEN_WIDTH - fwidth) // 2, (SCREEN_HEIGHT - fheight) // 2, bytes(flag).decode(), RED)                        pygame.display.update()                    if game_over:                        if start:                            print_text(screen, font2, (SCREEN_WIDTH - fwidth) // 2, (SCREEN_HEIGHT - fheight) // 2, &#x27;GAME OVER&#x27;, RED)                pygame.display.update()if __name__ == &#x27;__main__&#x27;:    main()\n\nscore&gt;1000后，会对flag进行一点操作，直接执行那一段代码即可，输出就是flag\n程序和人有一个能跑就行首先很明显是一个rc4加密，密文也给出。但解密出来的是假的flag，并且输出right？这个问号说明有一部分逻辑被应该是被隐藏起来了，看汇编流程图可以发现右边有一大块指令，隐藏了真正的密文，密钥没变，再解密一下即可\ndebase64主要逻辑就是那个base解密那个函数，仔细观察一下可以写出爆破脚本：\nstring table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;int main()&#123;    int key[4][3] = &#123; 0x46,0xed,0x18,0x96,0x56,0x9e,0xd2,0x72,0xb2,0xb3,0x80,0x70 &#125;;    for (int cnt = 0; cnt &lt; 4; cnt++)    &#123;        for (int i = 0; i &lt;= 62; i++)         &#123;            for (int j = 0; j &lt;= 62; j++)             &#123;                for (int k = 0; k &lt;= 62; k++)                 &#123;                    for (int l = 0; l &lt;= 62; l++)                     &#123;                        int temp1 = ((4 * i) | (j &gt;&gt; 4) &amp; 3) &amp; 0xff;                        int temp2 = ((16 * j) | (k &gt;&gt; 2)) &amp; 0xff;                        int temp3 = ((k &lt;&lt; 6) | l) &amp; 0xff;                        if (temp1 == key[cnt][0] &amp;&amp; temp2 == key[cnt][1] &amp;&amp; temp3 == key[cnt][2]) &#123;                            cout &lt;&lt; table[l] &lt;&lt; table[k] &lt;&lt; table[j] &lt;&lt; table[i];                            break;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n需要注意的是最后四个字符，hint给出的是后三个都是&#x3D;&#x3D;&#x3D;，那么只需要再猜一个字符就行，总体的md5值也给出，按道理应该再写个python脚本爆一下，但是我当时做的时候感觉来了，看这个flag样子估计最后一位是个数字，一下就猜对了\nFor Aiurpython打包的，解包，pyc反编译，可以主函数里引入了check的包，很明显与flag有关，引入的包都在PYZ-00.pyz_extracted这个文件夹下，在里面找到check的pyc文件，再反编译\n#!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 3.8enc = [    98,    77,    94,    91,    92,    107,    125,    66,    87,    70,    113,    92,    83,    70,    85,    81,    19,    21,    109,    99,    87,    107,    127,    65,    65,    64,    109,    87,    93,    90,    65,    64,    64,    65,    81,    3,    109,    85,    86,    80,    91,    64,    91,    91,    92,    0,    94,    107,    66,    77,    94,    91,    92,    71]lis = []def check(num):    flag = &#x27;LitCTF&#123;&#x27;    if num % 2 == 0 and num % 4 == 0 and num % 6 == 0 and num % 8 == 0 and num % 12 == 0 and num % 13 == 11:        k = str(num)        for i in range(len(enc)):            flag += chr(ord(k[i % len(k)]) ^ enc[i])            lis.append(ord(k[i % len(k)]) ^ enc[i])        flag += &#x27;&#125;&#x27;        imread = imread        imshow = imshow        namedWindow = namedWindow        WINDOW_NORMAL = WINDOW_NORMAL        FONT_HERSHEY_SIMPLEX = FONT_HERSHEY_SIMPLEX        getTickCount = getTickCount        getTickFrequency = getTickFrequency        putText = putText        LINE_AA = LINE_AA        waitKey = waitKey        getTextSize = getTextSize        resize = resize        moveWindow = moveWindow        IMREAD_UNCHANGED = IMREAD_UNCHANGED        destroyAllWindows = destroyAllWindows        import cv2        uint8 = uint8        zeros = zeros        import numpy        img = zeros((200, 20000, 3), uint8)        img.fill(255)        text = flag        font = FONT_HERSHEY_SIMPLEX        pos = (50, 120)        color = (0, 0, 0)        thickness = 2        putText(img, text, pos, font, 1, color, thickness, LINE_AA)        imshow(&#x27;flag&#x27;, img)        waitKey(0)        destroyAllWindows()\n\nnum值是24，直接运行那一段即可\n","categories":["网安"],"tags":["逆向"]},{"title":"kfc周会","url":"/2023/05/19/kfc%E5%91%A8%E4%BC%9A/","content":"这次周会主题就是ctf逆向的入门，精选了四道有趣的逆向题目，都是简单入门题\n[2023春秋杯  sum]考点：逆向分析的能力main函数：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v3; // rbp  int v4; // r14d  unsigned int v5; // r12d  __int64 i; // rbx  char v7; // al  int v8; // eax  const char *v9; // rax  v3 = (char *)&amp;matrix;  v4 = 1;  v5 = 0;  puts(&quot;Welcome to Solver!&quot;);  do  &#123;    for ( i = 0LL; i != 9; ++i )    &#123;      if ( !v3[i] )      &#123;        v7 = getchar();        if ( (unsigned __int8)(v7 - 49) &gt; 8u )          v4 = 0;        else          v3[i] = v7 - 48;      &#125;      v8 = v3[i];      v5 += v8;    &#125;    v3 += 9;  &#125;  while ( v3 != (char *)&amp;matrix + 81 );  if ( v4 &amp;&amp; (unsigned int)verify(&quot;Welcome to Solver!&quot;, argv) )  &#123;    puts(&quot;You Win!&quot;);    __snprintf_chk(buf, 32LL, 1LL, 32LL, &quot;%d&quot;, v5);    v9 = (const char *)str2md5(buf, strlen(buf));    __printf_chk(1LL, &quot;flag is: flag&#123;%s&#125;\\n\\n&quot;, v9);    exit(0);  &#125;  puts(&quot;Again~&quot;);  return 0;&#125;\n\n首先是一个do while嵌套for的一个81次的循环，循环时当v3[i]的值等于0，会让用户输入一个字符，并且该输入必须在0-9之间\n那么接下来进入verify函数：\n不仔细看的话中等复杂，但他肯定是一段验证程序，因为它在if条件里嘛，满足条件就是win了。分析的话要么动调，要么为了省事直接问gpt（这个题效果还不错，有时候小心他会胡说八道）：\n\nsolve：\n知道是数独，提取出81个数据，找个在线网站解一下数独，再运行程序填进去flag就输出了\n[GDOUCTF 2023]doublegame考点：动态调试，交叉引用直接运行程序是一个贪吃蛇游戏，撞壁游戏就结束了。\n拖入ida，因为没有main函数，所以通过字符串来定位关键逻辑：\n\n看到挺多0，跟进去，来到了这么一个函数：\nvoid __noreturn sub_140012CF0()&#123;  char *v0; // rdi  __int64 i; // rcx  char v2; // [rsp+20h] [rbp+0h] BYREF  char Buffer[22]; // [rsp+30h] [rbp+10h] BYREF  char v4[44]; // [rsp+46h] [rbp+26h] BYREF  char v5[44]; // [rsp+72h] [rbp+52h] BYREF  char v6[44]; // [rsp+9Eh] [rbp+7Eh] BYREF  char v7[44]; // [rsp+CAh] [rbp+AAh] BYREF  char v8[44]; // [rsp+F6h] [rbp+D6h] BYREF  char v9[44]; // [rsp+122h] [rbp+102h] BYREF  char v10[44]; // [rsp+14Eh] [rbp+12Eh] BYREF  char v11[44]; // [rsp+17Ah] [rbp+15Ah] BYREF  char v12[44]; // [rsp+1A6h] [rbp+186h] BYREF  char v13[66]; // [rsp+1D2h] [rbp+1B2h] BYREF  int j; // [rsp+214h] [rbp+1F4h]  int v15; // [rsp+234h] [rbp+214h]  int v16; // [rsp+254h] [rbp+234h]  int v17; // [rsp+274h] [rbp+254h]  int v18; // [rsp+294h] [rbp+274h]  _DWORD v19[25]; // [rsp+2C0h] [rbp+2A0h] BYREF  char v20[100]; // [rsp+324h] [rbp+304h] BYREF  char v21[828]; // [rsp+388h] [rbp+368h] BYREF  char v22; // [rsp+6C4h] [rbp+6A4h]  int v23; // [rsp+6E4h] [rbp+6C4h]  int v24; // [rsp+704h] [rbp+6E4h]  v0 = &amp;v2;  for ( i = 448i64; i; --i )  &#123;    *(_DWORD *)v0 = -858993460;    v0 += 4;  &#125;  sub_14001141A(&amp;unk_1400290A6);  strcpy(Buffer, &quot;000000000000000000000&quot;);  strcpy(v4, &quot;0 0 0 0     0     0 0&quot;);  strcpy(&amp;v4[22], &quot;0 0 0 00000 00000 0 0&quot;);  strcpy(v5, &quot;0 0               0 0&quot;);  strcpy(&amp;v5[22], &quot;0 000 000 0 000 0 0 0&quot;);  strcpy(v6, &quot;0 0     0 0 0   0 0 0&quot;);  strcpy(&amp;v6[22], &quot;0 0 0 00000 000 000 0&quot;);  strcpy(v7, &quot;0 0 0     0   0 0    &quot;);  strcpy(&amp;v7[22], &quot;0 000 0 0 000 0 0 0 0&quot;);  strcpy(v8, &quot;0     0 0 0 0 0 0 0 0&quot;);  strcpy(&amp;v8[22], &quot;0 00000 000 000 0 0 0&quot;);  strcpy(v9, &quot;0     0       0   0 0&quot;);  strcpy(&amp;v9[22], &quot;000 0 0 0 000 0 0 0 0&quot;);  strcpy(v10, &quot;0 0 0 0 0 0 * 0 0 0 0&quot;);  strcpy(&amp;v10[22], &quot;0 0000000 0 000 00000&quot;);  strcpy(v11, &quot;@       0 0         0&quot;);  strcpy(&amp;v11[22], &quot;0 0 0 0 0 00000000000&quot;);  strcpy(v12, &quot;0 0 0 0             0&quot;);  strcpy(&amp;v12[22], &quot;000 0 00000 0 000 000&quot;);  strcpy(v13, &quot;0         0 0   0   0&quot;);  strcpy(&amp;v13[22], &quot;000000000000000000000&quot;);  v11[4] = 48;  strcpy((char *)v19, &quot;Please to save the cat!&quot;);  memset(&amp;v19[6], 0, 0x4Cui64);  strcpy(v20, &quot;the score is saving cat&#x27;s key!\\n&quot;);  memset(&amp;v20[32], 0, 0x44ui64);  qmemcpy(v21, &amp;unk_14001D340, 0x47ui64);  memset(&amp;v21[71], 0, 729);  sub_1400111F9(&quot;path\\n&quot;);  v23 = 0;  v24 = 0;  v15 = 15;  v16 = 0;  v17 = 7;  v18 = 20;  for ( j = 0; j &lt;= 20; ++j )    puts(&amp;Buffer[22 * j]);  sub_1400111F9(&quot;Please to save the cat!\\n&quot;);  while ( v15 != v17 || v16 != v18 )  &#123;    v22 = getchar();    switch ( v22 )    &#123;      case &#x27;s&#x27;:        if ( Buffer[22 * v15 + 22 + v16] != 48 )        &#123;          Buffer[22 * v15++ + v16] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      case &#x27;w&#x27;:        if ( Buffer[22 * v15 - 22 + v16] != 48 )        &#123;          Buffer[22 * v15-- + v16] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      case &#x27;a&#x27;:        if ( Buffer[22 * v15 - 1 + v16] != 48 )        &#123;          if ( Buffer[22 * v15 - 1 + v16] == 42 )            v7[20] = 48;          Buffer[22 * v15 + v16--] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;      default:        if ( v22 == 100 &amp;&amp; Buffer[22 * v15 + 1 + v16] != 48 )        &#123;          Buffer[22 * v15 + v16++] = 32;          Buffer[22 * v15 + v16] = 64;        &#125;        break;    &#125;    system(&quot;cls&quot;);    for ( j = 0; j &lt;= 20; ++j )      puts(&amp;Buffer[22 * j]);    puts((const char *)&amp;v19[25 * v23]);    if ( v7[20] == 48 )    &#123;      v24 = sub_140011433(0i64);      if ( v24 == 13376013 )      &#123;        v23 = 1;        v7[20] = 32;        Buffer[22 * v15 + v16] = 32;        v15 = 15;        v16 = 0;        v11[0] = 64;        ++v23;      &#125;      else      &#123;        sub_1400111F9(&quot;error&quot;);      &#125;    &#125;  &#125;  system(&quot;cls&quot;);  Sleep(0x1F4u);  Sleep(0xBB8u);  sub_140011492();  exit(0);&#125;\n\n很明显是一个迷宫，但刚才的贪吃蛇哪去了（因为是double game啦），那么就再交叉引用看看谁调用了这个迷宫的函数，一直可以追到贪吃蛇游戏里：\n\n这个dword_140022CD0就是当前得分了，当它＞13371337时就会跳转到迷宫游戏\n逻辑清楚了，那么在判断分数前下个断点，贪吃蛇游戏结束之后断下来，修改两次标志位（sf）跳转到迷宫游戏\n接下来通过wsad控制上下左右走迷宫，先把小猫救出来后，程序会让输入key（其实就是贪吃蛇分数13371337），也可以通过判断key的逻辑再把key逆出来：\nif ( v7[20] == &#x27;0&#x27; )   &#123;     v25 = sub_7FF777D31433(0i64);     if ( v25 == 13376013 )\n\n__int64 __fastcall sub_7FF777D31E10(unsigned int a1)&#123;  unsigned int v2; // [rsp+120h] [rbp+100h] BYREF  v2 = a1;  sub_7FF777D3141A(&amp;unk_7FF777D490A6);  sub_7FF777D311F9(&quot;do you know the key to open the door\\n&quot;);  sub_7FF777D3126C(&quot;%d&quot;, &amp;v2);  v2 ^= 0x1DC4u;  return v2;&#125;\n\n所以为了使v25&#x3D;13376013，需要v2^0x1dc4&#x3D;13376013,那么key就是13376013^13376013&#x3D;13371337\n输入key之后，又回到原点了，再走一下迷宫，flag就是{key+md5(最短路径)}\n[HDCTF 2023]fake_game考点：pyc反编译，z3解方程做了两道exe的题目了，再来一道python的题目\n题目附件虽然是exe，但这个使python打包的exe文件，需要用到pyinstxtractor-master进行解包，输入命令：python pyinstxtractor.py fake_game.exe即可\n在文件夹下找到game.pyc文件，找在线网站即可反编译成py文件，推荐：在线Python pyc文件编译与反编译 (lddgo.net)\n反编译代码如下：\n# uncompyle6 version 3.9.0# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.6.12 (default, Feb  9 2021, 09:19:15) # [GCC 8.3.0]# Embedded file name: game.pyimport pygame, randomfrom win32api import MessageBoxIMAGE_PATH = &#x27;imgs/&#x27;scrrr_width = 800scrrr_height = 560GAMEOVER = FalseLOG = &#x27;文件:&#123;&#125;中的方法:&#123;&#125;出错&#x27;.format(__file__, __name__)class Map:    map_names_list = [     IMAGE_PATH + &#x27;map1.png&#x27;, IMAGE_PATH + &#x27;map2.png&#x27;]    def __init__(self, x, y, img_index):        self.image = pygame.image.load(Map.map_names_list[img_index])        self.position = (x, y)        self.can_grow = True    def load_map(self):        MainGame.window.blit(self.image, self.position)class Plant(pygame.sprite.Sprite):    def __init__(self):        super(Plant, self).__init__()        self.live = True    def load_image(self):        if hasattr(self, &#x27;image&#x27;) and hasattr(self, &#x27;rect&#x27;):            MainGame.window.blit(self.image, self.rect)        else:            print(LOG)class Sunflower(Plant):    def __init__(self, x, y):        super(Sunflower, self).__init__()        self.image = pygame.image.load(&#x27;imgs/sunflower.png&#x27;)        self.rect = self.image.get_rect()        self.rect.x = x        self.rect.y = y        self.price = 50        self.hp = 100        self.time_count = 0    def produce_money(self):        self.time_count += 1        if self.time_count == 25:            MainGame.money += 5            self.time_count = 0    def display_sunflower(self):        MainGame.window.blit(self.image, self.rect)class PeaShooter(Plant):    def __init__(self, x, y):        super(PeaShooter, self).__init__()        self.image = pygame.image.load(&#x27;imgs/peashooter.png&#x27;)        self.rect = self.image.get_rect()        self.rect.x = x        self.rect.y = y        self.price = 50        self.hp = 200        self.shot_count = 0    def shot(self):        should_fire = False        for zombie in MainGame.zombie_list:            if zombie.rect.y == self.rect.y and zombie.rect.x &lt; 800 and zombie.rect.x &gt; self.rect.x:                should_fire = True        else:            if self.live:                if should_fire:                    self.shot_count += 1                    if self.shot_count == 25:                        peabullet = PeaBullet(self)                        MainGame.peabullet_list.append(peabullet)                        self.shot_count = 0    def display_peashooter(self):        MainGame.window.blit(self.image, self.rect)class PeaBullet(pygame.sprite.Sprite):    def __init__(self, peashooter):        self.live = True        self.image = pygame.image.load(&#x27;imgs/peabullet.png&#x27;)        self.damage = 50        self.speed = 10        self.rect = self.image.get_rect()        self.rect.x = peashooter.rect.x + 60        self.rect.y = peashooter.rect.y + 15    def move_bullet(self):        if self.rect.x &lt; scrrr_width:            self.rect.x += self.speed        else:            self.live = False    def hit_zombie(self):        for zombie in MainGame.zombie_list:            if pygame.sprite.collide_rect(self, zombie):                self.live = False                zombie.hp -= self.damage                if zombie.hp &lt;= 0:                    zombie.live = False                    self.nextLevel()    def nextLevel(self):        MainGame.score += 20        MainGame.remnant_score -= 20        for i in range(1, 100):            if MainGame.score == 100 * i and MainGame.remnant_score == 0:                MainGame.remnant_score = 100 * i                MainGame.shaoguan += 1                MainGame.produce_zombie += 50    def display_peabullet(self):        MainGame.window.blit(self.image, self.rect)class Zombie(pygame.sprite.Sprite):    def __init__(self, x, y):        super(Zombie, self).__init__()        self.image = pygame.image.load(&#x27;imgs/zombie.png&#x27;)        self.rect = self.image.get_rect()        self.rect.x = x        self.rect.y = y        self.hp = 1000        self.damage = 2        self.speed = 1        self.live = True        self.stop = False    def move_zombie(self):        if self.live:            if not self.stop:                self.rect.x -= self.speed                if self.rect.x &lt; -80:                    MainGame().gameOver()    def hit_plant(self):        for plant in MainGame.plants_list:            if pygame.sprite.collide_rect(self, plant):                self.stop = True                self.eat_plant(plant)    def eat_plant(self, plant):        plant.hp -= self.damage        if plant.hp &lt;= 0:            a = plant.rect.y // 80 - 1            b = plant.rect.x // 80            map = MainGame.map_list[a][b]            map.can_grow = True            plant.live = False            self.stop = False    def display_zombie(self):        MainGame.window.blit(self.image, self.rect)class MainGame:    shaoguan = 1    score = 0    remnant_score = 100    money = 200    map_points_list = []    map_list = []    plants_list = []    peabullet_list = []    zombie_list = []    count_zombie = 0    produce_zombie = 100    def init_window(self):        pygame.display.init()        MainGame.window = pygame.display.set_mode([scrrr_width, scrrr_height])    def draw_text(self, content, size, color):        pygame.font.init()        font = pygame.font.SysFont(&#x27;kaiti&#x27;, size)        text = font.render(content, True, color)        return text    def load_help_text(self):        text1 = self.draw_text(&#x27;1.按左键创建向日葵 2.按右键创建豌豆射手&#x27;, 26, (255, 0, 0))        MainGame.window.blit(text1, (5, 5))    def init_plant_points(self):        for y in range(1, 7):            points = []            for x in range(10):                point = (                 x, y)                points.append(point)            else:                MainGame.map_points_list.append(points)                print(&#x27;MainGame.map_points_list&#x27;, MainGame.map_points_list)    def init_map(self):        for points in MainGame.map_points_list:            temp_map_list = list()            for point in points:                if (point[0] + point[1]) % 2 == 0:                    map = Map(point[0] * 80, point[1] * 80, 0)                else:                    map = Map(point[0] * 80, point[1] * 80, 1)                temp_map_list.append(map)                print(&#x27;temp_map_list&#x27;, temp_map_list)            else:                MainGame.map_list.append(temp_map_list)        else:            print(&#x27;MainGame.map_list&#x27;, MainGame.map_list)    def load_map(self):        for temp_map_list in MainGame.map_list:            for map in temp_map_list:                map.load_map()    def load_plants(self):        for plant in MainGame.plants_list:            if plant.live:                if isinstance(plant, Sunflower):                    plant.display_sunflower()                    plant.produce_money()                elif isinstance(plant, PeaShooter):                    plant.display_peashooter()                    plant.shot()            else:                MainGame.plants_list.remove(plant)    def load_peabullets(self):        for b in MainGame.peabullet_list:            if b.live:                b.display_peabullet()                b.move_bullet()                b.hit_zombie()            else:                MainGame.peabullet_list.remove(b)    def deal_events(self):        eventList = pygame.event.get()        for e in eventList:            if e.type == pygame.QUIT:                self.gameOver()            elif e.type == pygame.MOUSEBUTTONDOWN:                print(e.pos)                x = e.pos[0] // 80                y = e.pos[1] // 80                print(x, y)                map = MainGame.map_list[y - 1][x]                print(map.position)                if e.button == 1:                    if map.can_grow:                        if MainGame.money &gt;= 50:                            sunflower = Sunflower(map.position[0], map.position[1])                            MainGame.plants_list.append(sunflower)                            print(&#x27;当前植物列表长度:&#123;&#125;&#x27;.format(len(MainGame.plants_list)))                            map.can_grow = False                            MainGame.money -= 50            elif e.button == 3 and map.can_grow and MainGame.money &gt;= 50:                peashooter = PeaShooter(map.position[0], map.position[1])                MainGame.plants_list.append(peashooter)                print(&#x27;当前植物列表长度:&#123;&#125;&#x27;.format(len(MainGame.plants_list)))                map.can_grow = False                MainGame.money -= 50    def init_zombies(self):        for i in range(1, 7):            dis = random.randint(1, 5) * 200            zombie = Zombie(800 + dis, i * 80)            MainGame.zombie_list.append(zombie)    def load_zombies(self):        for zombie in MainGame.zombie_list:            if zombie.live:                zombie.display_zombie()                zombie.move_zombie()                zombie.hit_plant()            else:                MainGame.zombie_list.remove(zombie)    def start_game(self):        global GAMEOVER        xorr = [         0] * 4        ans = [0] * 55        flag = [178868, 188, 56953, 2413, 178874, 131, 56957, 2313, 178867, 156,          56933, 2377, 178832, 202, 56899, 2314, 178830, 167, 56924,          2313, 178830, 167, 56938, 2383, 178822, 217, 56859, 2372]        self.init_window()        self.init_plant_points()        self.init_map()        self.init_zombies()        while not GAMEOVER:            MainGame.window.fill((255, 255, 255))            MainGame.window.blit(self.draw_text(&#x27;当前钱数$: &#123;&#125;&#x27;.format(MainGame.money), 26, (255,                                                                                         0,                                                                                         0)), (500,                                                                                               40))            MainGame.window.blit(self.draw_text(&#x27;当前关数&#123;&#125;，得分&#123;&#125;,距离下关还差&#123;&#125;分&#x27;.format(MainGame.shaoguan, MainGame.score, MainGame.remnant_score), 26, (255,                                                                                                                                                0,                                                                                                                                                0)), (5,                                                                                                                                                      40))            self.load_help_text()            xorr[0] = MainGame.money            xorr[1] = MainGame.shaoguan            xorr[2] = MainGame.score            xorr[3] = MainGame.remnant_score            if xorr[0] * 256 - xorr[1] / 2 + xorr[2] * 23 + xorr[3] / 2 == 47118166:                if xorr[0] * 252 - xorr[1] * 366 + xorr[2] * 23 + xorr[3] / 2 - 1987 == 46309775:                    if xorr[0] * 6 - xorr[1] * 88 + xorr[2] / 2 + xorr[3] / 2 - 11444 == 1069997:                        if (xorr[0] - 652) * 2 - xorr[1] * 366 + xorr[2] * 233 + xorr[3] / 2 - 13333 == 13509025:                            for i in range(len(flag)):                                ans[i] = flag[i] ^ xorr[i % 4]                            else:                                with open(&#x27;flag.txt&#x27;, &#x27;w&#x27;) as (f):                                    f.write(&#x27;&#x27;.join([chr(a) for a in ans]))            self.load_map()            self.load_plants()            self.load_peabullets()            self.deal_events()            self.load_zombies()            MainGame.count_zombie += 1            if MainGame.count_zombie == MainGame.produce_zombie:                self.init_zombies()                MainGame.count_zombie = 0            pygame.time.wait(10)            pygame.display.update()    def gameOver(self):        global GAMEOVER        MainGame.window.blit(self.draw_text(&#x27;游戏结束&#x27;, 50, (255, 0, 0)), (300, 200))        print(&#x27;游戏结束&#x27;)        pygame.time.wait(400)        GAMEOVER = Trueif __name__ == &#x27;__main__&#x27;:    game = MainGame()    game.start_game()\n\nflag初始值已给出，只需要再求出xor数组内的4个值即可，这四个值的求解就需要用到z3这个解方程工具了（如何使用就不说了，有兴趣可以百度搜一搜用法）:\nfrom z3 import*xorr = [BitVec(&quot;num[%d]&quot; % i, 32) for i in range(4)]s = Solver()s.add(xorr[0] * 256 - xorr[1] / 2 + xorr[2] * 23 + xorr[3] / 2 == 47118166)s.add(xorr[0] * 252 - xorr[1] * 366 + xorr[2] * 23 + xorr[3] / 2 - 1987 == 46309775)s.add(xorr[0] * 6 - xorr[1] * 88 + xorr[2] / 2 + xorr[3] / 2 - 11444 == 1069997)s.add((xorr[0] - 652) * 2 - xorr[1] * 366 + xorr[2] * 233 + xorr[3] / 2 - 13333 == 13509025)if s.check() == sat:    s = s.model()print(s)#xorr[1] = 248#xorr[0] = 178940#xorr[2] = 56890#xorr[3] = 2361\n\n[SCTF2019]Who is he考点：c#的逆向运行程序，emmm，（这段视频不错）\n主要逻辑是在dll文件里的，\\Who is he\\Who is he_Data\\Managed\\Assembly-CSharp.\n至于怎么定位到这个dll的，就是看文件名称，有很多Unity的，System的一看就不是，剩下没几个了，试一试就知道了\n使用dnspy打开这个dll，定位到Testclick，下面有OnClick函数：\npublic void OnClick()&#123;\tDebug.Log(&quot;Button Clicked. TestClick.&quot;);\tDebug.Log(this.Name.text);\tbool flag = this.Name.text.Equals(this.Decrypt(this.EncryptData));\tif (flag)\t&#123;\t\tDebug.Log(&quot;Right&quot;);\t\tTestClick.Messagebox.MessageBox(IntPtr.Zero, &quot;Haha, same as you!&quot;, &quot;Info:&quot;, 0);\t&#125;\telse\t&#123;\t\tDebug.Log(&quot;Wrong&quot;);\t\tTestClick.Messagebox.MessageBox(IntPtr.Zero, &quot;Emmmmm,I don&#x27;t think so.&quot;, &quot;Info:&quot;, 0);\t&#125;&#125;\n\n逆向再看decrypt函数：\nprivate string Decrypt(string str)\t&#123;\t\tstring result;\t\ttry\t\t&#123;\t\t\tbyte[] bytes = Encoding.Unicode.GetBytes(TestClick.encryptKey);\t\t\tbyte[] array = Convert.FromBase64String(str);\t\t\tDESCryptoServiceProvider descryptoServiceProvider = new DESCryptoServiceProvider();\t\t\tMemoryStream memoryStream = new MemoryStream();\t\t\tCryptoStream cryptoStream = new CryptoStream(memoryStream, descryptoServiceProvider.CreateDecryptor(bytes, bytes), CryptoStreamMode.Write);\t\t\tcryptoStream.Write(array, 0, array.Length);\t\t\tcryptoStream.FlushFinalBlock();\t\t\tbyte[] bytes2 = memoryStream.ToArray();\t\t\tcryptoStream.Close();\t\t\tmemoryStream.Close();\t\t\tresult = Encoding.Unicode.GetString(bytes2);\t\t&#125;\t\tcatch\t\t&#123;\t\t\tresult = str;\t\t&#125;\t\treturn result;\t&#125;\n\n就是一个DES加base64的加密，具体怎么解的就不说了，因为今天只是逆向的一个简单介绍和入门。（估计这时候时间也不够了，计划30min）\n","categories":["网安"],"tags":["逆向"]},{"title":"春秋杯 逆向 wp","url":"/2023/05/30/%E6%98%A5%E7%A7%8B%E6%9D%AF/","content":"summain函数：\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  char *v3; // rbp  int v4; // r14d  unsigned int v5; // r12d  __int64 i; // rbx  char v7; // al  int v8; // eax  const char *v9; // rax  v3 = (char *)&amp;matrix;  v4 = 1;  v5 = 0;  puts(&quot;Welcome to Solver!&quot;);  do  &#123;    for ( i = 0LL; i != 9; ++i )    &#123;      if ( !v3[i] )      &#123;        v7 = getchar();        if ( (unsigned __int8)(v7 - 49) &gt; 8u )          v4 = 0;        else          v3[i] = v7 - 48;      &#125;      v8 = v3[i];      v5 += v8;    &#125;    v3 += 9;  &#125;  while ( v3 != (char *)&amp;matrix + 81 );  if ( v4 &amp;&amp; (unsigned int)verify(&quot;Welcome to Solver!&quot;, argv) )  &#123;    puts(&quot;You Win!&quot;);    __snprintf_chk(buf, 32LL, 1LL, 32LL, &quot;%d&quot;, v5);    v9 = (const char *)str2md5(buf, strlen(buf));    __printf_chk(1LL, &quot;flag is: flag&#123;%s&#125;\\n\\n&quot;, v9);    exit(0);  &#125;  puts(&quot;Again~&quot;);  return 0;&#125;\n\n首先是一个do while嵌套for的一个81次的循环，循环时当v3[i]的值等于0，会让用户输入一个字符，并且该输入必须在0-9之间\n那么接下来进入verify函数：\n不仔细看的话中等复杂，但他肯定是一段验证程序，因为它在if条件里嘛，满足条件就是win了。分析的话要么动调，要么为了省事直接问gpt（这个题效果还不错，有时候小心他会胡说八道）：\nsolve：\n知道是数独，提取出81个数据，找个在线网站解一下数独，再运行程序填进去flag就输出了\nPoisoned_tea_CHELL要么脱了壳看，动调也行，就是个xtea，当时的脚本丢了，懒得找了\nBWBA加密算法是DCT离散余弦变换，\n但是比赛时候认为这个算法是不可逆的，所以用了z3来解这个值\n方程生成：\n#include&lt;bits/stdc++.h&gt;#include &lt;cmath&gt;using namespace std;double a1[64] = &#123;0&#125;;int main()&#123;  double flag[64] = &#123;370.75,234.362,-58.0834,59.8212,88.8221,-30.2406,21.8316,49.9781,-33.5259,2.69675,43.5386,-30.2925,-28.0754,27.593,-2.53962,-27.1883,-5.60777,-0.263937,6.80326,8.03022,-6.34681,-0.89506,-6.80685,-13.6088,27.0958,29.8439,-21.7688,-20.6925,-13.2155,-37.0994,2.23679,37.6699,-3.5,9.85188,57.2806,13.5715,-20.7184,8.6816,3.59369,-4.5302,4.22203,-28.8166,-23.695,31.2268,6.58823,-39.9966,-20.7877,-19.7624,-22.031,16.3285,2.07557,-26.2521,16.1914,18.3976,-26.9295,3.03769,41.0412,20.2598,14.991,6.99392,-22.3752,-7.24466,8.96299,-10.4874&#125;, v10 = 0, v9 = 0;  int i, j, cnt = 64;  for ( i = 0; i &lt; cnt; ++i )  &#123;    cout &lt;&lt;endl &lt;&lt;&quot;s.add((&quot;;    double tempi = i;    for ( j = 0; j &lt; cnt; ++j )    &#123;      double tempj = j;      v9 = cos((tempj + 0.5) * (3.141592653589793 * tempi) / cnt);      if (j == 63)&#123;        cout &lt;&lt;&quot;(&quot;;        printf(&quot;%lf&quot;,v9);        cout&lt;&lt;&quot; * flag&quot; &lt;&lt;j&lt;&lt;&quot;)&quot;;      &#125;      else&#123;        cout &lt;&lt;&quot;(&quot;;        printf(&quot;%lf&quot;,v9);        cout&lt;&lt;&quot; * flag&quot; &lt;&lt;j&lt;&lt;&quot;)&quot; &lt;&lt;&quot;+&quot;;      &#125;    &#125;    if ( i )      v10 = sqrt(2.0 / cnt);    else      v10 = sqrt(1.0 / cnt);    flag[i] /= v10;    cout &lt;&lt;&quot;)&quot;;    cout &lt;&lt;&quot; ==&quot;;    printf(&quot;%lf&quot;,flag[i]);    //         cout&lt;&lt;&quot;)&quot;;  &#125;&#125;\n\nz3：\nfrom z3 import *flag0 = Real(&#x27;flag0&#x27;)flag1 = Real(&#x27;flag1&#x27;)flag2 = Real(&#x27;flag2&#x27;)flag3 = Real(&#x27;flag3&#x27;)# ...flag63 = Real(&#x27;flag63&#x27;)s = Solver()s.add(((1.000000 * flag0)+(1.000000 * flag1)+(1.000000 * flag2)+(1.000000 * flag3)+(1.000000 * flag4)+(1.000000 * flag5)+(1.000000 * flag6)+(1.000000 * flag7)+(1.000000 * flag8)+(1.000000 * flag9)+(1.000000 * flag10)+(1.000000 * flag11)+(1.000000 * flag12)+(1.000000 * flag13)+(1.000000 * flag14)+(1.000000 * flag15)+(1.000000 * flag16)+(1.000000 * flag17)+(1.000000 * flag18)+(1.000000 * flag19)+(1.000000 * flag20)+(1.000000 * flag21)+(1.000000 * flag22)+(1.000000 * flag23)+(1.000000 * flag24)+(1.000000 * flag25)+(1.000000 * flag26)+(1.000000 * flag27)+(1.000000 * flag28)+(1.000000 * flag29)+(1.000000 * flag30)+(1.000000 * flag31)+(1.000000 * flag32)+(1.000000 * flag33)+(1.000000 * flag34)+(1.000000 * flag35)+(1.000000 * flag36)+(1.000000 * flag37)+(1.000000 * flag38)+(1.000000 * flag39)+(1.000000 * flag40)+(1.000000 * flag41)+(1.000000 * flag42)+(1.000000 * flag43)+(1.000000 * flag44)+(1.000000 * flag45)+(1.000000 * flag46)+(1.000000 * flag47)+(1.000000 * flag48)+(1.000000 * flag49)+(1.000000 * flag50)+(1.000000 * flag51)+(1.000000 * flag52)+(1.000000 * flag53)+(1.000000 * flag54)+(1.000000 * flag55)+(1.000000 * flag56)+(1.000000 * flag57)+(1.000000 * flag58)+(1.000000 * flag59)+(1.000000 * flag60)+(1.000000 * flag61)+(1.000000 * flag62)+(1.000000 * flag63)) ==2966.000000)s.add(((0.999699 * flag0)+(0.997290 * flag1)+(0.992480 * flag2)+(0.985278 * flag3)+(0.975702 * flag4)+(0.963776 * flag5)+(0.949528 * flag6)+(0.932993 * flag7)+(0.914210 * flag8)+(0.893224 * flag9)+(0.870087 * flag10)+(0.844854 * flag11)+(0.817585 * flag12)+(0.788346 * flag13)+(0.757209 * flag14)+(0.724247 * flag15)+(0.689541 * flag16)+(0.653173 * flag17)+(0.615232 * flag18)+(0.575808 * flag19)+(0.534998 * flag20)+(0.492898 * flag21)+(0.449611 * flag22)+(0.405241 * flag23)+(0.359895 * flag24)+(0.313682 * flag25)+(0.266713 * flag26)+(0.219101 * flag27)+(0.170962 * flag28)+(0.122411 * flag29)+(0.073565 * flag30)+(0.024541 * flag31)+(-0.024541 * flag32)+(-0.073565 * flag33)+(-0.122411 * flag34)+(-0.170962 * flag35)+(-0.219101 * flag36)+(-0.266713 * flag37)+(-0.313682 * flag38)+(-0.359895 * flag39)+(-0.405241 * flag40)+(-0.449611 * flag41)+(-0.492898 * flag42)+(-0.534998 * flag43)+(-0.575808 * flag44)+(-0.615232 * flag45)+(-0.653173 * flag46)+(-0.689541 * flag47)+(-0.724247 * flag48)+(-0.757209 * flag49)+(-0.788346 * flag50)+(-0.817585 * flag51)+(-0.844854 * flag52)+(-0.870087 * flag53)+(-0.893224 * flag54)+(-0.914210 * flag55)+(-0.932993 * flag56)+(-0.949528 * flag57)+(-0.963776 * flag58)+(-0.975702 * flag59)+(-0.985278 * flag60)+(-0.992480 * flag61)+(-0.997290 * flag62)+(-0.999699 * flag63)) ==1325.751676)# ...s.add(((0.024541 * flag0)+(-0.073565 * flag1)+(0.122411 * flag2)+(-0.170962 * flag3)+(0.219101 * flag4)+(-0.266713 * flag5)+(0.313682 * flag6)+(-0.359895 * flag7)+(0.405241 * flag8)+(-0.449611 * flag9)+(0.492898 * flag10)+(-0.534998 * flag11)+(0.575808 * flag12)+(-0.615232 * flag13)+(0.653173 * flag14)+(-0.689541 * flag15)+(0.724247 * flag16)+(-0.757209 * flag17)+(0.788346 * flag18)+(-0.817585 * flag19)+(0.844854 * flag20)+(-0.870087 * flag21)+(0.893224 * flag22)+(-0.914210 * flag23)+(0.932993 * flag24)+(-0.949528 * flag25)+(0.963776 * flag26)+(-0.975702 * flag27)+(0.985278 * flag28)+(-0.992480 * flag29)+(0.997290 * flag30)+(-0.999699 * flag31)+(0.999699 * flag32)+(-0.997290 * flag33)+(0.992480 * flag34)+(-0.985278 * flag35)+(0.975702 * flag36)+(-0.963776 * flag37)+(0.949528 * flag38)+(-0.932993 * flag39)+(0.914210 * flag40)+(-0.893224 * flag41)+(0.870087 * flag42)+(-0.844854 * flag43)+(0.817585 * flag44)+(-0.788346 * flag45)+(0.757209 * flag46)+(-0.724247 * flag47)+(0.689541 * flag48)+(-0.653173 * flag49)+(0.615232 * flag50)+(-0.575808 * flag51)+(0.534998 * flag52)+(-0.492898 * flag53)+(0.449611 * flag54)+(-0.405241 * flag55)+(0.359895 * flag56)+(-0.313682 * flag57)+(0.266713 * flag58)+(-0.219101 * flag59)+(0.170962 * flag60)+(-0.122411 * flag61)+(0.073565 * flag62)+(-0.024541 * flag63)) ==-59.325693)print(s.check())print(s.model())\n\n注意z3的小数都是用分数表示的，精度不重要，大概就行了，取整输出就是flag\nflag = [0 for i in range(64)]flag[    55] = 221527137955783113048387578098669691852696472163174363992368587140468072862920727666475906867404888638838351318494490704211264388450373808157143523413409650950475194124966447357784178278474314607876795718871850895314347485314725170589326708258271512005230085206855375465185961941426128822017371048964561623152284829085198599876666124694211060913327259311235999626439130457424039519987122749459176262 / 4393949489366013141326163371687704628053876930668323418191072958216729857094949839067603311586792854232854294729192049148923892216475097051452982099673208220975632436415151212496411611956992817991807078659939201284753446394195432061555651948215760845094198788857248533383339796074398574229674880933341286069968842091882649229346271093965887550163210225244116603976086342392436567094267576310818570886085flag[    32] = 1687279396917760686256775837450156537810376211966209118713889456264098294438023380830097733539434047032147127492810004743931813776323691257487629314860358703386692057998366248033741285251060976444886928995003306048059584076838156029948315773458988690200028145397390874043032135199067245841270264782772413546558083597284157959212565958078116842012101046869288077937458487761020750491219956365179541224993959 / 35151595914928105130609306973501637024431015445346587345528583665733838856759598712540826492694342833862834357833536393191391137731800776411623856797385665767805059491321209699971292895655942543934456629279513610278027571153563456492445215585726086760753590310857988267066718368595188593837399047466730288559750736735061193834770168751727100401305681801952932831808690739139492536754140610486548567088680# ...flag[    26] = 7170921423120406134452068759100082419053673782981918591779303332725381751713223477702469650712602475303035621426578259606409522642372892852081452455753207582821725938452118491738552068892503760852475907805364856515936237811647835538337671975355462756861657530521173108999585739612050593385888410823160809684081128580452765679381516405015784498511345136923293313107025304624821870346710591020483644332361041 / 70303191829856210261218613947003274048862030890693174691057167331467677713519197425081652985388685667725668715667072786382782275463601552823247713594771331535610118982642419399942585791311885087868913258559027220556055142307126912984890431171452173521507180621715976534133436737190377187674798094933460577119501473470122387669540337503454200802611363603905865663617381478278985073508281220973097134177360flag[    16] = 861213459618800635980908762431887453130690039744021489676272811252339111506547068326575312581482641230115288118062762058810601836638224532023901869148002712207608878099715831214905749629077894633991833351216771043843037338219613551234098593505551504978788179664358071455377274133270389363464604100908033564647036460300697073894865437645538471236181203672538362517067280984107395984610847492259850454653687 / 17575797957464052565304653486750818512215507722673293672764291832866919428379799356270413246347171416931417178916768196595695568865900388205811928398692832883902529745660604849985646447827971271967228314639756805139013785576781728246222607792863043380376795155428994133533359184297594296918699523733365144279875368367530596917385084375863550200652840900976466415904345369569746268377070305243274283544340flag[    50] = 5389532113412151751299492060732273506518184376927034892632825060270115663910131858165879826910364623085516402239499563714301946910479121309695970873212193419808425757856749399267199805874274962872794906415079644252333229564204011386698056058032425290562078339180963131641291131179791821069055657674420630383090229680767184468506535062020111993855418757917802204733786495755701316418542412964134684989 / 70303191829856210261218613947003274048862030890693174691057167331467677713519197425081652985388685667725668715667072786382782275463601552823247713594771331535610118982642419399942585791311885087868913258559027220556055142307126912984890431171452173521507180621715976534133436737190377187674798094933460577119501473470122387669540337503454200802611363603905865663617381478278985073508281220973097134177360for i in range(64):    print(chr(round(flag[i])),end=&#x27;&#x27;)\n\n\n\n但是看别的师傅的wp，有逆算法直接就解出来了，还有用cv2库的\nPytranspyinstxtractor.py 解包\npyc反编译可以看到打开了一个so文件，ida打开这个so文件，有一个check函数，里面有一个方程，z3求解一下得到：511 112 821 949 517 637 897 575 648 738。\n在linux里运行一下，一开始的输入就是这10个数，再输一遍，然后说让走迷宫。（比赛时就是这是卡住了）\n接下来继续看pyc反编译的代码：\ndecoded_data = base64.b64decode(scrambled_code_string)uncompressed_data = zlib.decompress(decoded_data)exec(__import__(&#x27;marshal&#x27;).loads(uncompressed_data))\n\n看不太懂，问问gpt：\n这段代码是Python的代码，它的作用是将经过base64编码和zlib压缩的Python代码字符串解码并执行。具体来说，代码首先使用Python内置的base64模块对经过编码的字符串进行解码，得到被编码的二进制数据。然后，它使用zlib模块对二进制数据进行解压缩，得到未压缩的二进制数据。最后，代码使用marshal模块将未压缩的二进制数据转换为可执行的Python代码对象，并使用exec()函数将其执行。需要注意的是，这段代码的来源不明，它可能包含有害代码或安全漏洞，因此不应该随意运行。如果您不确定代码的来源和用途，请谨慎处理。\n\n既然能执行，那看看uncompressed_data里面是什么东西\n打印出来后，放入010，是一个缺了文件头的pyc，补上之后反编译：\nfootprint = &#x27;3qzqns4hj6\\neeaxc!4a-%\\nd735_@4l6g\\nf1gd1v7hdm\\n1+$-953&#125;81\\na^21vbnm3!\\n-#*f-e1d8_\\n2ty9uipok-\\n6r1802f7d1\\n9wez1c-f&#123;0&#x27;xx0000 = []footprintlist = footprint.split(&#x27;\\n&#x27;)for i in range(len(footprintlist)):    xx0000.append(list(footprintlist[i]))else:    def xxxx000x0(num):        xx000000 = format(num, &#x27;010b&#x27;)        return xx000000    oxooxxxxxoooo = []    xx0000000 = input(&quot;Please enter the previous 10 digits again and ending with &#x27;\\\\n&#x27;: &quot;).split(&#x27; &#x27;)    if len(xx0000000) == 10:        try:            for i in xx0000000:                oxooxxxxxoooo.append(int(i))        except:            print(&#x27;err input!&#x27;)            exit(-1)    else:        print(&#x27;err input!&#x27;)        exit(-1)    for i in range(len(oxooxxxxxoooo)):        oxooxxxxxoooo[i] = list(xxxx000x0(oxooxxxxxoooo[i]))    else:        xx0000x000 = oxooxxxxxoooo        x, o = (0, 0)        xx00x00x0xxx00 = [(x, o)]        xx00x00x0xxx00input = list(input(&#x27;input maze path:&#x27;))        count = 0        while (x, o) != (9, 9):            if count &lt; len(xx00x00x0xxx00input):                xx0000x0xxx00 = xx00x00x0xxx00input[count]                if xx0000x0xxx00 == &#x27;a&#x27;:                    if o &gt; 0 and xx0000x000[x][o - 1] == &#x27;0&#x27;:                        o -= 1                        count += 1                        xx00x00x0xxx00.append((x, o))                    else:                        print(&#x27;wrong!&#x27;)                        exit(-1)                elif xx0000x0xxx00 == &#x27;d&#x27;:                    if o &lt; 9 and xx0000x000[x][o + 1] == &#x27;0&#x27;:                        count += 1                        o += 1                        xx00x00x0xxx00.append((x, o))                    else:                        print(&#x27;wrong!&#x27;)                        exit(-1)                else:                    if xx0000x0xxx00 == &#x27;w&#x27;:                        if x &gt; 0 and xx0000x000[x - 1][o] == &#x27;0&#x27;:                            count += 1                            x -= 1                            xx00x00x0xxx00.append((x, o))                        else:                            print(&#x27;wrong!&#x27;)                            exit(-1)                    else:                        if xx0000x0xxx00 == &#x27;s&#x27;:                            if x &lt; 9 and xx0000x000[x + 1][o] == &#x27;0&#x27;:                                count += 1                                x += 1                                xx00x00x0xxx00.append((x, o))                            else:                                print(&#x27;wrong!&#x27;)                                exit(-1)                        else:                            print(&#x27;wrong!&#x27;)                            exit(-1)            else:                print(&#x27;wrong!&#x27;)                exit(-1)        print(&#x27;right! you maybe got it,flag is flag&#123;the footprint of the maze path&#125;&#x27;)\n\n是一个迷宫，迷宫是利用输入的10个数生成的，我们可以修改源码，让他生成完后，自己输出迷宫：\n\n从左上角走到右下角，路径：sddsdssdddwwwddsssssaaaaassddsddwdds\n剩下的就简单咯\nEmoji Connect是个小游戏，代码段其实挺复杂的，可以一段段问gpt，大概了解到是一个连连看。\nflag处理：\nint num = (array[0] - 55296) * 1024 + array[1] - 56320 + 65536 - 128512;this.number[num] -= (list[1].Row - 1) * (list[1].Column - 1);this.number[num] -= (list[0].Row - 1) * (list[0].Column - 1);\n\nnum数组给出，array数组也有，应该是最后全消了，所以数据都用到了，嫖的脚本：\narray=[]for i in range(48):    array.append([0]*48)    array[0][0] = &quot;d83dde08&quot;;array[0][1] = &quot;d83dde11&quot;;&#x27;&#x27;&#x27;......&#x27;&#x27;&#x27;array[47][46] = &quot;d83dde0f&quot;;array[47][47] = &quot;d83dde25&quot;;number=[25588, 31114, 28727, 26722, 24948, 25135, 25480, 29029, 23025, 25775, 15411, 25423, 25202, 30031, 27380, 30734, 25054, 25109, 20741, 28568, 28802, 24591, 26063, 30940, 30375, 19411, 29573, 20845, 27232, 26743, 25779, 24986, 31498, 30978, 22945, 26563, 35012, 29994, 27016, 29535, 21342, 26573, 27569, 25408, 31567, 25503, 21385, 27207]for i in range(48):    for j in range(48):        x=int(array[i][j][:4],16)        y=int(array[i][j][4:],16)        num = (x - 55296) * 1024 + y - 56320 + 65536 - 128512        number[num]-=i*jprint(bytes(number))print(b&#x27;flag&#123;&#x27;+bytes(number)[6:-6]+b&#x27;&#125;&#x27;)\n\nOldSymbolicCode是MS-DOS的应用程序，可以使用DOSbox运行，并且可以动调。\n逻辑是判断长度是否为36，rc4+tea加密\n","categories":["网安"],"tags":["逆向"]},{"title":"ciscn  逆向wp","url":"/2023/05/31/ciscn/","content":"babyre需要注意的是密文的顺序，加点逻辑，让他自己打印出来\nmovAside先说混淆原理：(66条消息) movfuscator混淆_mov混淆_Cherest_San的博客-CSDN博客\n实现：(68条消息) movfuscator混淆_mov混淆_Cherest_San的博客-CSDN博客\n这种题解混淆后也很难看，所以逻辑一定是简单的，不然没法逆，一般去看函数表\n解决：ltrace 看函数表，可以发现到最后的比较就是输入的flag经过加密后与密文进行逐字符比较，如图：\n\n所以在ida里再在plt表里修改一下，使strcmp调用的时候跳转到put函数，让他把密文打印出来，之后dump（右键-&gt;patching-&gt;apply patches to)\n密文的话进入data段第一个数据就是，（验证了程序本身是简单的），与输出的密文比较一下就看出来了\n再使用pwntools的逐字符爆破脚本：\nfrom pwn import *context(log_level=&#x27;debug&#x27;)flag = [0x67, 0x9D, 0x60, 0x66, 0x8A, 0x56, 0x49, 0x50, 0x65, 0x65,   0x60, 0x55, 0x64, 0x5C, 0x65, 0x48, 0x50, 0x51, 0x5C, 0x55,   0x67, 0x51, 0x57, 0x5C, 0x49, 0x67, 0x54, 0x63, 0x5C, 0x54,   0x62, 0x52, 0x56, 0x54, 0x54, 0x50, 0x49, 0x53, 0x52, 0x52,   0x56, 0x8C]flag1 = &#x27;&#x27;index = 0while True:\tfor i in range(33, 127):\t\tp = process(&quot;./moveAsidea&quot;)\t\tp.recvline()\t\tp.sendline(chr(i).encode())\t\tp.recvline()\t\ta = p.recvline().decode(&#x27;ISO-8859-1&#x27;).strip(&#x27;\\n&#x27;)\t\tprint(flag1)\t\tif index == len(flag):\t\t\tbreak\t\tif ord(a) == flag[index]:\t\t\tindex += 1\t\t\tflag1 += chr(i)\t\tp.close()print(flag1)\n\nemm,这个脚本嫖的，不太会写，不过原理就是输入一个字符看回显，手动也可以模拟这个过程，把映射表一个一个弄出来就行了……\n效果：\nezbyte学到了 try catch 块处理异常，C++异常处理（try catch）从入门到精通 (biancheng.net)，这个网站讲的真不错\nDWARF字节码，按栈展开，通过DWARF Expression将代码隐藏在栈展开过程中 (buaq.net)\nDWARF字节码，使用readelf 就可以看到r12寄存器的值使用了4个表达式，解出来就是答案，但因为这个题简单可以这样直接手搓字节码，通解是用好几个脚本把栈展开的部分提取出来，并且可以转成伪代码\n","categories":["网安"],"tags":["逆向"]},{"title":"d3ctf  逆向wp","url":"/2023/05/31/d3ctf/","content":"d3rc4多线程，rc4，pipe通信\n","categories":["网安"],"tags":["逆向"]},{"title":"linux ptrace","url":"/2023/06/01/linux%20ptrace/","content":"","categories":["网安"],"tags":["逆向"]},{"title":"陕西省赛  逆向wp","url":"/2023/06/06/%E9%99%95%E8%A5%BF%E7%9C%81%E8%B5%9B/","content":"比赛（3&#x2F;4）\n我的upx -d怎么坏了：魔改upx壳，先手脱壳，dump出来，可以看到就是一个迷宫：\n\n从S走到#\nBabypython字节码，逻辑挺多的，但是对输入的加密不多，逆着来看，程序会输出output：&#x3D;1nb0A3b7AUQwB3b84mQ&#x2F;E0MvJUb+EXbx5TQwF3bt52bAZncsd9c，根据字节码，最后输出时是先base64加密，再逆序，再替换了三个字符，字节码翻译成伪代码如图：\n\n那么再看output是如何生成的，继续手搓字节码，得到伪代码：\n\n只有两部分对output有作用，其他不用管，大概逻辑就是先将flag逐位异或8，再+3，存到了output里。那么先求出base后的output：qglrv@onmlqpA&gt;qmq&gt;mBo3A?Bn&lt;lppA@;lp4nx\nExp\n\nFlag：flag{5dcbafe63fbf3b7d8647c1aee650ae9c}\nBadCoffee是一道加了混淆后的js代码，混淆主要就是在数字和字符串上，逻辑感觉上并无影响，虽然关键逻辑就一点点。\n一步一步手动解混淆，把表达式都求出来，是两个42个数字的数组，再将一些不好看的字符串重命名一下。再看逻辑，如图：\n\nXxx函数就是传入两个数进行异或。大概就是将input逐位异或num_42数组，再倒着异或一遍num_42数组，得到了最后的密文，在最后有对密文的比较，如图：\n\n所以解密exp：\n\n\nFlag：flag{I_c0uld_neu3r_undeRstand_jvaVs3rIpt!}\n","categories":["网安"],"tags":["逆向"]}]