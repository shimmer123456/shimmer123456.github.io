[{"title":"word笔记","url":"/2022/11/24/word%E7%AC%94%E8%AE%B0/","content":"word笔记一.删除空格1.打开替换\n2.查找内容内输入‘ ’ ，表示键入一个空格\n3.替换为内为空 \n4.全部替换即可\n二.删除空段1.打开”查找与替换”\n2.更多—-&gt;特殊格式—-&gt;段落标记(^p)—–&gt;两次,出现两个^p—-&gt;替换内容为^p(一个)\n3.全部替换即可\n4.原理:\n没有空格的空段是怎样产生的？不正是我们连打了两次回车之后才有的么？现在把两个连续的回车替换成一个，正好消除了那个空段。\n如果有连续的空段的话，一次替换不完，你可以多按几次“全部替换”，直到提示找不到替换的对象为止\n删除其余类似:“^l”表示软回车，“^p”表示硬回车，“^t”表示制表符，“^m”表示手动分页符，\n“^+”表示长划线(—)，“^&#x3D;”表示短划线(–)，“^l”表示人工换行符，^n表示分栏符\n三.将可以排列整齐的数据排列整齐1.ctrl+a 全选\n2.插入表格,强制使他们分开\n3.删除表格:布局–&gt;转换为文本.\n四.把不连续的编号变为连续\n1.ctrl+f9 创建一个空域  输入seq a  外面一个点\n2.剪切\n3.ctrl +h查找\n4.更多,使用通配符\n5.查找内容:(^13)[0-9]{1,}.     (硬回车)\n6.替换为:\\1^c  \n7.f9刷新\n 设置自动调整:\n1.ctrl +f9创建一个空域\n2.输入{autonum} 剪切\n3.查找替换重复以上\n4.f9更新\n","categories":["office"],"tags":["word"]},{"title":"算法基础","url":"/2022/11/24/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","content":"一.排序1.快排模板#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n, i, j;int q[N];void quick_sort(int q[], int l, int r)&#123;\tif (l &gt;= r) return;int x = q[(l+r)/2]; i = l - 1; j = r + 1;while (i&lt;j)&#123;\tdo i++; while (q[i] &lt; x);\tdo j--; while (q[j] &gt; x);\tif (i&lt;j) swap(q[i], q[j]);&#125;quick_sort(q, l, j);quick_sort(q, j + 1, r);&#125;int main()&#123;\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tscanf(&quot;%d&quot;, &amp;q[i]);\t&#125;\tquick_sort(q, 0, n - 1);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tprintf(&quot;%d&quot;, q[i]);\t&#125;\treturn 0;&#125;\n\n2.归并排序归并排序（acwing 逆序对的数量）\n个人理解，归并排序在递归完成之后会将整个数组相邻两个数分为一组，这时，只存在左右两边的情况，而本层计算完成之后，返回上一层计算，这里的同时在 一边的逆序数对刚刚已经计算完了（往上一层分组减少一半），所以只需要计算跨左右的情况就可以了\n #include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define array arrconst int N = 100010;int array[N];int nums;unsigned long result = 0;void merge_sort(int array[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = (l + r) / 2;    merge_sort(array, l, mid);//递归左右两边  递归结果就是两个为一组    merge_sort(array, mid + 1, r);//    int temp[r - l + 1];    int lptr = l;    int rptr = mid + 1;    int tempptr = 0;    while (lptr &lt;= mid &amp;&amp; rptr &lt;= r)    &#123;        if (array[lptr] &lt;= array[rptr])        &#123;            temp[tempptr++] = array[lptr++];        &#125;        else &#123;            temp[tempptr++] = array[rptr++];            result += (mid - lptr + 1);//注意这里，是直接加的，后面的不需要比较了。        &#125;    &#125;    while (lptr &lt;= mid)    &#123;        temp[tempptr++] = array[lptr++];    &#125;    while (rptr &lt;= r)    &#123;        temp[tempptr++] = array[rptr++];    &#125;    for (int i = l, j = 0; i &lt;= r; i++, j++)    &#123;        array[i] = temp[j];    &#125;&#125;int main() &#123;    scanf(&quot;%d&quot;, &amp;nums);    for (int i = 0; i &lt; nums; i++)    &#123;        scanf(&quot;%d&quot;, &amp;array[i]);    &#125;    merge_sort(array, 0, nums - 1);    cout &lt;&lt; result;    return 0;&#125;\n\n二.查找1.二分查找#include &lt;iostream&gt;using namespace std;int main()&#123;\tint n, num[105], targe;\tcin &gt;&gt; n;\tfor (int i = 0; i &lt; n; i++)\t&#123;\t\tcin &gt;&gt; num[i];\t&#125;\tcin &gt;&gt; targe;\tint l = 0, r = n - 1;\twhile (l &lt;= r)\t&#123;\t\tint mid = (l + r) &gt;&gt; 1;\t\tif (num[mid] == targe)\t\t&#123;\t\t\tcout &lt;&lt; targe &lt;&lt; &quot;in index&quot; &lt;&lt; mid &lt;&lt; endl;\t\t\treturn 0;\t\t&#125;\t\tif (num[mid] &lt; targe)\t\t&#123;\t\t\tr = mid - 1;\t\t&#125;\t\telse\t\t&#123;\t\t\tl = mid + 1;\t\t&#125;\t&#125;\tcout &lt;&lt; &quot;no&quot; &lt;&lt; endl;\treturn 0;&#125;\n\n三.数据结构1.Trie树 高效的存储和查找字符串集合的数据结构\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26], cnt[N], idx;int i;void insert(char str[])//插入一个字符串&#123;\tint p = 0;//节点 从零开始\t\tfor ( i = 0; str[i]; i++)\t&#123;\t\tint u = str[i] - &#x27;a&#x27;;\t\tif (!son[p][u]) son[p][u] = ++idx;//如果没有对应的下一节点，创造一个 idx给了个编号\t\tp = son[p][u];       //idx是每次加一的，所以使得p每次加一；\t\t//也就是上一节点存储下一节点的位置，在接下来查找的时候才可以找到\t&#125;\tcnt[p]++;//以p为节点的结束次数！！！&#125;int query(char str[])//查找&#123;\tint p = 0;\tfor ( i = 0; str[i]; i++)\t&#123;\t\tint u = str[i] - &#x27;a&#x27;;\t\tif (!son[p][u]) return 0;\t\tp = son[p][u];//son[p][u]的值就是下一个节点的坐标\t&#125;\treturn cnt[p];&#125;char str[N];int main()&#123;\tint n;\tscanf(&quot;%d&quot;, &amp;n);\twhile (n--)\t&#123;\t\tchar op[2];\t\tscanf(&quot;%s%s&quot;, op,str);\t\tif (op[0] == &#x27;I&#x27;) insert(str);\t\telse printf(&quot;%d\\n&quot;, query(str));\t&#125;\treturn 0;&#125;\n\n2.并查集1.将两个集合合并2.询问两个元素是否在一个集合中\n原理：每个集合用一颗树来表示，树根的编号就是集合的编号；每个节点存储他的父节点p[x]表示x的父节点1.如何判断树根 p[x]&#x3D;x则是树根2.如何求x的树根编号： while(p[x]!&#x3D;x) x&#x3D;p[x];   只要不等，一直往上走；3.如何合并集合  两棵树 一颗插入另一颗px是x的集合编号 py是y的集合编号   p[x]&#x3D;y 即可\n对2. 优化：（路径压缩） 一旦往上走找到根节点，那么将该路径上的所有点直接指向根节点   大概为o1的时间复杂度\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int p[N]; int find(int x)//核心&#123;\tif (p[x] != x) p[x] = find(p[x]);//返回x的祖宗节点 并且加路径优化\treturn p[x];&#125; int main()&#123;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\tfor (int i = 0; i &lt;= n; i++) p[i] = i;\twhile (m--)\t&#123;\t\tchar op[2];\t\tint a, b;\t\tscanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b);\t\tif (op[0] == &#x27;M&#x27;)\t\t&#123;\t\t\tp[find(a)] = find(b);//把b的祖宗节点插入a的祖宗节点下当儿子\t\t&#125;\t\telse\t\t&#123;\t\t\tif (find(a) == find(b))\t\t\t&#123;\t\t\t\tputs(&quot;yes&quot;);\t\t\t&#125;\t\t\telse\t\t\t\tputs(&quot;No&quot;);\t\t&#125;\t&#125;\treturn 0;&#125;\n\n3.前缀和求区间 [r,l] 之中数的和\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], s[N];int main()&#123;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);//n个数  m次操作\tfor (int i = 1; i &lt;= n; i++)//注意是1~n\t&#123;\t\tscanf(&quot;%d&quot;, &amp;a[i]);//读入n个数\t&#125;\tfor (int i = 1; i &lt;= n; i++)//注意1~n\t&#123;\t\ts[i] = s[i - 1] + a[i];//预处理\t&#125;\twhile (m--)\t&#123;\t\tint l, r;\t\tscanf(&quot;%d%d&quot;, &amp;l, &amp;r);//求l到r区间的和\t\tprintf(&quot;%d\\n&quot;, s[r] - s[l - 1]);\t&#125;\treturn 0;&#125;\n\n4.差分（前缀的逆运算）\n在指定区间都加c（原数组a[N]）由o(n) 到 o(1)\n#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], b[N];int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)//1~n    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        b[i] = a[i] - a[i - 1];      //构建差分数组    &#125;    int l, r, c;    while (m--)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c);        b[l] += c;     //将序列中[l, r]之间的每个数都加上c        b[r + 1] -= c;    &#125;    for (int i = 1; i &lt;= n; i++)//1~n    &#123;        a[i] = b[i] + a[i - 1];    //前缀和运算        printf(&quot;%d &quot;, a[i]);    &#125;    return 0;&#125;\n\n5.单链表数组模拟的，但其实通常用stl\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int e[N], ne[N], head, idx;//对链表进行初始化void init() &#123;    head = -1;//最开始的时候，链表的头节点要指向-1，    //为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束    /*    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针    当它在初始化的时候指向-1，来表示链表里没有内容。    */    idx = 0;//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找    //第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下    //标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！    /*    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。    另外，我们遍历链表的时候也是这样，靠的是ne[]    */&#125;//将x插入到头节点上void int_to_head(int x) &#123;//和链表中间插入的区别就在于它有head头节点    e[idx] = x;//第一步，先将值放进去    ne[idx] = head;//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了    //先在只是做到了第一步，将元素x的指针指向了head原本指向的    head = idx;//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）    idx++;//指针向下移一位，为下一次插入元素做准备。&#125;//e[idx]=x;// ne[idx]=head;// head=idx;// idx++;//将x插入到下标为k的点的后面void add(int k, int x) &#123;    e[idx] = x;//先将元素插进去    e[idx]=x;ne[idx]=ne[k];ne[k]=idx;idx++;    ne[idx] = ne[k];//让元素x配套的指针，指向它要占位的元素的下一个位置    ne[k] = idx;//让原来元素的指针指向自己    idx++;//将idx向后挪&#125;//将下标是k的点后面的点个删掉void remove(int k) &#123;    ne[k] = ne[ne[k]];//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。&#125;//ne[k]=ne[ne[k]]//传进来的是k-1int main() &#123;    cin &gt;&gt; n;    init();//初始化    for (int i = 0; i &lt; n; i++)     &#123;        char s;        cin &gt;&gt; s;        if (s == &#x27;H&#x27;) &#123;            int x;            cin &gt;&gt; x;            int_to_head(x);        &#125;        if (s == &#x27;D&#x27;) &#123;            int k;            cin &gt;&gt; k;            if (k == 0) head = ne[head];//删除头节点            else remove(k - 1);//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1        &#125;        if (s == &#x27;I&#x27;) &#123;            int k, x;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);//同样的，第k个数，和下标不同，所以要减1        &#125;    &#125;    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;    return 0;&#125;\n\n6.队列我觉得是一个双指针在维护这个数据结构吧先进的先出  后进的后出 tt就是维护队尾位置的下标 如果要队头出列的话 hh++就可以 遍历的时候i&lt;&#x3D;hh就可以了（输出时候队头开始遍历）\n#include&lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1e6 + 10;int qu[N], hh = 0, tt = -1;//初始化很重要！！！int main()&#123;    int n;    cin &gt;&gt; n;    while (n--)    &#123;        int x;        string a;        cin &gt;&gt; a;        if (a == &quot;push&quot;)            cin &gt;&gt; x, qu[++tt] = x;//元素只能队尾入队        else if (a == &quot;pop&quot;)            hh++;//注意元素只能队头弹出，且是 ++        else if (a == &quot;empty&quot;)//队内是否为空        &#123;            if (tt &lt; hh)                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else//查询队头            cout &lt;&lt; qu[hh] &lt;&lt; endl;    &#125;     for (int i = tt; i &lt;= hh; i++)    &#123;        printf(&quot;%d&quot;, qu[i]);    &#125;    return 0;&#125;\n\n\n\n四.搜索1.DFS输出n个数的全排列\n（DFS八皇后也仅仅是扩展到二维数组而已 （acwing））\n#include &lt;iostream&gt;using namespace std;const int N = 10;int n;bool book[N];int st[N];void dfs(int u)&#123;\tif (u &gt; n)\t&#123;\t\tfor (int i = 1; i &lt;= n; i++)\t\t&#123;\t\t\tprintf(&quot;%d&quot;, st[i]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t\treturn;\t&#125;\tfor (int i = 1; i &lt;= n; i++)\t&#123;\t\tif (!book[i])\t\t&#123;\t\t\tst[u]=i;\t\t\tbook[i] = true;\t\t\tdfs(u + 1);\t\t\t\t\t\t\t\t\t //能走到这一步说明是打印完之后return的，来到了当时的上一层，在这\t\t\tst[u] = 0;  //回溯\t\t\tbook[i] = false;  \t\t\t////////  忘了时候再仔细调试看看，终于懂了。\t\t&#125;\t&#125;&#125;int main()&#123;\tcin &gt;&gt; n;\tdfs(1);\treturn 0;&#125;\n\n1.1dfs的例题dfs的指数级枚举，真的妙！！！ \n#include &lt;iostream&gt;using namespace std;const int N = 1e1 + 6; //定义一个常量Nint n;int st[N];  //记录每个位置当前的状态：0表示还没考虑，1表示选它，2表示不选它void dfs(int u) // 枚举的第几个数字&#123;    if (u &gt; n) &#123;        //终止条件，因为题目要求一个就n个数 所以只有 u &gt; n 就输出枚举的方案        for (int i = 1; i &lt;= n; i++)            if (st[i] == 1)                printf(&quot;%d &quot;, i);        puts(&quot;&quot;);        return;    &#125;    st[u] = 1;   //选它的分支    dfs(u + 1);    st[u] = 0;   //恢复现场，以便进行下一个分支    st[u] = 2; //  不选它的分支    dfs(u + 1);    st[u] = 0;  // 恢复现场&#125;int main(void)&#123;    scanf(&quot;%d&quot;, &amp;n);    dfs(1);    return 0;&#125;\n\n\n\n2.BFS在DFS中我们说关键点是递归以及回溯，\n在BFS中，关键点则是状态的选取和标记\n 悟了悟了！！！！\n​       BFS 迷宫：  一个while大循环，只要不空就以一直走  每次取出队头  下面一个for的四个方向的循环 符合条件就会向外扩展 注意都是扩展在t的基础上的（一个点） 然后：每个被扩展出来的都会进队列，继续扩展，如果扩展不了就四个for都不满足，在下一次循环中他就被弹出了！  okay！！！\n#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;#define x first#define y second int n, m;typedef pair&lt;int, int&gt;PII;int a[110][110];   //储存地图int dis[110][110];  //储存距离int pos[4][2] = &#123; -1,0,0,1,1,0,0,-1 &#125;; //偏移量数组void bfs(PII start)&#123;    queue&lt;PII&gt; q;    q.push(start);\t\t//初始状态入队        while (!q.empty()) \t//队列不空时        &#123;            PII t = q.front();       // 取出队首元素，存放到 t 变量里 ，元素出队            q.pop(); \t\t\t\t//元素出队            for (int i = 0; i &lt; 4; i++)//\t扩展 t 结点        &#123;           int tx = t.x + pos[i][0],ty = t.y + pos[i][1];           if (a[tx][ty] == -1 || a[tx][ty] == 1)continue; //判断是否越界或者碰到障碍           if (a[tx][ty] == 0)\t\t//如果未被访问，           &#123;               dis[tx][ty] = dis[t.x][t.y] + 1; //记录当前点到起点的距离               a[tx][ty] = -1;\t\t\t    //标记扩展的新结点被访问               q.push(&#123;tx,ty&#125;);\t\t\t\t//将扩展的新节点入队           &#125;           if (tx == n &amp;&amp; ty == m) //如果到达右下角           &#123;           cout &lt;&lt; dis[tx][ty]; //返回右下角到起点的距离           return;           &#125;        &#125;        &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(a, -1, sizeof a); //初始化为 - 1 ，这样方便 判断边界        for (int i = 1; i &lt;= n; i++) //从1开始读入地图方便判断边界，这样地图都会被初始化的 - 1 包围            for (int j = 1; j &lt;= m; j++) //这样判断扩展的点是否越界时，只要判断是不是 - 1 即可            &#123;                cin &gt;&gt; a[i][j];            &#125;    PII start; //定义一个二元组，储存起点，传入到BFS函数里        start.x = 1, start.y = 1;    bfs(start);    return 0;&#125;\n\n五.感悟1.csp  201403-2（窗口）\n独立完成，有点开心，放在这吧\n#include &lt;iostream&gt;using namespace std;int n, m;int a[2600], b[1500], c[2600], d[1500];int s[2600][1500];void chu(int a, int b, int c, int d, int q)&#123;\tfor (int i = a; i &lt;= c; i++)\t&#123;\t\tfor (int j = b; j &lt;= d; j++)\t\t&#123;\t\t\ts[i][j] = q;\t\t&#125;\t&#125;&#125;int main()&#123;\tcin &gt;&gt; n &gt;&gt; m;\tfor(int q=1;q&lt;=n;q++)\t&#123;\t\tcin &gt;&gt; a[q] &gt;&gt; b[q] &gt;&gt; c[q] &gt;&gt; d[q];\t\tchu(a[q], b[q], c[q], d[q], q);\t&#125;\twhile(m--)\t&#123;\t\tint x, y;\t\tcin &gt;&gt; x &gt;&gt; y;\t\tif (s[x][y] &gt; 0)\t\t&#123;\t\t\tcout &lt;&lt; s[x][y]&lt;&lt;endl;\t\t\t\t\t&#125;\t\telse\t\t&#123;\t\t\tcout &lt;&lt; &quot;IGNORED\\n&quot;;\t\t&#125;\t\tchu(a[s[x][y]], b[s[x][y]], c[s[x][y]], d[s[x][y]], s[x][y]);\t&#125;\treturn 0;&#125;\n\n","categories":["数据结构与算法"],"tags":["基础"]},{"title":"css基础","url":"/2022/11/24/CSS3/","content":"CSS31.初识CSS3CSS3给我们带来了什么好处呢？简单的说，CSS3把很多以前需要使用图片和脚本来实现的效果、甚至动画效果，只需要短短几行代码就能搞定。比如圆角，图片边框，文字阴影和盒阴影，过渡、动画等。\n选择器以前我们通常用class、 ID 或 tagname 来选择HTML元素，CSS3的选择器强大的难以置信。它们可以减少在标签中的class和ID的数量更方便的维护样式表、更好的实现结构与表现的分离。\n\n圆角效果以前做圆角通常使用背景图片，或繁琐的元素拼凑，现在很简单了 border-radius 帮你轻松搞定。\n\n块阴影与文字阴影可以对任意DIV和文字增加投影效果。\n\n色彩CSS3支持更多的颜色和更广泛的颜色定义。新颜色CSS3支持HSL ， CMYK ，HSLA and RGBA。\n\n渐变效果以前只能用Photoshop做出的图片渐变效果，现在可以用CCS写出来了。IE中的滤镜也可以实现。\n\n个性化字体网页上的字体太单一？使用@Font-Face 轻松实现定制字体。\n\n多背景图一个元素上添加多层背景图片。\n\n边框背景图边框应用背景图片。\n\n变形处理你可以对HTML元素进行旋转、缩放、倾斜、移动、甚至以前只能用JavaScript实现的强大动画。\n\n多栏布局可以让你不用使用多个div标签就能实现多栏布局。浏览器解释这个属性并生成多栏，让文本实现一个仿报纸的多栏结构。\n\n媒体查询针对不同屏幕分辨率，应用不同的样式。\n\n等等 ……\n2. 边框2.1 圆角效果 border-radius border-radius是向元素添加圆角边框。\n使用方法：\nborder-radius:10px; &#x2F;* 所有角都使用半径为10px的圆角 *&#x2F; \nborder-radius: 5px 4px 3px 2px; &#x2F;* 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 *&#x2F; \n不要以为border-radius的值只能用px单位，你还可以用百分比或者em，但兼容性目前还不太好。\n实心上半圆：\n方法：把高度(height)设为宽度（width）的一半，并且只设置左上角和右上角的半径与元素的高度一致（大于也是可以的）。\ndiv&#123;    height:50px;/*是width的一半*/    width:100px;    background:#9da;    border-radius:50px 50px 0 0;/*半径至少设置为height的值*/    &#125;\n\n实心圆：方法：把宽度（width）与高度(height)值设置为一致（也就是正方形），并且四个圆角值都设置为它们值的一半。如下代码：\ndiv&#123;    height:100px;/*与width设置一致*/    width:100px;    background:#9da;    border-radius:50px;/*四个圆角值都设置为宽度或高度值的一半*/    &#125;\n\n2.2 阴影 box-shadow（一）box-shadow是向盒子添加阴影。支持添加一个或者多个。\n很简单的一段代码，就实现了投影效果，酷毙了。我们来看下语法：\nbox-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];参数介绍：\n\n注意：inset 可以写在参数的第一个或最后一个，其它位置是无效的。\n为元素设置外阴影：\n示例代码：\n.box_shadow&#123;  box-shadow:4px 2px 6px #333333; &#125;\n\n为元素设置内阴影：\n示例代码：\n.box_shadow&#123;  box-shadow:4px 2px 6px #333333 inset; &#125;\n\n添加多个阴影：\n以上的语法的介绍，就这么简单，如果添加多个阴影，只需用逗号隔开即可。如：\n.box_shadow&#123;    box-shadow:4px 2px 6px #f00, -4px -2px 6px #000, 0px 0px 12px 5px #33CC00 inset;&#125;效果：\n\n\n\n2.3 阴影 box-shadow（二）1、阴影模糊半径与阴影扩展半径的区别\n阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；\n阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；\n2、X轴偏移量和Y轴偏移量值可以设置为负数\nbox-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];\n\nX轴偏移量为负数：\n.boxshadow-outset&#123;    width:100px;    height:100px;    box-shadow:-4px 4px 6px #666;&#125;\n\n\n\n\n\nY轴偏移量为负数：\n.boxshadow-outset&#123;    width:100px;    height:100px;    box-shadow:4px -4px 6px #666;&#125;\n\n\n\n2.4 为边框应用图片 border-image顾名思义就是为边框应用背景图片，它和我们常用的background属性比较相似。例如：\nbackground:url(xx.jpg) 10px 20px no-repeat;\n\n但是又比背景图片复杂一些。\n想象一下：一个矩形，有四个边框。如果应用了边框图片，图片该怎么分布呢？ 图片会自动被切割分成四等分。用于四个边框。可以理解为它是一个切片工具，会自动把用做边框的图片切割。怎么切割呢？为了方便理解，做了一张特殊的图片，由9个矩形（70*70像素）拼成的一张图（210*210像素），并标注好序号，是不是像传说中的九宫图，如下：\n\n根据border-image的语法：\n#border-image&#123;   background:#F4FFFA;   width:210px; height:210px; border:70px solid #ddd;   border-image:url(borderimg.png) 70 repeat  &#125;\n\n从序号可以看出div的四个角分别对应了背景图片的四个角。而2,4,6,8 被重复。5在哪？因为是从四周向中心切割图片的所以，5显示不出来。而在chrome浏览器中5是存在的，下图的样子：repeat的意思就是重复，目前因为是刚好被整除，效果看不出来。如果改下DIV的宽高，再来看重复的效果：\n\n边角部分为裁掉了，可见repeat就是一直重复，然后超出部分剪裁掉，而且是居中开始重复。\nRound 参数：Round可以理解为圆满的铺满。为了实现圆满所以会压缩（或拉伸）；\n#border-image &#123;     width:170px;     height:170px;     border:70px solid;     border-image:url(borderimg.png) 70 round; &#125;\n\n3. 颜色相关3.1 颜色之RGBARGB是一种色彩标准，是由红(R)、绿(G)、蓝(B)的变化以及相互叠加来得到各式各样的颜色。RGBA是在RGB的基础上增加了控制alpha透明度的参数。\n语法：\ncolor：rgba(R,G,B,A)\n\n以上R、G、B三个参数，正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限。并非所有浏览器都支持使用百分数值。A为透明度参数，取值在0~1之间，不可为负值。\n代码示例：\nbackground-color:rgba(100,120,60,0.5);\n\n3.2 渐变色彩CSS3 Gradient 分为**线性渐变(linear)和径向渐变(radial)**。由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。\n这一小节我们来说一下线性渐变：\n参数：\n第一个参数:指定渐变方向，可以用“角度”的关键词或“英文”来表示：\n第一个参数省略时，默认为“180deg”，等同于“to bottom”。\n第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。\nbackground-image:linear-gradient(to left, red, orange,yellow,green,blue,indigo,violet);\n\n4. 文字与字体4.1 text-overflow 与 word-wraptext-overflow用来设置是否使用一个省略标记（…）标示对象内文本的溢出。\n但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：\ntext-overflow:ellipsis; overflow:hidden; white-space:nowrap; \n\n同时，word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行。\nnormal为浏览器默认值，break-word设置在长单词或 URL地址内部进行换行，此属性不常用，用浏览器默认值即可。\n4.2 嵌入字体@font-face@font-face能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体。\n语法：\n@font-face &#123;    font-family : 字体名称;    src : 字体文件在服务器上的相对或绝对路径;&#125;\n\n这样设置之后，就可以像使用普通字体一样在（font-*）中设置字体样式。\n比如：\np &#123;    font-size :12px;    font-family : &quot;My Font&quot;;    /*必须项，设置@font-face中font-family同样的值*/&#125;\n\n4.3 文本阴影text-shadowtext-shadow可以用来设置文本的阴影效果。\n语法：\ntext-shadow: X-Offset Y-Offset blur color;\n\nX-Offset：表示阴影的水平偏移距离，其值为正值时阴影向右偏移，反之向左偏移；   \nY-Offset：是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移，反之向上偏移；\nBlur：是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0；\nColor：是指阴影的颜色，其可以使用rgba色。\n比如，我们可以用下面代码实现设置阴影效果。\ntext-shadow: 0 1px 1px #fff\n\n5.与背景相关的样式5.1 background-origin设置元素背景图片的原始起始位置。\n语法：\nbackground-origin ： border-box | padding-box | content-box;\n\n参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。\n需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。\n5.2 background-clip用来将背景图片做适当的裁剪以适应实际需要。\n语法：\nbackground-clip ： border-box | padding-box | content-box | no-clip\n\n参数分别表示从边框、或内填充，或者内容区域向外裁剪背景。no-clip表示不裁切，和参数border-box显示同样的效果。backgroud-clip默认值为border-box。\n5.3 background-size设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。\n语法：\nbackground-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain\n\n取值说明：\n1、auto：默认值，不改变背景图片的原始高度和宽度；\n2、&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；\n**3、&lt;百分比&gt;**：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；\n4、cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；\n5、contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。\n5.4 multiple backgrounds？？？多重背景，也就是CSS2里background的属性外加origin、clip和size组成的新background的多次叠加，缩写时为用逗号隔开的每组值；用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。\n语法缩写如下：\nbackground ： [background-color] | [background-image] | [background-position][/background-size] | [background-repeat] | [background-attachment] | [background-clip] | [background-origin],...\n\n可以把上面的缩写拆解成以下形式：\nbackground-image:url1,url2,…,urlN;\nbackground-repeat : repeat1,repeat2,...,repeatN;backround-position : position1,position2,...,positionN;background-size : size1,size2,...,sizeN;background-attachment : attachment1,attachment2,...,attachmentN;background-clip : clip1,clip2,...,clipN;background-origin : origin1,origin2,...,originN;background-color : color;\n\n注意：\n\n用逗号隔开每组 background 的缩写值；\n如果有 size 值，需要紧跟 position 并且用 “&#x2F;“ 隔开；\n如果有多个背景图片，而其他属性只有一个（例如 background-repeat 只有一个），表明所有背景图片应用该属性值。\nbackground-color 只能设置一个。\n\n6. CSS3选择器6.1 属性选择器  在HTML中，通过各种各样的属性可以给元素增加很多附加的信息。例如，通过id属性可以将不同div元素进行区分。\n  在CSS2中引入了一些属性选择器，而CSS3在CSS2的基础上对属性选择器进行了扩展，新增了3个属性选择器，使得属性选择器有了通配符的概念，这三个属性选择器与CSS2的属性选择器共同构成了CSS功能强大的属性选择器。如下表所示：\n 实例展示：\nhtml代码：\n&lt;a href=&quot;xxx.pdf&quot;&gt;我链接的是PDF文件&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;icon&quot;&gt;我类名是icon&lt;/a&gt;&lt;a href=&quot;#&quot; title=&quot;我的title是more&quot;&gt;我的title是more&lt;/a&gt;\n\ncss代码 \na[class^=icon]&#123;  background: green;  color:#fff;&#125;a[href$=pdf]&#123;  background: orange;  color: #fff;&#125;a[title*=more]&#123;  background: blue;  color: #fff;&#125;\n\n\n\n6.2 结构性伪类选择器—root:root选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是。\n示例演示：\n通过“:root”选择器设置背景颜色\nHTML代码：\n&lt;div&gt;:root选择器的演示&lt;/div&gt;\n\nCSS代码：\n:root &#123;  background:orange;&#125;\n\n\n\n“:root”选择器等同于元素，简单点说：\n:root&#123;background:orange&#125;html &#123;background:orange;&#125;\n\n得到的效果等同。\n建议使用:root方法。\n另外在IE９以下还可以借助“:root”实现hack功能。\n6.3 结构性伪类选择器—not:not选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。就拿form元素来说，比如说你想给表单中除submit按钮之外的input元素添加红色边框，CSS代码可以写成：\nform &#123;  width: 200px;  margin: 20px auto;&#125;div &#123;  margin-bottom: 20px;&#125;input:not([type=&quot;submit&quot;])&#123;  border:1px solid red;&#125;\n\n相关HTML代码：\n&lt;form action=&quot;#&quot;&gt;  &lt;div&gt;    &lt;label for=&quot;name&quot;&gt;Text Input:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;John Smith&quot; /&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;label for=&quot;name&quot;&gt;Password Input:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;John Smith&quot; /&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  &lt;/div&gt;&lt;/form&gt;  \n\n\n\n6.4 结构性伪类选择器—empty:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。\n示例显示：\n比如说，你的文档中有三个段落p元素，你想把没有任何内容的P元素隐藏起来。我们就可以使用“:empty”选择器来控制。\nHTML代码：\n&lt;p&gt;我是一个段落&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n\nCSS代码：\np&#123; background: orange; min-height: 30px;&#125;p:empty &#123;  display: none;&#125;\n\n\n\n6.5 CSS3 结构性伪类选择器—target:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。我们先来上个例子，然后再做分析。\n示例展示\n点击链接显示隐藏的段落。\nHTML代码：\n&lt;h2&gt;&lt;a href=&quot;#brand&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;menuSection&quot; id=&quot;brand&quot;&gt;    content for Brand&lt;/div&gt;\n\nCSS代码：\n.menuSection&#123;  display: none;&#125;:target&#123;/*这里的:target就是指id=&quot;brand&quot;的div对象*/  display:block;&#125;\n\n\n\n分析：\n1、具体来说，触发元素的URL中的标志符通常会包含一个**#号，后面带有一个标志符名称**，上面代码中是：#brand\n2、：target就是用来匹配id为“brand”的元素（id&#x3D;”brand”的元素）,上面代码中是那个div元素。\n多个url（多个target）处理：\n就像上面的例子，#brand与后面的id&#x3D;”brand”是对应的，当同一个页面上有很多的url的时候你可以取不同的名字，只要#号后对的名称与id&#x3D;””中的名称对应就可以了。如下面例子：html代码：  \n&lt;h2&gt;&lt;a href=&quot;#brand&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;menuSection&quot; id=&quot;brand&quot;&gt;  content for Brand&lt;/div&gt;&lt;h2&gt;&lt;a href=&quot;#jake&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;menuSection&quot; id=&quot;jake&quot;&gt; content for jake&lt;/div&gt;&lt;h2&gt;&lt;a href=&quot;#aron&quot;&gt;Brand&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;menuSection&quot; id=&quot;aron&quot;&gt;    content for aron&lt;/div&gt;\n\ncss代码：\n#brand:target &#123;  background: orange;  color: #fff;&#125;#jake:target &#123;  background: blue;  color: #fff;&#125;#aron:target &#123;  background: red;  color: #fff;&#125;\n\n上面的代码可以对不同的target对象分别设置不的样式。\n6.6 CSS3 结构性伪类选择器—first-child“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。\n示例演示\n通过“:first-child”选择器定位列表中的第一个列表项，并将序列号颜色变为红色。\nHTML代码：\n&lt;ol&gt;  &lt;li&gt;&lt;a href=&quot;##&quot;&gt;Link1&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;##&quot;&gt;Link2&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;##&quot;&gt;link3&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;\n\nCSS代码：\nol &gt; li&#123;  font-size:20px;  font-weight: bold;  margin-bottom: 10px;&#125;ol a &#123;  font-size: 16px;  font-weight: normal;&#125;ol &gt; li:first-child&#123;  color: red;&#125;\n\n\n\n6.7 CSS3 结构性伪类选择器—last-child“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。例如，需要改变的是列表中的最后一个“li”的背景色，就可以使用这个选择器，\nul&gt;li:last-child&#123;background:blue;&#125;\n\n示例演示\n在博客的排版中，每个段落都有15px的margin-bottom，假设不想让博客“post”中最后一个段落不需要底部的margin值，可以使用“:last-child”选择器。\nHTML代码：\n&lt;div class=&quot;post&quot;&gt;  &lt;p&gt;第一段落&lt;/p&gt;  &lt;p&gt;第二段落&lt;/p&gt;  &lt;p&gt;第三段落&lt;/p&gt;  &lt;p&gt;第四段落&lt;/p&gt;  &lt;p&gt;第五段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.post &#123;  padding: 10px;  border: 1px solid #ccc;  width: 200px;  margin: 20px auto;&#125;.post p &#123;  margin:0 0 15px 0;&#125;.post p:last-child &#123;  margin-bottom:0;&#125;\n\n\n\n6.8 CSS3 结构性伪类选择器—nth-child(n)“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。\n经验与技巧:当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素。\n案例演示\n 通过“:nth-child(n)”选择器，并且参数使用表达式“2n”，将偶数行列表背景色设置为橙色。\nHTML代码：\n&lt;ol&gt;  &lt;li&gt;item1&lt;/li&gt;  &lt;li&gt;item2&lt;/li&gt;  &lt;li&gt;item3&lt;/li&gt;  &lt;li&gt;item4&lt;/li&gt;  &lt;li&gt;item5&lt;/li&gt;  &lt;li&gt;item6&lt;/li&gt;  &lt;li&gt;item7&lt;/li&gt;  &lt;li&gt;item8&lt;/li&gt;  &lt;li&gt;item9&lt;/li&gt;  &lt;li&gt;item10&lt;/li&gt;&lt;/ol&gt;\n\nCSS代码：\nol &gt; li:nth-child(2n)&#123;  background: orange;&#125;\n\n\n\n6.9 CSS3 结构性伪类选择器—nth-last-child(n)“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。\n案例演示\n选择列表中倒数第五个列表项，将其背景设置为橙色。\nHTML代码：\n&lt;ol&gt;  &lt;li&gt;item1&lt;/li&gt;  &lt;li&gt;item2&lt;/li&gt;  &lt;li&gt;item3&lt;/li&gt;  &lt;li&gt;item4&lt;/li&gt;  &lt;li&gt;item5&lt;/li&gt;  &lt;li&gt;item6&lt;/li&gt;  &lt;li&gt;item7&lt;/li&gt;  &lt;li&gt;item8&lt;/li&gt;  &lt;li&gt;item9&lt;/li&gt;  &lt;li&gt;item10&lt;/li&gt;  &lt;li&gt;item11&lt;/li&gt;  &lt;li&gt;item12&lt;/li&gt;  &lt;li&gt;item13&lt;/li&gt;  &lt;li&gt;item14&lt;/li&gt;  &lt;li&gt;item15&lt;/li&gt;&lt;/ol&gt;\n\n**CSS代码：\n6.10 CSS3 first-of-type选择器“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。\n示例演示：\n通过“:first-of-type”选择器，定位div容器中的第一个p元素（p不一定是容器中的第一个子元素），并设置其背景色为橙色。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;div&gt;我是一个块元素，我是.wrapper的第一个子元素&lt;/div&gt;  &lt;p&gt;我是一个段落元素，我是不是.wrapper的第一个子元素，但是他的第一个段落元素&lt;/p&gt;  &lt;p&gt;我是一个段落元素&lt;/p&gt;  &lt;div&gt;我是一个块元素&lt;/div&gt;&lt;/div&gt;\n\nCSS代码：\n.wrapper &#123;  width: 500px;  margin: 20px auto;  padding: 10px;  border: 1px solid #ccc;  color: #fff;&#125;.wrapper &gt; div &#123;  background: green;&#125;.wrapper &gt; p &#123;  background: blue;&#125;/*我要改变第一个段落的背景为橙色*/.wrapper &gt; p:first-of-type &#123;  background: orange;&#125;\n\n\n\n6.11 CSS3 nth-of-type(n)选择器“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词。\n示例演示\n通过“:nth-of-type(2n)”选择器，将容器“div.wrapper”中偶数段数的背景设置为橙色。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落元素&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.wrapper &gt; p:nth-of-type(2n)&#123;  background: orange;&#125;\n\n\n\n6.12 CSS3 last-of-type选择器“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素。\n示例演示\n通过“:last-of-type”选择器，将容器“div.wrapper”中最后一个段落元素背景设置为橙色\n（提示：这个段落不是“div.wrapper”容器的最后一个子元素）。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;p&gt;我是第一个段落&lt;/p&gt;  &lt;p&gt;我是第二个段落&lt;/p&gt;  &lt;p&gt;我是第三个段落&lt;/p&gt;  &lt;div&gt;我是第一个Div元素&lt;/div&gt;  &lt;div&gt;我是第二个Div元素&lt;/div&gt;  &lt;div&gt;我是第三个Div元素&lt;/div&gt;&lt;/div&gt;\n\n\nCSS代码：\n .wrapper &gt; p:last-of-type&#123;  background: orange;&#125;\n\n\n\n6.13 CSS3 nth-last-of-type(n)选择器“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。\n示例演示\n通过“:nth-last-of-type(n)”选择器将容器“div.wrapper”中的倒数第三个段落背景设置为橙色。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;p&gt;我是第一个段落&lt;/p&gt;  &lt;p&gt;我是第二个段落&lt;/p&gt;  &lt;p&gt;我是第三个段落&lt;/p&gt;  &lt;p&gt;我是第四个段落&lt;/p&gt;  &lt;p&gt;我是第五个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;  &lt;p&gt;我是第六个段落&lt;/p&gt;  &lt;p&gt;我是第七个段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.wrapper &gt; p:nth-last-of-type(3)&#123;  background: orange;&#125;\n\n\n\n6.14 CSS3 only-child选择器“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。\n示例演示\n通过“:only-child”选择器，来控制仅有一个子元素的背景样式，为了更好的理解，我们这个示例通过对比的方式来向大家演示。\nHTML代码：\n&lt;div class=&quot;post&quot;&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;post&quot;&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.post p &#123;  background: green;  color: #fff;  padding: 10px;&#125;.post p:only-child &#123;  background: orange;&#125;\n\n\n\n6.15 CSS3 only-of-type选择器“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。\n示例演示\n通过“:only-of-type”选择器来修改容器中仅有一个div元素的背景色为橙色。\nHTML代码：\n&lt;div class=&quot;wrapper&quot;&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;  &lt;div&gt;我是一个Div元素&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;wrapper&quot;&gt;  &lt;div&gt;我是一个Div&lt;/div&gt;  &lt;ul&gt;    &lt;li&gt;我是一个列表项&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;我是一个段落&lt;/p&gt;&lt;/div&gt;\n\nCSS代码：\n.wrapper &gt; div:only-of-type &#123;  background: orange;&#125;\n\n\n\n6.16 CSS3选择器 :enabled选择器在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“**:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled**”对这些表单元素设置样式。\n示例演示\n通过“:enabled”选择器，修改文本输入框的边框为2像素的红色边框，并设置它的背景为灰色。\nHTML代码:\n&lt;form action=&quot;#&quot;&gt;  &lt;div&gt;    &lt;label for=&quot;name&quot;&gt;Text Input:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;可用输入框&quot;  /&gt;  &lt;/div&gt;   &lt;div&gt;    &lt;label for=&quot;name&quot;&gt;Text Input:&lt;/label&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;禁用输入框&quot;  disabled=&quot;disabled&quot; /&gt;  &lt;/div&gt;&lt;/form&gt;  \n\nCSS代码：\ndiv&#123;  margin: 20px;&#125;input[type=&quot;text&quot;]:enabled &#123;  background: #ccc;  border: 2px solid red;&#125;\n\n\n\n6.17 CSS3选择器 :disabled选择器“**:disabled”选择器刚好与“:enabled**”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。\n示例演示\n通过“**:disabled**”选择器，给不可用输入框设置明显的样式。\nHTML代码：\n&lt;form action=&quot;#&quot;&gt;  &lt;div&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;我是可用输入框&quot; /&gt;  &lt;/div&gt;  &lt;div&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;我是不可用输入框&quot; disabled /&gt;  &lt;/div&gt;&lt;/form&gt;  \n\n\nCSS代码\nform &#123;  margin: 50px;&#125;div &#123;  margin-bottom: 20px;&#125;input &#123;  background: #fff;  padding: 10px;  border: 1px solid orange;  border-radius: 3px;&#125;input[type=&quot;text&quot;]:disabled &#123;  background: rgba(0,0,0,.15);  border: 1px solid rgba(0,0,0,.15);  color: rgba(0,0,0,.15);&#125;\n\n\n\n6.18 CSS3选择器 :checked选择器在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“**:checked**”表示的是选中状态。\n示例演示：\n通过“:checked”状态来自定义复选框效果。\nHTML代码\n&lt;form action=&quot;#&quot;&gt;  &lt;div class=&quot;wrapper&quot;&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; id=&quot;usename&quot; /&gt;&lt;span&gt;√&lt;/span&gt;    &lt;/div&gt;    &lt;lable for=&quot;usename&quot;&gt;我是选中状态&lt;/lable&gt;  &lt;/div&gt;    &lt;div class=&quot;wrapper&quot;&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;input type=&quot;checkbox&quot;  id=&quot;usepwd&quot; /&gt;&lt;span&gt;√&lt;/span&gt;    &lt;/div&gt;    &lt;label for=&quot;usepwd&quot;&gt;我是未选中状态&lt;/label&gt;  &lt;/div&gt;&lt;/form&gt; \n\nCSS代码：\nform &#123;  border: 1px solid #ccc;  padding: 20px;  width: 300px;  margin: 30px auto;&#125;.wrapper &#123;  margin-bottom: 10px;&#125;.box &#123;  display: inline-block;  width: 20px;  height: 20px;  margin-right: 10px;  position: relative;  border: 2px solid orange;  vertical-align: middle;&#125;.box input &#123;  opacity: 0;  position: absolute;  top:0;  left:0;&#125;.box span &#123;  position: absolute;  top: -10px;  right: 3px;  font-size: 30px;  font-weight: bold;  font-family: Arial;  -webkit-transform: rotate(30deg);  transform: rotate(30deg);  color: orange;&#125;input[type=&quot;checkbox&quot;] + span &#123;  opacity: 0;&#125;input[type=&quot;checkbox&quot;]:checked + span &#123;  opacity: 1;&#125;\n\n\n\n6.19 CSS3选择器 ::selection选择器“**::selection”伪元素是用来匹配突出显示**的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示的，效果如下图所示：\n从上图中可以看出，用鼠标选中“专注IT、互联网技术”、“纯干货、学以致用”、“没错、这是免费的”这三行文本中，默认显示样式为：蓝色背景、白色文本。\n有的时候设计要求,不使用上图那种浏览器默认的突出文本效果，需要一个与众不同的效果，此时“**::selection”伪元素就非常的实用。不过在Firefox浏览器**还需要添加前缀。\n示例演示:\n通过“::selection”选择器，将Web中选中的文本背景变成红色，文本变成绿色。\nHTML代码：\n&lt;p&gt;“::selection”伪元素是用来匹配突出显示的文本。浏览器默认情况下，选择网站文本是深蓝的背景，白色的字体，&lt;/p&gt;\n\nCSS代码：\n::-moz-selection &#123;  background: red;  color: green;&#125;::selection &#123;  background: red;  color: green;&#125;\n\n\n\n注意：\n1、IE9+、Opera、Google Chrome 以及 Safari 中支持 ::selection 选择器。\n2、Firefox 支持替代的 ::-moz-selection。\n","categories":["前端"],"tags":["css"]},{"title":"加解密算法及其特征","url":"/2022/11/27/%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/","content":"一.base系列1.特征\nBase16：结尾没有等号，数字要多于字母； \nBase32：字母要多于数字，明文数量超过 10 个，结尾可能会有很多等号；\nBase58：结尾没有等号，字母要多于数字；\nBase64：一般情况下结尾都会有 1 个或者 2 个等号，明文很少的时候可能没有；\nBase85：等号一般出现在字符串中间，含有一些奇怪的字符；\nBase100：密文由 Emoji 表情组成\n\n2.加密方式每\n","categories":["网安"],"tags":["逆向"]},{"title":"汇编","url":"/2022/11/27/%E6%B1%87%E7%BC%96/","content":"标志寄存器：\nOF overflow flag 溢出标志 操作数超出机器能表示的范围表示溢出,溢出时为1.\nSF sign Flag 符号标志记录运算结果的符号,结果负时为1.  ZF zero flag 零标志 运算结果等于0时为1,否则为0.\nCF carry flag   进位标志 最高有效位产生进位时为1,否则为0.\nAF auxiliary carry flag 辅助进位标志   运算时,第3位向第4位产生进位时为1,否则为0.  \nPF parity flag 奇偶标志   运算结果操作数位为1的个数为偶数个时为1,否则为0.\nDF direcion flag 方向标志   用于串处理.DF&#x3D;1时,每次操作后使SI和DI减小.DF&#x3D;0时则增大.\nIF interrupt flag 中断标志   IF&#x3D;1时,允许CPU响应可屏蔽中断,否则关闭中断.\nTF trap flag 陷阱标志 用于调试单步操作.\n\n指令：mov:赋值指令,相当于高级语言的’&#x3D;’ 语法规则: mov 寄存器,value eg: mov ax,10h\ninc:自增一,相当于高级语言中的’++’ 语法规则:inc 寄存器 eg:inc ax\ndec:自减一,相当于高级语言中的’–’ 语法规则:dec 寄存器 eg:dec ax\nadd:加法指令(+),将两数相加的结果保存在第一个寄存器中 语法规则:add 寄存器,寄存器&#x2F;value eg: add ax,bx add ax,2\nsub:减法指令(-),将两数相减的结果保存在第一个寄存器中 语法规则:sub 寄存器,寄存器&#x2F;value eg: sub ax,bx sub ax,2\nmul:乘法指令(*),将两数相乘的结果保存在第一个寄存器中 语法规则:mul 寄存器,寄存器&#x2F;value eg: mul ax,bx mul ax,2\ndiv:除法指令(&#x2F;),将两数相除的结果保存在第一个寄存器中 语法规则:div 寄存器,寄存器&#x2F;value eg: div ax,bx div ax,2\nadc:进位加法,当计算大数字(超过32位)时,低位保存在ax中,高位保存在dx中,运用adc指令可进行进位运算 有进位cf&#x3D;1,否则cf&#x3D;0,相当于 dx&#x3D;ax+bx+cf 语法规则:adc 寄存器,寄存器&#x2F;value eg: adc dx,axadc dx,0220h\nsbb:借位减法,当计算大数字(超过32位)时,低位保存在ax中,高位保存在dx中,运用adc指令可进行借位运算 有进位cf&#x3D;1,否则cf&#x3D;0,相当于 dx&#x3D;ax-bx-cf 语法规则:sbb 寄存器,寄存器&#x2F;value eg: sbb dx,axsbb dx,0220h\njmp:转移指令,可手动指定cpu执行指定地址(cs&#x2F;ip)的代码 语法规则: jmp short xxxx(短转移)jmp xxxx:xxxx(长转移) eg: JMP 1000H 段内直接转移，转移地址的偏移量由指令给出 JMP CX 段内间接转移，转移地址的偏移量由CX指出 JMP 1000H:2000H 段间直接转移，段码和偏移量由指令给出JMP DWORD PTR [SI] 段间间接转移转移地址在SI所指地址开始的4个单元中\nloop:循环指令,寄存器cx存储循环次数,从指定地址开始循环,相当于高级语言的while和for循环 语法规则: loop 目标地址 eg: s: mov cx,3 add ax,2 loop s\nret：返回 退出一个函数\ncall：语法：call 子函数地址\npush&#x2F;pop 出入栈\npushad&#x2F;popad ：PUSHAD也叫保护现场，就是把我们的寄存器压入栈中pushad是把eax，ecx，edx，ebx，esp、ebp，esi，edi依次压入栈中，ESP会减少32\n在手动去壳时需要关注的，壳在努力让操作系统认为程序没有加壳，所以在pushad后再popad恢复现场\n跳转指令及条件：\n","categories":["网安"],"tags":["逆向"]},{"title":"c语言讲座","url":"/2022/12/13/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E9%A2%98/","content":"c语言程序设计题温馨提示：写程序一定要自己动手，只看不做是学不会的。\n一.分支与跳转（关键字：if else switch continue break case default goto)\n1．利用条件运算符的嵌套来完成此题：学习成绩&gt;&#x3D;90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。\n#include &lt;stdio.h&gt;int main()&#123;\tint sc;\tscanf(&quot;%d&quot;, &amp;sc);\tif (sc &gt;= 90)\t&#123;\t\tprintf(&quot;A\\n&quot;);\t&#125;\telse if (sc &gt;= 60 &amp;&amp; sc &lt;= 89)//注意这里不可以写成 60&lt;=sc&lt;=89 \t&#123;\t\tprintf(&quot;B\\n&quot;);\t&#125;\telse\t&#123;\t\tprintf(&quot;C\\n&quot;);\t&#125;\treturn 0;&#125;\n\n\n\n二.循环（while  for  do…while)\n1.计算下列表达式：s&#x3D;1！+2！+3！+4！+……+10！\n#include &lt;stdio.h&gt;int main()&#123;\tint i;\tint t=1, s=0;\tfor (i = 1; i &lt;= 10; i++)\t&#123;\t\tt *= i;\t\ts += t;\t&#125;\tprintf(&quot;%d&quot;, s);\treturn 0;&#125;\n\n2.九九乘法表（3种循环解决）\nfor循环：\n#include &lt;stdio.h&gt;int main()&#123;\tint i;      int j;\tfor (i = 1; i &lt;= 9; i++)\t&#123;\t\tfor (j = 1; j &lt;= i; j++)\t\t&#123;\t\t\tprintf(&quot;%d*%d=%2d &quot;, j, i, i * j);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\treturn 0;&#125;\n\nwhile：\n#include &lt;stdio.h&gt;int main()&#123;\tint row = 1;\twhile (row &lt;= 9)\t&#123;   \t  \tint col = 1;    \twhile (col &lt;= row)     \t&#123;       \t  \tprintf(&quot;%d * %d = %d\\t&quot;, col, row, col * row);         \tcol += 1;         &#125;    printf(&quot;\\n&quot;);     row += 1;      return 0;&#125;\n\n do while：\n#include&lt;stdio.h&gt;int main ()&#123;\tint i=1,j;\tdo&#123;\t\tj=1;\t\tdo&#123;\t\t\tprintf(&quot;%d*%d=%d &quot;,i,j,i*j);\t\t\tj++;\t\t&#125;while(j&lt;=i);\t\ti++; \t\tprintf(&quot;\\n&quot;); \t&#125;while(i&lt;=9);&#125; \n\n3.用公式计算π的近似值：\nπ&#x2F;4≈1- 1&#x2F;3+1&#x2F;5-1&#x2F;7+⋯，直到最后一项的绝对值小于10-8为止\n输出格式为：”PI&#x3D;%7.5f\\n”。\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123;\tdouble a=1;\tdouble sum = 0;\tint n=0;\twhile (1)\t&#123;\t\tsum +=pow(-1,n)* (1.0 / a);\t\ta += 2;\t\tn++;\t\tif ((1.0 / a) &lt; 1e-8)\t\t&#123;\t\t\tbreak;\t\t&#125;\t&#125;\tprintf(&quot;%PI=%7.5f\\n&quot;, 4*sum);\treturn 0;&#125;\n\n\n\n三.数组1.将一个一维数组{1,2,3,4,5,6,7,8,9,10}的成员逆序后输出\n注意：正确的结果为：10 9 8 7 6 5 4 3 2 1\n#include&lt;stdio.h&gt;int main()&#123;  int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;  int t,i;  for(i=0;i&lt;5;i++)   &#123;    t=a[i];      a[i]=a[9-i];      a[9-i]=t;   &#125;  for(i=0;i&lt;10;i++)    printf(&quot;%2d&quot;,a[i]);      printf(&quot;\\n&quot;);      return 0;&#125;\n\n2.打印杨辉三角前n行（二维数组）\n#include &lt;stdio.h&gt;int arr[31][31] = &#123; 0 &#125;;void init(int n)&#123;\tint i, j;\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tfor (j = 0; j &lt;= i; j++)\t\t&#123;\t\t\tif (j == 0 || j == i)\t\t\t\tarr[i][j] = 1;\t\t\telse\t\t\t\tarr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];\t\t&#125;\t&#125;&#125;int main()&#123;\tinit(30);\tint n, i, j;\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 0; i &lt; n; i++)\t&#123;\t\tfor (j = 0; j &lt;= i; j++)\t\t&#123;\t\t\tif (j != i)\t\t\t\tprintf(&quot;%d &quot;, arr[i][j]);\t\t\telse\t\t\t\tprintf(&quot;%d&quot;, arr[i][j]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;                1            1   2   1          1   3   3   1        1   4   6   4   1\n\n\n\n四.经典题1.输入两个正整数m和n，求其最大公约数和最小公倍数。\n（辗转相除法；最小公倍数&#x3D;两数相乘&#x2F;最大公约数）\n#include &lt;stdio.h&gt;int main()&#123;\tint a, b, num1, num2, temp;\tscanf(&quot;%d%d&quot; ,&amp;num1, &amp;num2);\tif (num1 &lt; num2)\t&#123;\t\ttemp = num1;\t\tnum1 = num2;\t\tnum2 = temp;\t&#125;\telse\t&#123;\t\ta = num1;\t\tb = num2;\t&#125;\twhile (b != 0)\t&#123;\t\ttemp = a % b;\t\ta = b;\t\tb = temp;\t&#125;\tprintf(&quot;最大公约数：%d\\n &quot;, a);\tprintf(&quot;最小公倍数: %d\\n&quot;,num1 * num2 / a);\treturn 0;&#125;//求最大公约数可以使用gcd函数//自己实现：int gcd(int a,int b) &#123;    return b &gt; 0 ? gcd(b, a % b) : a;&#125;\n\n2.水仙花数：\n打印出所有得“水仙花数”，所谓“水仙花数”是指一个3位数，其各位数字的立方和等于该数本身，例如，152是水仙花数，因为153＝1×1×1＋5×5×5＋3×3×3。\n#include &lt;stdio.h&gt;int main()&#123;  int i,j,k,n;  printf(&quot;水仙花数是:&quot;);  for(n=100;n&lt;1000;n++)  &#123;\t  \ti=n/100;/*分解出百位*/    j=n/10%10;/*分解出十位*/    k=n%10;/*分解出个位*/    if(i*100+j*10+k==i*i*i+j*j*j+k*k*k)      printf(&quot;%-5d&quot;,n);  &#125;    return 0;&#125;\n\n3.反转数：给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零\n#include &lt;stdio.h&gt;int main()&#123;\tint N;\tint ret=0;\tscanf(&quot;%d&quot;,&amp;N);\twhile(N)\t&#123;\t\tret=ret*10;\t\tret=ret+N%10;\t\tN=N/10;\t&#125;\tprintf(&quot;%d&quot;,ret);\treturn 0;&#125; \n\n4.求素数（2–100之间）\nvoid FindPrime()&#123;\tint i = 0; int j = 0;\tfor (i = 1; i &lt;= 100; i++)//这里可以直接+=2，因为偶数不可能是素数\t&#123;\t\tfor ( j = 2; j &lt;= i; j++)//还可以优化为sqrt（i）\t\t&#123;\t\t\tif (i % j == 0)//如果余数为0，则不是素数，结束循环\t\t\t\tbreak;\t\t&#125;\t\tif(i==j)//如果j一直加到和i相等，证明i是素数\t\tprintf(&quot;%d &quot;, i);\t&#125;&#125;int main()&#123;\tFindPrime();    return 0;&#125;\n\n5.冒泡排序：（排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序） - VisuAlgo）\n从键盘输入的10个整数按从小到大的顺序排序后输出\n#include&lt;stdio.h&gt;\tvoid main()&#123;\tint n[10] = &#123; 25,35,68,79,21,13,98,7,16,62 &#125;;//定义一个大小为10的数组\tint i, j, temp;\tfor (i = 1; i &lt;= 9; i++)//外层循环是比较的轮数，数组内有10个数，那么就应该比较10-1=9轮\t&#123;\t\tfor (j = 0; j &lt;= 9 - i; j++)//内层循环比较的是当前一轮的比较次数，例如：第一轮比较9-1=8次，第二轮比较9-2=7次\t\t&#123;\t\t\tif (n[j] &gt; n[j + 1])//相邻两个数如果逆序，则交换位置\t\t\t&#123;\t\t\t\ttemp = n[j];\t\t\t\tn[j] = n[j + 1];\t\t\t\tn[j + 1] = temp;\t\t\t&#125;\t\t&#125;\t&#125;\tprintf(&quot;排序过后的数顺序:\\n&quot;);\tfor (i = 0; i &lt; 10; i++)\tprintf(&quot;%-4d&quot;, n[i]);\tprintf(&quot;\\n&quot;);&#125;\n\n五.指针1.使用指针方法，计算两个数组中各元素对应位置的和，和的结果存入第三个数组中，然后输出。\n#include &lt;stdio.h&gt;void count(int *p1,int *p2,int *p3,int x);int main()&#123;\tint arr01[4]=&#123;2,4,5,8&#125;;\tint arr02[4]=&#123;1,0,4,6&#125;;\tint arr03[4];\tcount(arr01,arr02,arr03,4);&#125; void count(int *p1,int *p2,int *p3,int x)&#123;\tint i;\tfor(i=0;i&lt;x;i++)\t&#123;\t\t*(p3+i) = (*(p1+i))+ (*(p2+i));\t&#125; \tprintf(&quot;两个数组对应各元素和分别为：\\n&quot;);\tfor(i=0;i&lt;x;i++)\t&#123;\t\tprintf(&quot;%d &quot;,p3[i]);\t&#125;&#125;\n\n2.输出值为：\n（二级）\n#include &lt;stdio.h&gt;int main()&#123;\tchar* a[] = &#123; &quot;work&quot;,&quot;at&quot;,&quot;alibaba&quot; &#125;;\tchar** pa = a;\tpa++;\tprintf(&quot;%s\\n&quot;, *pa);\treturn 0;&#125;\n\nchar* a[]为指针数组，是数组用来存放指针，该数组有三个元素，分别是三个字符串的地址。\npa &#x3D; a；是将数组a的首元素的地址放入二级指针变量pa中。\npa++：即为a++，从数组首元素的地址变为第二个元素的地址。\n*pa：此时pa为a[1]，也就是第二个元素表示字符串的首地址，以%s的形式输出，依次打印字符串。\n六.递归1.用递归的方法求正整数N的阶乘\n#include&lt;stdio.h&gt;long jiecheng(int n)&#123;  long p;  if(n==0||n==1)//0的阶乘为1    p=1;      else     p=n*jiecheng(n-1);  return p;&#125;int main()&#123;  int n;  scanf(&quot;%d&quot;,&amp;n);  printf(&quot;%d&quot;,jiecheng(n));  return 0;&#125;\n\n至此，面向考试的题就都讲完啦,最后祝大家都能在考试中取得自己满意的成绩！\n","categories":["讲座"],"tags":["c语言"]},{"title":"wifi攻击","url":"/2022/12/14/%E5%A5%BD%E7%8E%A9%E7%9A%84wifi%E7%A0%B4%E8%A7%A3/","content":"记录一下好玩的wifi破解仅供学习研究，不要非法攻击！\n\n​    fluxion 进入对应目录下\n\n​     .&#x2F;fluxion.sh 进入程序\n\n先输入2来查找周围wifi\n\n\n\n4.接下来按3就是扫描所有频段的wifi\n5.扫描到目标wifi后就可以按ctrl+c停止扫描\n6.输入目标wifi前的序号\n\n7.接下来一路按推荐走就可以了\n8.开始抓握手包\n成功后显示这个：\n9.接着开始选择攻击方式\n创建一个钓鱼wifi\n10继续一路推荐\n需要注意的是SSL证书那里选第三项没有证书\n11.再选断开网络，选择一个语言，这个是指目标接收到信息的语言，选中文\n12.此时，会弹出6个窗口，观察右上角的\n\n这个时候，目标断开网络并且会连上我们创建的虚假同名wifi，并会进行网页劫持（DNS劫持），强制用户输入密码：\n\n等用户上钩就可以了。\n","categories":["网安"],"tags":["web"]},{"title":"数据结构","url":"/2022/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"线性表顺序表单链表数组模拟：\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int n;int e[N], ne[N], head, idx;//对链表进行初始化void init() &#123;    head = -1;//最开始的时候，链表的头节点要指向-1，    //为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束    /*    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针    当它在初始化的时候指向-1，来表示链表里没有内容。    */    idx = 0;//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找    //第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下    //标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！    /*    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问的    时候，是靠着指针，也就是靠ne[]来访问的，这样下标乱，也就我们要做的事不相关了。    另外，我们遍历链表的时候也是这样，靠的是ne[]    */&#125;//将x插入到头节点上void int_to_head(int x) &#123;//和链表中间插入的区别就在于它有head头节点    e[idx] = x;//第一步，先将值放进去    ne[idx] = head;//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了    //先在只是做到了第一步，将元素x的指针指向了head原本指向的    head = idx;//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）    idx++;//指针向下移一位，为下一次插入元素做准备。&#125;//e[idx]=x;// ne[idx]=head;// head=idx;// idx++;//将x插入到下标为k的点的后面void add(int k, int x) &#123;    e[idx] = x;//先将元素插进去    e[idx]=x;ne[idx]=ne[k];ne[k]=idx;idx++;    ne[idx] = ne[k];//让元素x配套的指针，指向它要占位的元素的下一个位置    ne[k] = idx;//让原来元素的指针指向自己    idx++;//将idx向后挪&#125;//将下标是k的点后面的点个删掉void remove(int k) &#123;    ne[k] = ne[ne[k]];//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。&#125;//ne[k]=ne[ne[k]]//传进来的是k-1int main() &#123;    cin &gt;&gt; n;    init();//初始化    for (int i = 0; i &lt; n; i++)     &#123;        char s;        cin &gt;&gt; s;        if (s == &#x27;H&#x27;) &#123;            int x;            cin &gt;&gt; x;            int_to_head(x);        &#125;        if (s == &#x27;D&#x27;) &#123;            int k;            cin &gt;&gt; k;            if (k == 0) head = ne[head];//删除头节点            else remove(k - 1);//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1        &#125;        if (s == &#x27;I&#x27;) &#123;            int k, x;            cin &gt;&gt; k &gt;&gt; x;            add(k - 1, x);//同样的，第k个数，和下标不同，所以要减1        &#125;    &#125;    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;        return 0;&#125;\n\n\n\n双链表指针域存下一个和上一个的地址\n循环链表头指尾，尾指头呗\n静态链表栈先进后出\n应用：括号匹配\n表达式求值（中缀转后缀&#x2F;前缀）\n队列先进先出\n数组模拟：\n我觉得是一个双指针在维护这个数据结构吧先进的先出  后进的后出 tt就是维护队尾位置的下标 如果要队头出列的话 hh++就可以 遍历的时候i&lt;&#x3D;hh就可以了（输出时候队头开始遍历）\n#include&lt;iostream&gt;#include &lt;string&gt;using namespace std;const int N = 1e6 + 10;int qu[N], hh = 0, tt = -1;//初始化很重要！！！int main()&#123;    int n;    cin &gt;&gt; n;    while (n--)    &#123;        int x;        string a;        cin &gt;&gt; a;        if (a == &quot;push&quot;)            cin &gt;&gt; x, qu[++tt] = x;//元素只能队尾入队        else if (a == &quot;pop&quot;)            hh++;//注意元素只能队头弹出，且是 ++        else if (a == &quot;empty&quot;)//队内是否为空        &#123;            if (tt &lt; hh)                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;        else//查询队头            cout &lt;&lt; qu[hh] &lt;&lt; endl;    &#125;         for (int i = tt; i &lt;= hh; i++)    &#123;        printf(&quot;%d&quot;, qu[i]);    &#125;        return 0;&#125;\n\n双端队列两端都可以出和进\n循环队列圈圈\n应用：bfs\n字符串KMP算法匹配字符串的一种优化\n原始匹配方法缺点：当字串能够与主串部分匹配时，主串的扫描指针i会经常回溯，最坏时间复杂度为O(mn)\nkmp算法：当字串能够与主串部分匹配时，不再让主串的指令i回溯，而是让字串的j指针回溯到j&#x3D;next[j]的位置，算法平均时间复杂度O(m+n)\n那么关键就在于如何求解next数组了，手算的方法就是在该位置前的串的最长相等前后缀长度+1， 特别的 next[1]&#x3D;0  next[2]&#x3D;1\neg：ababaa   在j&#x3D;6时 ：最长前后缀aba  所以next[6]&#x3D;4;\n​\t\t\t\t\t   在j&#x3D;5时： 最长前后缀ab 所以 next[5]&#x3D;3;\n也可以看出如果匹配过程中很少出现可以部分匹配的情况，kmp算法和朴素匹配也差不多\n初始化：\ntypedef struct s &#123;\tchar ch[1024];\tint length;&#125;sstring;\n\nKMP算法：\nint KMP(sstring s, sstring t)&#123;\tint i = 1;\tint j = 1;\tint next[1024];\tGet_next(t, next);\twhile (i &lt;= s.length &amp;&amp; j &lt;= t.length)\t&#123;\t\tif (j == 0 || s.ch[i] == t.ch[j])\t\t&#123;\t\t\ti++;\t\t\tj++;\t\t&#125;\t\telse\t\t&#123;\t\t\tj = next[j];\t\t&#125;\t&#125;\tif (j &gt; t.length)\t&#123;\t\treturn i - t.length;\t&#125;\telse\t\treturn 0;&#125;\n\n求解next数组：（这有两个公式）\nvoid Get_next(sstring t,int next[])&#123;\tint i=1,j=0;\tnext[1] = 0;\twhile (i &lt; t.length)\t&#123;\t\tif (j == 0 || t.ch[i] == t.ch[j])\t\t&#123;\t\t\ti++;\t\t\tj++;\t\t\tnext[i] = j;\t\t&#125;\t\telse\t\t&#123;\t\t\tj = next[j];\t\t&#125;\t&#125;&#125;\n\n优化求解next：\nint nextval[1024];nextval[1]=0;for(int j=2;j&lt;t.length;j++)&#123;    if(t.ch[next[j]]==t.ch[j])    &#123;        nextval[j]=nextval[next[j]];    &#125;    else        nextval[j]=next[j];&#125;\n\neg：           a b a b a a \n序号j           1 2 3 4 5 6 \nnext:           0 1 1 2 3 4  \nnextval：    0 1 0 1 0 4     \n从第二个开始，b与其对应的next[2]&#x3D;1即a比较，不相同，那么保持不动；\n第三个a与其next[3]&#x3D;1即a比较，相同，那么将他的nextval改为前面的next的值，就是循环里的else\n以此类推\n树二叉树的存储顺序存储（满二叉树）从左到右，由上至下依次将结点存入一个顺序表中，（由1开始）有以下性质：\n左儿子：i*2；\n右儿子：i*2+1；\n父节点：i&#x2F;2；\nstruct TreeNode &#123;\tint value;\tbool isEmpty;&#125;;TreeNode t[100];for (int i = 0; i &lt; 100; i++)&#123;\tt[i].isEmpty = true;&#125;\n\n链式存储当一颗二叉树不是满二叉树时，如果继续顺序存储，那么他们的下标将变得无序，若是强制补全二叉树（完全二叉树）再来存，那么可能会浪费很多空间，所以采用链式存储的方式：\nstruct BiTNode&#123;    int value;    struct BiTNode* lchild;    struct BiTNode* rchild;&#125;;\n\n\n\n二叉树的遍历先序遍历根左右\nvoid Preorder(BiTree T)&#123;    if(T!=NULL)    &#123;        visit(T);        Preorder(T-&gt;lchild);//递归遍历左子树        Preorder(T-&gt;rchild);//递归遍历右子树    &#125;&#125;\n\n中序遍历左根右\n后序遍历左右根\n（这三种就是那三句的顺序变一下就ok）\n层序遍历一层一层遍历\n利用一个队列来实现，有种bfs的感觉\n线索二叉树存储\nstruct BiTNode&#123;    int value;    struct BiTNode* lchild;    struct BiTNode* rchild;    int ltag,rtag //tag==0 表示指向儿子 ==1 表示指向线索&#125;;\n\n普通树普通树存储双亲表示法（顺序存储）每个结点的指针指向父亲结点\n优点：找父节点方便\n缺点：找儿子结点不方便\n孩子表示法（顺序＋链式存储）每个结点的指针指向儿子结点\n优点：找儿子节点方便\n缺点：找父节点不方便\n孩子兄弟表示法（链式存储）两个指针分别存左孩子和（左孩子的）右兄弟的指针 \n应用：树和二叉树的相互转换 ；森林和二叉树的相互转换\n普通树的遍历原理就是二叉树那样遍历的 ，没有了中序遍历，还剩三种\n森林遍历先序遍历等效于依次对子树进行先序遍历\n中序遍历等效于依次对子树进行后序遍历  是后序\n","categories":["数据结构与算法"],"tags":["基础"]}]